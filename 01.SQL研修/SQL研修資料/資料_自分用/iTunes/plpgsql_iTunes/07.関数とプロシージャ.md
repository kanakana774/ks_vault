### PL/pgSQL の基本的な構文と制御構造 (続き)

#### 6. 関数とプロシージャ

PL/pgSQL の最も一般的な使用方法は、関数（Function）とプロシージャ（Procedure）を作成することです。これらはデータベースサーバー上で実行されるコードのブロックであり、SQL クエリをラップしたり、複雑なビジネスロジックを実装したりするために使用されます。

##### 6.1. 関数の作成 (`CREATE FUNCTION`)

関数は値を返し、主にクエリ内で使用されることを意図しています。

###### 引数と戻り値の定義

関数は 0 個以上の引数を取り、単一の値を返すか、行のセットを返すことができます。

**構文:**

```sql
CREATE [ OR REPLACE ] FUNCTION function_name (
    [ argument_name data_type [ DEFAULT default_expr ] [, ...] ]
)
RETURNS return_data_type AS $$
[ DECLARE
    declarations ]
BEGIN
    statements;
    RETURN expression; -- RETURNS data_type の場合
END;
$$ LANGUAGE plpgsql;
```

**例 (単一値の戻り値):** 指定された `artist_id` のアーティスト名を取得する関数。

```sql
CREATE OR REPLACE FUNCTION get_artist_name_by_id(p_artist_id INTEGER)
RETURNS TEXT AS $$
DECLARE
    v_artist_name artist.name%TYPE;
BEGIN
    SELECT name INTO v_artist_name
    FROM artist
    WHERE artist_id = p_artist_id;

    RETURN v_artist_name;
END;
$$ LANGUAGE plpgsql;
```

###### `RETURNS data_type`, `RETURNS TABLE`, `RETURNS SETOF record/data_type`

- **`RETURNS data_type`**: 単一のスカラー値を返します。上記の例のように `RETURNS TEXT` など。
- **`RETURNS TABLE (column_name data_type, ...)`**: 複数の列を持つ行のセットを返します。これは、関数がテーブルのように振る舞うことを可能にします。
- **`RETURNS SETOF record/data_type`**: 構造が不明なレコードのセット、または指定された型の単一列のセットを返します。通常は `FOR record_var IN query LOOP RETURN NEXT record_var; END LOOP;` の形式で使用します。

**例 (`RETURNS TABLE`):** 指定された国からの顧客リストを返す関数。

```sql
CREATE OR REPLACE FUNCTION get_customers_from_country(p_country TEXT)
RETURNS TABLE (
    customer_id_out INTEGER,
    full_name TEXT,
    email_address TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT c.customer_id,
           c.first_name || ' ' || c.last_name,
           c.email
    FROM customer c
    WHERE c.country = p_country;
END;
$$ LANGUAGE plpgsql;
```

**`RETURN QUERY`** は、`SELECT` ステートメントの結果全体を直接返すための便利な構文です。

**例 (`RETURNS SETOF record`):** 指定されたアーティストのアルバムタイトルとそのアーティスト ID を返す関数。

```sql
CREATE OR REPLACE FUNCTION get_albums_by_artist(p_artist_name TEXT)
RETURNS SETOF album AS $$ -- albumテーブルの行全体を返す
DECLARE
    v_artist_id artist.artist_id%TYPE;
BEGIN
    -- まずアーティストIDを取得
    SELECT artist_id INTO v_artist_id
    FROM artist
    WHERE name = p_artist_name;

    -- 見つからない場合は何も返さない
    IF v_artist_id IS NULL THEN
        RETURN;
    END IF;

    -- そのアーティストのアルバムをループで処理し、各行を返す
    FOR r IN SELECT * FROM album WHERE artist_id = v_artist_id LOOP
        RETURN NEXT r;
    END LOOP;
    RETURN; -- ループが終了したら関数を終了
END;
$$ LANGUAGE plpgsql;
```

##### 6.2. プロシージャの作成 (`CREATE PROCEDURE`)

プロシージャは値を返しません（`RETURNS VOID` に相当）。主にデータベースの状態を変更する操作（データ挿入、更新、削除）を実行するために使用され、トランザクション制御を内部に持つことができます。

###### 引数 (`IN`, `OUT`, `INOUT`)

プロシージャでは、引数のモードを指定できます。

- `IN` (デフォルト): 入力として使用。プロシージャ内で値を変更しても、呼び出し元には影響しません。
- `OUT`: 出力として使用。プロシージャ内で設定された値が、呼び出し元に返されます。
- `INOUT`: 入力としても出力としても使用。

**構文:**

```sql
CREATE [ OR REPLACE ] PROCEDURE procedure_name (
    [ [ argmode ] argument_name data_type [ DEFAULT default_expr ] [, ...] ]
) AS $$
[ DECLARE
    declarations ]
BEGIN
    statements;
END;
$$ LANGUAGE plpgsql;
```

**例 (`IN` 引数):** 指定された顧客 ID のメールアドレスを更新するプロシージャ。

```sql
CREATE OR REPLACE PROCEDURE update_customer_email(
    IN p_customer_id INTEGER,
    IN p_new_email TEXT
) AS $$
BEGIN
    UPDATE customer
    SET email = p_new_email
    WHERE customer_id = p_customer_id;

    RAISE NOTICE 'Customer ID % のメールアドレスを % に更新しました。', p_customer_id, p_new_email;
END;
$$ LANGUAGE plpgsql;
```

**例 (`OUT` 引数):** 指定されたアーティスト ID のアーティスト名を検索し、`OUT` 引数で返すプロシージャ。

```sql
CREATE OR REPLACE PROCEDURE get_artist_name_out(
    IN p_artist_id INTEGER,
    OUT p_artist_name TEXT
) AS $$
BEGIN
    SELECT name INTO p_artist_name
    FROM artist
    WHERE artist_id = p_artist_id;

    IF p_artist_name IS NULL THEN
        RAISE NOTICE 'Artist ID % は見つかりませんでした。', p_artist_id;
    END IF;
END;
$$ LANGUAGE plpgsql;
```

###### トランザクション制御 (COMMIT, ROLLBACK)

プロシージャ内では、`COMMIT` および `ROLLBACK` ステートメントを使用できます。これにより、プロシージャの内部で複数の DML 操作を含むサブトランザクションを管理できます。関数内ではこれらのコマンドは使用できません。

**例:** 複数の操作を行い、途中でエラーが発生した場合はロールバックするプロシージャ。

```sql
CREATE OR REPLACE PROCEDURE perform_multi_operations()
AS $$
DECLARE
    new_artist_id INTEGER;
    new_album_id INTEGER;
    error_occurred BOOLEAN := FALSE;
BEGIN
    RAISE NOTICE '--- 複数操作プロシージャ開始 ---';

    -- トランザクションブロック開始
    BEGIN
        -- 1. 新しいアーティストを挿入
        INSERT INTO artist (name) VALUES ('Temporary Artist') RETURNING artist_id INTO new_artist_id;
        RAISE NOTICE '新しいアーティストID: % を挿入しました。', new_artist_id;

        -- 2. 新しいアルバムを挿入 (正しいartist_idを使用)
        INSERT INTO album (title, artist_id) VALUES ('Temporary Album 1', new_artist_id) RETURNING album_id INTO new_album_id;
        RAISE NOTICE '新しいアルバムID: % を挿入しました。', new_album_id;

        -- 意図的にエラーを発生させる (例: 存在しないIDでアルバムを挿入)
        -- INSERT INTO album (title, artist_id) VALUES ('Temporary Album Bad', 99999);
        -- RAISE NOTICE 'この行は実行されません。'; -- エラーでスキップ

        -- 全ての操作が成功した場合のみコミット
        COMMIT;
        RAISE NOTICE '全ての操作が正常に完了し、コミットされました。';

    EXCEPTION
        WHEN OTHERS THEN
            -- エラーが発生した場合、ロールバック
            ROLLBACK;
            RAISE WARNING 'エラーが発生しました: %。トランザクションはロールバックされました。', SQLERRM;
            error_occurred := TRUE;
    END; -- トランザクションブロック終了

    IF NOT error_occurred THEN
        RAISE NOTICE '成功: アーティストID % とアルバムID % は永続化されました。', new_artist_id, new_album_id;
    ELSE
        RAISE NOTICE '失敗: 変更はデータベースに反映されませんでした。';
    END IF;

    RAISE NOTICE '--- 複数操作プロシージャ終了 ---';
END;
$$ LANGUAGE plpgsql;
```

##### 6.3. 関数の呼び出し

関数は `SELECT` ステートメントの中で呼び出します。`FROM` 句でテーブル関数として使用することもできます。

**例:**

```sql
-- 単一値関数の呼び出し
SELECT get_artist_name_by_id(5);

-- テーブル関数の呼び出し
SELECT * FROM get_customers_from_country('Canada');

-- RETURNS SETOF record 関数の呼び出し
SELECT album_id, title FROM get_albums_by_artist('AC/DC');
```

##### 6.4. プロシージャの呼び出し (`CALL`)

プロシージャは `CALL` ステートメントを使って呼び出します。

**例:**

```sql
-- IN引数のみのプロシージャ呼び出し
CALL update_customer_email(1, 'new_customer1_email@example.com');

-- OUT引数を持つプロシージャ呼び出し
-- OUT引数の値は、呼び出し元で変数として受け取るか、NULLを指定して無視できる
DO $$
DECLARE
    v_artist_name TEXT;
BEGIN
    CALL get_artist_name_out(1, v_artist_name);
    RAISE NOTICE 'プロシージャから返されたアーティスト名: %', v_artist_name;

    -- 存在しないIDの場合
    CALL get_artist_name_out(99999, v_artist_name);
    RAISE NOTICE 'プロシージャから返されたアーティスト名 (存在しないID): %', v_artist_name; -- NULLが返る
END
$$;

-- トランザクション制御を持つプロシージャの呼び出し
CALL perform_multi_operations();
```

##### 6.5. 関数の削除 (`DROP FUNCTION`)

関数を削除するには `DROP FUNCTION` を使用します。引数の型を指定する必要があります。

**構文:**

```sql
DROP FUNCTION [ IF EXISTS ] function_name ( [ argument_data_type [, ...] ] ) [ CASCADE | RESTRICT ];
```

**例:**

```sql
DROP FUNCTION IF EXISTS get_artist_name_by_id(INTEGER);
DROP FUNCTION IF EXISTS get_customers_from_country(TEXT);
DROP FUNCTION IF EXISTS get_albums_by_artist(TEXT);
```

##### 6.6. プロシージャの削除 (`DROP PROCEDURE`)

プロシージャを削除するには `DROP PROCEDURE` を使用します。引数の型を指定する必要があります。

**構文:**

```sql
DROP PROCEDURE [ IF EXISTS ] procedure_name ( [ argument_data_type [, ...] ] ) [ CASCADE | RESTRICT ];
```

**例:**

```sql
DROP PROCEDURE IF EXISTS update_customer_email(INTEGER, TEXT);
DROP PROCEDURE IF EXISTS get_artist_name_out(INTEGER, TEXT);
DROP PROCEDURE IF EXISTS perform_multi_operations();
```

---

### 練習問題

以下の指示に従って PL/pgSQL の関数とプロシージャを作成し、呼び出し、削除してください。

#### 問題 1: 単一値を返す関数の作成と呼び出し

1.  `get_track_price(p_track_id INTEGER)` という名前の関数を作成してください。
2.  この関数は、与えられた `track_id` の `unit_price` (`NUMERIC(10,2)`) を返します。
3.  関数内で、`SELECT INTO` を使用して価格を取得してください。
4.  トラックが見つからない場合、`NULL` を返してください。
5.  作成した関数を `SELECT` ステートメントで呼び出し、`track_id = 1` と `track_id = 99999` (存在しない ID) の両方で結果を確認してください。

#### 問題 2: `RETURNS TABLE` を使用する関数の作成と呼び出し

1.  `get_top_selling_tracks(p_limit INTEGER)` という名前の関数を作成してください。
2.  この関数は、最も多く販売されたトラックのリストを返します。
3.  戻り値の型は `TABLE (track_name TEXT, total_quantity_sold INTEGER)` としてください。
4.  関数内で、`invoice_line` テーブルと `track` テーブルを結合し、`track_id` ごとに `quantity` の合計を計算して、`total_quantity_sold` の降順でソートし、`p_limit` で指定された数だけ返してください。
5.  作成した関数を `SELECT * FROM` で呼び出し、`p_limit = 5` として結果を確認してください。

#### 問題 3: `IN` 引数と `OUT` 引数を持つプロシージャの作成と呼び出し

1.  `create_and_get_artist(IN p_artist_name TEXT, OUT p_artist_id INTEGER)` という名前のプロシージャを作成してください。
2.  このプロシージャは以下の処理を行います。
    - まず、`p_artist_name` が既に `artist` テーブルに存在するかを確認してください。
    - もし存在すれば、その `artist_id` を `p_artist_id` に設定します。
    - もし存在しなければ、新しいアーティストとして `p_artist_name` を挿入し、生成された `artist_id` を `p_artist_id` に設定します。
3.  プロシージャ内で `RAISE NOTICE` を使用して、アーティストが新規作成されたか、既存のものが取得されたかを出力してください。
4.  作成したプロシージャを `CALL` ステートメントで呼び出してください。
    - 既存のアーティスト名（例: `'AC/DC'`）を渡して、ID が返されることを確認してください。
    - 新しいアーティスト名（例: `'My New Band'`）を渡して、新しい ID が生成されることを確認してください。

#### 問題 4: プロシージャ内でのトランザクション制御 (COMMIT/ROLLBACK)

1.  `process_invoice_and_customer(IN p_customer_id INTEGER, IN p_invoice_total NUMERIC(10,2), OUT p_invoice_id INTEGER)` という名前のプロシージャを作成してください。
2.  このプロシージャは以下の処理を行います。
    - `p_customer_id` が `customer` テーブルに存在するかどうかを確認します。
    - もし存在しない場合、`RAISE EXCEPTION '顧客ID % は存在しません。'` を発生させます。
    - 顧客が存在する場合、新しい `invoice` レコードを作成します。`invoice_date` は `NOW()`、`billing_address` などは `customer` テーブルから取得するか、ダミーの値を使用してください。`total` には `p_invoice_total` を設定します。
    - 挿入された `invoice_id` を `p_invoice_id` に設定します。
    - 全ての操作が成功した場合、`COMMIT` を明示的に行い、`RAISE NOTICE` で成功メッセージを出力してください。
    - 途中で何らかのエラーが発生した場合（例: 存在しない顧客 ID）、`EXCEPTION WHEN OTHERS THEN` で捕捉し、`ROLLBACK` を明示的に行い、`RAISE WARNING` でエラーメッセージとロールバックされたことを出力してください。
3.  作成したプロシージャを `CALL` ステートメントで呼び出し、以下のケースをテストしてください。
    - 既存の `customer_id` (例: `1`) と適切な `total` (例: `19.99`) で呼び出し、`invoice` が作成され、`p_invoice_id` が返されることを確認してください。
    - 存在しない `customer_id` (例: `99999`) と適切な `total` で呼び出し、エラーが発生し、トランザクションがロールバックされることを確認してください。
4.  関数の削除
    - 問題 1 と問題 2 で作成した関数を削除してください。
5.  プロシージャの削除
    - 問題 3 と問題 4 で作成したプロシージャを削除してください。

---

### 解答

#### 問題 1: 単一値を返す関数の作成と呼び出し

**関数の作成:**

```sql
CREATE OR REPLACE FUNCTION get_track_price(p_track_id INTEGER)
RETURNS NUMERIC(10,2) AS $$
DECLARE
    v_unit_price track.unit_price%TYPE;
BEGIN
    SELECT unit_price INTO v_unit_price
    FROM track
    WHERE track_id = p_track_id;

    RETURN v_unit_price; -- 見つからなければNULLが返る
END;
$$ LANGUAGE plpgsql;
```

**関数の呼び出し:**

```sql
SELECT 'Track ID 1 Price:' AS description, get_track_price(1) AS price;
SELECT 'Track ID 99999 Price:' AS description, get_track_price(99999) AS price;
```

#### 問題 2: `RETURNS TABLE` を使用する関数の作成と呼び出し

**関数の作成:**

```sql
CREATE OR REPLACE FUNCTION get_top_selling_tracks(p_limit INTEGER)
RETURNS TABLE (
    track_name TEXT,
    total_quantity_sold INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT t.name AS track_name,
           SUM(il.quantity) AS total_quantity_sold
    FROM track t
    JOIN invoice_line il ON t.track_id = il.track_id
    GROUP BY t.track_id, t.name
    ORDER BY total_quantity_sold DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;
```

**関数の呼び出し:**

```sql
SELECT * FROM get_top_selling_tracks(5);
```

#### 問題 3: `IN` 引数と `OUT` 引数を持つプロシージャの作成と呼び出し

**プロシージャの作成:**

```sql
CREATE OR REPLACE PROCEDURE create_and_get_artist(
    IN p_artist_name TEXT,
    OUT p_artist_id INTEGER
) AS $$
BEGIN
    -- 既存のアーティストを検索
    SELECT artist_id INTO p_artist_id
    FROM artist
    WHERE name = p_artist_name;

    IF p_artist_id IS NULL THEN
        -- 存在しない場合、新しく挿入
        INSERT INTO artist (name) VALUES (p_artist_name)
        RETURNING artist_id INTO p_artist_id;
        RAISE NOTICE '新しいアーティスト "%" (ID: %) を作成しました。', p_artist_name, p_artist_id;
    ELSE
        RAISE NOTICE '既存のアーティスト "%" (ID: %) を取得しました。', p_artist_name, p_artist_id;
    END IF;
END;
$$ LANGUAGE plpgsql;
```

**プロシージャの呼び出し:**

```sql
DO $$
DECLARE
    returned_artist_id INTEGER;
BEGIN
    -- 既存のアーティスト名を渡す
    CALL create_and_get_artist('AC/DC', returned_artist_id);
    RAISE NOTICE 'AC/DC のアーティストID: %', returned_artist_id;

    -- 新しいアーティスト名を渡す
    CALL create_and_get_artist('My New Band PLPGSQL', returned_artist_id);
    RAISE NOTICE 'My New Band のアーティストID: %', returned_artist_id;

    -- もう一度同じ新しいアーティスト名を渡す (既存として取得されるはず)
    CALL create_and_get_artist('My New Band PLPGSQL', returned_artist_id);
    RAISE NOTICE 'My New Band (再取得) のアーティストID: %', returned_artist_id;
END
$$;
```

#### 問題 4: プロシージャ内でのトランザクション制御 (COMMIT/ROLLBACK)

**プロシージャの作成:**

```sql
CREATE OR REPLACE PROCEDURE process_invoice_and_customer(
    IN p_customer_id INTEGER,
    IN p_invoice_total NUMERIC(10,2),
    OUT p_invoice_id INTEGER
) AS $$
DECLARE
    v_customer_exists BOOLEAN;
    v_customer_info customer%ROWTYPE; -- 顧客情報を保持
BEGIN
    RAISE NOTICE '--- process_invoice_and_customer プロシージャ開始 ---';

    -- トランザクションブロック開始
    BEGIN
        -- 1. 顧客の存在確認
        SELECT * INTO v_customer_info
        FROM customer
        WHERE customer_id = p_customer_id;

        IF v_customer_info IS NULL THEN
            RAISE EXCEPTION '顧客ID % は存在しません。', p_customer_id;
        END IF;

        -- 2. 新しい請求書を作成
        INSERT INTO invoice (
            customer_id,
            invoice_date,
            billing_address,
            billing_city,
            billing_state,
            billing_country,
            billing_postal_code,
            total
        ) VALUES (
            p_customer_id,
            NOW(),
            v_customer_info.address,
            v_customer_info.city,
            v_customer_info.state,
            v_customer_info.country,
            v_customer_info.postal_code,
            p_invoice_total
        ) RETURNING invoice_id INTO p_invoice_id;

        RAISE NOTICE '新しい請求書ID: % を顧客ID % のために作成しました。', p_invoice_id, p_customer_id;

        -- 全ての操作が成功した場合のみコミット
        COMMIT;　-- ※ここでcommitはできない。
        RAISE NOTICE '全ての操作が正常に完了し、コミットされました。';

    EXCEPTION
        WHEN OTHERS THEN
            -- エラーが発生した場合、ロールバック
            ROLLBACK;
            RAISE WARNING 'エラーが発生しました: %。トランザクションはロールバックされました。', SQLERRM;
            p_invoice_id := NULL; -- エラー時はIDをNULLに設定
    END; -- トランザクションブロック終了

    RAISE NOTICE '--- process_invoice_and_customer プロシージャ終了 ---';
END;
$$ LANGUAGE plpgsql;
```

**プロシージャの呼び出し:**

```sql
DO $$
DECLARE
    created_invoice_id INTEGER;
BEGIN
    -- 成功ケース (顧客ID 1 は存在)
    RAISE NOTICE '--- 成功ケースのテスト ---';
    CALL process_invoice_and_customer(1, 19.99, created_invoice_id);
    RAISE NOTICE '成功: 作成された請求書ID: %', created_invoice_id;
    -- SELECT * FROM invoice WHERE invoice_id = created_invoice_id; で確認

    -- 失敗ケース (顧客ID 99999 は存在しない)
    RAISE NOTICE '--- 失敗ケースのテスト ---';
    CALL process_invoice_and_customer(99999, 29.99, created_invoice_id);
    RAISE NOTICE '失敗: 作成された請求書ID (NULLが期待されます): %', created_invoice_id;
    -- SELECT * FROM invoice WHERE customer_id = 99999; で何も追加されていないことを確認
END
$$;
```

##### 注意

begin~end ブロック内で begin~end ブロックを新たに開き、入れ子にすると、、、
内側のトランザクションはサブトランザクションを勝手に開く（開始時に savepoint みたいなものを作る）
もし内側で例外発生時は内側の savepoint までロールバックする（Exception 句で握りつぶしても関係なくロールバックする）
commit はトップレベルのトランザクションを確定させる処理なので、サブトランザクション内で書くとエラーが起こる。

```SQL
create プロシージャ・・・
begin
    begin -- 入れ子開始時にサブトランザクション開始（savepoint A）
        update ・・・ -- 更新処理成功
        update ・・・ -- 更新処理でエラー発生
    exception
        when others then
        raise notice '握りつぶしてもサブトランザクション内はロールバックする（savepoint Aまで巻き戻る）';
    end
end
```

```SQL
create プロシージャ・・・
begin
    begin
        update ・・・
        update ・・・
        commit; -- ここでcommitするとサブトランザクション内なのでエラーに
    exception
        when others then
        raise notice '';
    end
    commit; -- ここならトップレベルなのでok
end
```

基本的にどんな sql 書いてもトランザクションは開く、autocommit 設定なら、call で呼び出し完了したときに commit されるが、内部で細かく commit を制御したい場合、有効。
また、commit された後はまた新たなトランザクションが開始される。

#### 6.5. 関数の削除

```sql
DROP FUNCTION IF EXISTS get_track_price(INTEGER);
DROP FUNCTION IF EXISTS get_top_selling_tracks(INTEGER);
```

#### 6.6. プロシージャの削除

```sql
DROP PROCEDURE IF EXISTS create_and_get_artist(TEXT, OUT INTEGER);
DROP PROCEDURE IF EXISTS process_invoice_and_customer(INTEGER, NUMERIC, OUT INTEGER);
```
