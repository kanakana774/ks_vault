各問題は DO ブロック内で実行可能です。

---

### 問題 1: 特定のアルバムのトラック数を取得する

**問題:** `album_id` が `1` のアルバムに含まれるトラックの総数を取得し、その数を表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    track_count INTEGER;
    target_album_id INTEGER := 1;
BEGIN
    SELECT COUNT(*)
    INTO track_count
    FROM track
    WHERE album_id = target_album_id;

    RAISE NOTICE 'アルバムID % のトラック数: %', target_album_id, track_count;
END $$;
```

**解説:**

1. `DO $$ ... END $$;` は、無名コードブロックを定義し、PL/pgSQL コードを実行できるようにします。
2. `DECLARE` セクションで、トラック数を保持するための変数 `track_count` と対象のアルバム ID `target_album_id` を宣言します。
3. `SELECT COUNT(*) INTO track_count FROM track WHERE album_id = target_album_id;` で、指定されたアルバム ID のトラック数を取得し、`track_count` 変数に格納します。
4. `RAISE NOTICE` で結果をコンソールに出力します。

---

### 問題 2: 顧客のフルネームを取得する

**問題:** `customer_id` が `10` の顧客の `first_name` と `last_name` を結合してフルネームとして取得し、表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    customer_full_name VARCHAR(60);
    target_customer_id INTEGER := 10;
BEGIN
    SELECT first_name || ' ' || last_name
    INTO customer_full_name
    FROM customer
    WHERE customer_id = target_customer_id;

    RAISE NOTICE '顧客ID % のフルネーム: %', target_customer_id, customer_full_name;
END $$;
```

**解説:**

1. `customer_full_name` 変数でフルネームを格納します。
2. `SELECT first_name || ' ' || last_name` を使用して、`first_name` と `last_name` をスペースで連結し、フルネームを作成します。
3. `RAISE NOTICE` で結果を表示します。

---

### 問題 3: 特定のアーティストのアルバムリストを取得する

**問題:** `artist_id` が `2` のアーティストのすべてのアルバムのタイトルをリストアップし、それぞれ表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    album_record RECORD;
    target_artist_id INTEGER := 2;
BEGIN
    RAISE NOTICE 'アーティストID % のアルバムリスト:', target_artist_id;
    FOR album_record IN
        SELECT title
        FROM album
        WHERE artist_id = target_artist_id
    LOOP
        RAISE NOTICE '  - %', album_record.title;
    END LOOP;
END $$;
```

**解説:**

1. `FOR ... IN ... LOOP` 構文を使用して、クエリの結果を 1 行ずつ処理します。
2. `album_record` は `RECORD` 型の変数で、ループの各イテレーションでクエリから返される行を保持します。
3. `album_record.title` で現在の行の `title` 列にアクセスします。

---

### 問題 4: 合計請求額が特定の金額を超える請求書をカウントする

**問題:** `total` が `5.00` を超える請求書（`invoice`）の数を数え、その数を表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    high_value_invoice_count INTEGER;
    min_total_amount NUMERIC(10,2) := 5.00;
BEGIN
    SELECT COUNT(*)
    INTO high_value_invoice_count
    FROM invoice
    WHERE total > min_total_amount;

    RAISE NOTICE '合計請求額が % を超える請求書の数: %', min_total_amount, high_value_invoice_count;
END $$;
```

**解説:**

1. `high_value_invoice_count` で条件を満たす請求書の数を保持します。
2. `min_total_amount` で比較対象となる金額を定義します。
3. `WHERE total > min_total_amount` で条件を指定し、`COUNT(*)` で合致する行の数を取得します。

---

### 問題 5: 従業員の役職を更新する

**問題:** `employee_id` が `3` の従業員の `title` を `'Senior Sales Manager'` に更新する PL/pgSQL コードを作成してください。更新後、その従業員の新しい役職を表示してください。

**解答:**

```sql
DO $$
DECLARE
    target_employee_id INTEGER := 3;
    new_title VARCHAR(30) := 'Senior Sales Manager';
    current_title VARCHAR(30);
BEGIN
    UPDATE employee
    SET title = new_title
    WHERE employee_id = target_employee_id;

    SELECT title
    INTO current_title
    FROM employee
    WHERE employee_id = target_employee_id;

    RAISE NOTICE '従業員ID % の新しい役職: %', target_employee_id, current_title;
END $$;
```

**解説:**

1. `UPDATE` ステートメントを使用して、指定された従業員の `title` を更新します。
2. `SELECT title INTO current_title` を使用して、更新後の役職を確認し、`RAISE NOTICE` で表示します。
3. DO ブロック内での DML (INSERT, UPDATE, DELETE) は自動的にコミットされます。

---

### 問題 6: 新しいジャンルを追加する

**問題:** `name` が `'J-Pop'` の新しいジャンルを `genre` テーブルに追加する PL/pgSQL コードを作成してください。追加後、新しく割り当てられた `genre_id` を表示してください。

**解答:**

```sql
DO $$
DECLARE
    new_genre_name VARCHAR(120) := 'J-Pop';
    new_genre_id INTEGER;
BEGIN
    INSERT INTO genre (name)
    VALUES (new_genre_name)
    RETURNING genre_id INTO new_genre_id;

    RAISE NOTICE '新しいジャンル "%" (ID: %) が追加されました。', new_genre_name, new_genre_id;
END $$;
```

**解説:**

1. `INSERT INTO ... VALUES (...) RETURNING ... INTO ...;` 構文を使用して、新しい行を挿入し、自動生成されたプライマリキー (`genre_id`) を `new_genre_id` 変数に取得します。
2. `RAISE NOTICE` で追加されたジャンル名と ID を表示します。

---

### 問題 7: 特定のメディアタイプのトラックを削除する (トランザクション使用)

**問題:** `media_type_id` が `3` のすべてのトラックを `track` テーブルから削除する PL/pgSQL コードを作成してください。ただし、もし削除対象のトラックが 10 件を超える場合は削除をロールバックし、メッセージを表示してください。

**解答:**

```sql
DO $$
DECLARE
    target_media_type_id INTEGER := 3;
    track_count_to_delete INTEGER;
BEGIN
    -- 削除するトラックの数を事前に確認
    SELECT COUNT(*)
    INTO track_count_to_delete
    FROM track
    WHERE media_type_id = target_media_type_id;

    IF track_count_to_delete > 10 THEN
        RAISE NOTICE '削除対象のトラックが10件を超えています (%). 削除をロールバックします。', track_count_to_delete;
        -- DOブロックは暗黙的にトランザクションを形成するため、ROLLBACKできません。
        -- 実際にはより複雑なトランザクション管理が必要ですが、ここではメッセージで代用します。
        -- 本番環境では、DELETEをCATCHするEXCEPTIONブロック内でROLLBACKを明示的に行うか、
        -- 関数内でトランザクションを制御する必要があります。
    ELSE
        DELETE FROM track
        WHERE media_type_id = target_media_type_id;

        RAISE NOTICE '% 件のトラックが削除されました (メディアタイプID: %)。', track_count_to_delete, target_media_type_id;
    END IF;
END $$;
```

**解説:**

1. `track_count_to_delete` 変数で削除対象のトラック数を取得します。
2. `IF ... THEN ... ELSE ... END IF;` 構文で条件分岐します。
3. `track` テーブルが `invoice_line` や `playlist_track` と外部キー制約を持っているため、実際には制約がある場合は削除できません。この問題では、単に削除を実行するロジックを示しています。外部キー制約がある場合、関連レコードも削除するか、ON DELETE CASCADE を設定する必要があります。
4. **重要:** DO ブロックは単一のトランザクションとして実行されるため、PL/pgSQL 内で明示的に `ROLLBACK` を発行することはできません。この例では、ロールバックの代わりにメッセージを表示することで、意図を伝えています。実際のアプリケーションでは、関数やストアドプロシージャ内で `BEGIN; ... EXCEPTION ... END;` を使用してトランザクションを制御します。

---

### 問題 8: 請求書の合計金額が最も高い顧客を見つける

**問題:** これまでの請求書の合計金額が最も高い顧客の `first_name`, `last_name`, および合計請求額を表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    top_customer_first_name VARCHAR(40);
    top_customer_last_name VARCHAR(20);
    max_total_spent NUMERIC(10,2);
BEGIN
    SELECT
        c.first_name,
        c.last_name,
        SUM(i.total) AS total_spent
    INTO
        top_customer_first_name,
        top_customer_last_name,
        max_total_spent
    FROM
        customer c
    JOIN
        invoice i ON c.customer_id = i.customer_id
    GROUP BY
        c.customer_id, c.first_name, c.last_name
    ORDER BY
        total_spent DESC
    LIMIT 1;

    RAISE NOTICE '最も多く購入した顧客: % % (合計金額: %)', top_customer_first_name, top_customer_last_name, max_total_spent;
END $$;
```

**解説:**

1. `customer` と `invoice` テーブルを `customer_id` で結合します。
2. `GROUP BY c.customer_id, c.first_name, c.last_name` で顧客ごとにグループ化し、`SUM(i.total)` で合計請求額を計算します。
3. `ORDER BY total_spent DESC` で合計請求額の降順にソートし、`LIMIT 1` で最も高い顧客を取得します。
4. 結果をそれぞれの変数に格納し、表示します。

---

### 問題 9: 指定された年月範囲内の請求書数を取得する

**問題:** 2010 年 1 月から 2010 年 12 月までの間に発行された請求書（`invoice`）の総数を取得し、表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    invoice_count_in_range INTEGER;
    start_date DATE := '2010-01-01';
    end_date DATE := '2010-12-31';
BEGIN
    SELECT COUNT(*)
    INTO invoice_count_in_range
    FROM invoice
    WHERE invoice_date BETWEEN start_date AND end_date;

    RAISE NOTICE '% から % までの請求書数: %', start_date, end_date, invoice_count_in_range;
END $$;
```

**解説:**

1. `start_date` と `end_date` 変数で期間を定義します。
2. `WHERE invoice_date BETWEEN start_date AND end_date` を使用して、指定された範囲内の請求書をフィルタリングします。
3. `COUNT(*)` で合致する行の数を取得し、結果を表示します。

---

### 問題 10: トラックの単価に基づいてカテゴリを割り当てる

**問題:** `track_id` が `5` のトラックの `unit_price` を取得し、その価格に基づいてカテゴリ（例: 'Cheap', 'Standard', 'Premium'）を割り当てて表示する PL/pgSQL コードを作成してください。

- `unit_price` < 0.99 の場合: 'Cheap'
- `unit_price` = 0.99 の場合: 'Standard'
- `unit_price` > 0.99 の場合: 'Premium'

**解答:**

```sql
DO $$
DECLARE
    target_track_id INTEGER := 5;
    track_unit_price NUMERIC(10,2);
    price_category VARCHAR(20);
BEGIN
    SELECT unit_price
    INTO track_unit_price
    FROM track
    WHERE track_id = target_track_id;

    IF track_unit_price < 0.99 THEN
        price_category := 'Cheap';
    ELSIF track_unit_price = 0.99 THEN
        price_category := 'Standard';
    ELSE
        price_category := 'Premium';
    END IF;

    RAISE NOTICE 'トラックID % の単価: % (カテゴリ: %)', target_track_id, track_unit_price, price_category;
END $$;
```

**解説:**

1. `track_unit_price` に対象トラックの単価を取得します。
2. `IF ... ELSIF ... ELSE ... END IF;` 構文を使用して、単価に基づいて `price_category` 変数に適切なカテゴリを割り当てます。
3. 結果を表示します。

---

### 問題 11: 顧客の住所情報を更新する

**問題:** `customer_id` が `20` の顧客の `address` を `'123 Main St'`, `city` を `'Tokyo'`, `country` を `'Japan'` に更新する PL/pgSQL コードを作成してください。更新後、その顧客の新しい住所情報を表示してください。

**解答:**

```sql
DO $$
DECLARE
    target_customer_id INTEGER := 20;
    new_address VARCHAR(70) := '123 Main St';
    new_city VARCHAR(40) := 'Tokyo';
    new_country VARCHAR(40) := 'Japan';
    updated_address VARCHAR(70);
    updated_city VARCHAR(40);
    updated_country VARCHAR(40);
BEGIN
    UPDATE customer
    SET
        address = new_address,
        city = new_city,
        country = new_country
    WHERE customer_id = target_customer_id;

    SELECT address, city, country
    INTO updated_address, updated_city, updated_country
    FROM customer
    WHERE customer_id = target_customer_id;

    RAISE NOTICE '顧客ID % の新しい住所: % (都市: %, 国: %)', target_customer_id, updated_address, updated_city, updated_country;
END $$;
```

**解説:**

1. `UPDATE` ステートメントで複数の列を一度に更新します。
2. 更新後に再度 `SELECT` を実行して、変更が正しく適用されたことを確認し、表示します。

---

### 問題 12: 特定のジャンルのトラックの平均価格を取得する

**問題:** `genre_id` が `1` のジャンルに属するトラックの平均 `unit_price` を計算し、表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    target_genre_id INTEGER := 1;
    avg_price NUMERIC(10,2);
BEGIN
    SELECT AVG(unit_price)
    INTO avg_price
    FROM track
    WHERE genre_id = target_genre_id;

    RAISE NOTICE 'ジャンルID % のトラックの平均単価: %', target_genre_id, avg_price;
END $$;
```

**解説:**

1. `AVG(unit_price)` 集計関数を使用して、指定されたジャンルのトラックの平均単価を計算します。
2. 結果を `avg_price` 変数に格納し、表示します。

---

### 問題 13: 従業員のレポート先（上司）の名前を取得する

**問題:** `employee_id` が `6` の従業員の上司（`reports_to`）の `first_name` と `last_name` を取得し、表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    target_employee_id INTEGER := 6;
    manager_first_name VARCHAR(20);
    manager_last_name VARCHAR(20);
BEGIN
    SELECT
        e2.first_name,
        e2.last_name
    INTO
        manager_first_name,
        manager_last_name
    FROM
        employee e1
    JOIN
        employee e2 ON e1.reports_to = e2.employee_id
    WHERE
        e1.employee_id = target_employee_id;

    IF manager_first_name IS NOT NULL THEN
        RAISE NOTICE '従業員ID % の上司: % %', target_employee_id, manager_first_name, manager_last_name;
    ELSE
        RAISE NOTICE '従業員ID % は上司を持っていません。', target_employee_id;
    END IF;
END $$;
```

**解説:**

1. `employee` テーブルを自己結合（`e1` を従業員、`e2` を上司として）して、上司の情報を取得します。
2. `IF ... ELSE ... END IF;` を使用して、上司が存在しない場合のメッセージを処理します（`reports_to` が `NULL` の場合）。

---

### 問題 14: 特定のプレイリストに含まれるトラック数を取得する

**問題:** `playlist_id` が `1` のプレイリストに含まれるトラックの総数を取得し、その数を表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    track_count INTEGER;
    target_playlist_id INTEGER := 1;
BEGIN
    SELECT COUNT(*)
    INTO track_count
    FROM playlist_track
    WHERE playlist_id = target_playlist_id;

    RAISE NOTICE 'プレイリストID % のトラック数: %', target_playlist_id, track_count;
END $$;
```

**解説:**

1. `playlist_track` テーブルから、指定された `playlist_id` に対応するトラックの数を数えます。
2. `COUNT(*)` で合計数を取得し、表示します。

---

### 問題 15: 顧客の国ごとの合計請求額を集計する

**問題:** 各国ごとの顧客による合計請求額を計算し、国名と合計金額を降順で表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    country_total_record RECORD;
BEGIN
    RAISE NOTICE '国ごとの合計請求額:';
    FOR country_total_record IN
        SELECT
            c.country,
            SUM(i.total) AS total_spent_by_country
        FROM
            customer c
        JOIN
            invoice i ON c.customer_id = i.customer_id
        GROUP BY
            c.country
        ORDER BY
            total_spent_by_country DESC
    LOOP
        RAISE NOTICE '  - %: %', country_total_record.country, country_total_record.total_spent_by_country;
    END LOOP;
END $$;
```

**解説:**

1. `customer` と `invoice` テーブルを結合します。
2. `GROUP BY c.country` で国ごとにグループ化し、`SUM(i.total)` で各国の合計請求額を計算します。
3. `ORDER BY total_spent_by_country DESC` で合計請求額の降順にソートします。
4. `FOR ... IN ... LOOP` で結果をイテレートし、それぞれの国と合計金額を表示します。

---

### 問題 16: 新しい顧客を追加し、サポート担当者を割り当てる

**問題:** `first_name` が `'Jane'`, `last_name` が `'Doe'`, `email` が `'jane.doe@example.com'` の新しい顧客を追加してください。この顧客には、`employee_id` が `3` の従業員をサポート担当者として割り当ててください。追加後、新しく割り当てられた `customer_id` とサポート担当者の名前を表示してください。

**解答:**

```sql
DO $$
DECLARE
    new_customer_id INTEGER;
    new_first_name VARCHAR(40) := 'Jane';
    new_last_name VARCHAR(20) := 'Doe';
    new_email VARCHAR(60) := 'jane.doe@example.com';
    support_rep_id INTEGER := 3;
    support_rep_name VARCHAR(40);
BEGIN
    -- 新しい顧客を追加
    INSERT INTO customer (first_name, last_name, email, support_rep_id)
    VALUES (new_first_name, new_last_name, new_email, support_rep_id)
    RETURNING customer_id INTO new_customer_id;

    -- サポート担当者の名前を取得
    SELECT first_name || ' ' || last_name
    INTO support_rep_name
    FROM employee
    WHERE employee_id = support_rep_id;

    RAISE NOTICE '新しい顧客 "% %" (ID: %) が追加されました。サポート担当者: %', new_first_name, new_last_name, new_customer_id, support_rep_name;
END $$;
```

**解説:**

1. `INSERT` ステートメントで新しい顧客レコードを作成し、`RETURNING customer_id` で新しく生成された `customer_id` を取得します。
2. サポート担当者の名前を `employee` テーブルから取得します。
3. `RAISE NOTICE` で追加された顧客情報とサポート担当者の名前を表示します。

---

### 問題 17: アルバム名の部分一致で検索し、アーティスト名も表示する

**問題:** アルバム名に `'Love'` を含むすべてのアルバムのタイトルと、そのアルバムを制作したアーティストの名前をリストアップする PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    album_artist_record RECORD;
    search_term VARCHAR(160) := '%Love%';
BEGIN
    RAISE NOTICE 'アルバム名に "%" を含むアルバムとアーティスト: ', search_term;
    FOR album_artist_record IN
        SELECT
            a.title AS album_title,
            ar.name AS artist_name
        FROM
            album a
        JOIN
            artist ar ON a.artist_id = ar.artist_id
        WHERE
            a.title ILIKE search_term -- ILIKE は大文字小文字を区別しない検索
    LOOP
        RAISE NOTICE '  - アルバム: %, アーティスト: %', album_artist_record.album_title, album_artist_record.artist_name;
    END LOOP;
END $$;
```

**解説:**

1. `album` テーブルと `artist` テーブルを結合して、アルバムとアーティストの情報を取得します。
2. `WHERE a.title ILIKE search_term` を使用して、アルバム名が部分的に一致するレコードを検索します。`ILIKE` は大文字小文字を区別しない検索を行います。
3. `FOR ... IN ... LOOP` で結果をイテレートし、アルバムタイトルとアーティスト名を表示します。

---

### 問題 18: 最も古い従業員と最も新しい従業員の入社日を取得する

**問題:** 最も古い入社日を持つ従業員と、最も新しい入社日を持つ従業員の `first_name`, `last_name`, および `hire_date` を取得し、表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    oldest_employee_rec RECORD;
    newest_employee_rec RECORD;
BEGIN
    -- 最も古い従業員
    SELECT first_name, last_name, hire_date
    INTO oldest_employee_rec
    FROM employee
    ORDER BY hire_date ASC
    LIMIT 1;

    -- 最も新しい従業員
    SELECT first_name, last_name, hire_date
    INTO newest_employee_rec
    FROM employee
    ORDER BY hire_date DESC
    LIMIT 1;

    RAISE NOTICE '最も古い入社日の従業員: % % (入社日: %)', oldest_employee_rec.first_name, oldest_employee_rec.last_name, oldest_employee_rec.hire_date;
    RAISE NOTICE '最も新しい入社日の従業員: % % (入社日: %)', newest_employee_rec.first_name, newest_employee_rec.last_name, newest_employee_rec.hire_date;
END $$;
```

**解説:**

1. 最も古い従業員を見つけるために `ORDER BY hire_date ASC LIMIT 1` を使用します。
2. 最も新しい従業員を見つけるために `ORDER BY hire_date DESC LIMIT 1` を使用します。
3. それぞれの結果を `RECORD` 型の変数に格納し、表示します。

---

### 問題 19: 特定の期間内に生まれた従業員をリストアップする

**問題:** 1960 年 1 月 1 日から 1970 年 12 月 31 日までの間に生まれたすべての従業員の `first_name`, `last_name`, および `birth_date` をリストアップする PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    employee_rec RECORD;
    start_birth_date DATE := '1960-01-01';
    end_birth_date DATE := '1970-12-31';
BEGIN
    RAISE NOTICE '% から % の間に生まれた従業員:', start_birth_date, end_birth_date;
    FOR employee_rec IN
        SELECT
            first_name,
            last_name,
            birth_date
        FROM
            employee
        WHERE
            birth_date BETWEEN start_birth_date AND end_birth_date
        ORDER BY
            birth_date ASC
    LOOP
        RAISE NOTICE '  - % % (生年月日: %)', employee_rec.first_name, employee_rec.last_name, employee_rec.birth_date::DATE;
    END LOOP;
END $$;
```

**解説:**

1. `start_birth_date` と `end_birth_date` で生年月日の範囲を定義します。
2. `WHERE birth_date BETWEEN start_birth_date AND end_birth_date` で条件に合う従業員をフィルタリングします。
3. `FOR ... IN ... LOOP` で結果をイテレートし、従業員の情報を表示します。`::DATE` を使用して `TIMESTAMP` 型を日付のみにキャストしています。

---

### 問題 20: 請求書明細（invoice_line）の合計数量が特定の数を超える請求書 ID と顧客情報を取得する

**問題:** 各請求書（`invoice`）において、関連する `invoice_line` の `quantity` の合計が `10` を超えるすべての請求書 ID、およびその請求書を生成した顧客の `first_name` と `last_name` を取得し、表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    invoice_detail_rec RECORD;
    min_total_quantity INTEGER := 10;
BEGIN
    RAISE NOTICE '合計数量が % を超える請求書:', min_total_quantity;
    FOR invoice_detail_rec IN
        SELECT
            i.invoice_id,
            c.first_name,
            c.last_name,
            SUM(il.quantity) AS total_quantity
        FROM
            invoice i
        JOIN
            customer c ON i.customer_id = c.customer_id
        JOIN
            invoice_line il ON i.invoice_id = il.invoice_id
        GROUP BY
            i.invoice_id, c.first_name, c.last_name
        HAVING
            SUM(il.quantity) > min_total_quantity
        ORDER BY
            total_quantity DESC
    LOOP
        RAISE NOTICE '  - 請求書ID: %, 顧客: % % (合計数量: %)', invoice_detail_rec.invoice_id, invoice_detail_rec.first_name, invoice_detail_rec.last_name, invoice_detail_rec.total_quantity;
    END LOOP;
END $$;
```

**解説:**

1. `invoice`, `customer`, `invoice_line` の 3 つのテーブルを結合します。
2. `GROUP BY i.invoice_id, c.first_name, c.last_name` で請求書と顧客ごとにグループ化します。
3. `SUM(il.quantity)` で各請求書の合計数量を計算します。
4. `HAVING SUM(il.quantity) > min_total_quantity` を使用して、合計数量が指定された数を超えるグループをフィルタリングします。`WHERE` 句は個々の行に適用されますが、`HAVING` 句はグループ化された結果に適用されます。
5. `FOR ... IN ... LOOP` で結果をイテレートし、各請求書と顧客の情報を表示します。

---

## PL/pgSQL 問題集 3 (レコード型・配列に関する追加 20 問)

---

### 問題 41: レコード型を使用して単一の顧客情報を取得する

**問題:** `customer_id` が `1` の顧客の情報をレコード型に取得し、`first_name` と `email` を表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    customer_data customer%ROWTYPE; -- customer テーブルの行の構造を持つレコード型
    target_customer_id INTEGER := 1;
BEGIN
    SELECT *
    INTO customer_data
    FROM customer
    WHERE customer_id = target_customer_id;

    RAISE NOTICE '顧客ID % の情報: 名前=%、メールアドレス=%',
                 target_customer_id,
                 customer_data.first_name,
                 customer_data.email;
END $$;
```

**解説:**

1. `customer%ROWTYPE` を使用して、`customer` テーブルの行構造と全く同じ構造を持つレコード型 `customer_data` を宣言します。
2. `SELECT * INTO customer_data` で、指定された顧客のすべての列を `customer_data` レコードに格納します。
3. `customer_data.first_name` のように、`レコード変数名.列名` でレコード内の個々の列にアクセスできます。

---

### 問題 42: FOR ループとレコード型で複数のアーティスト情報を取得する

**問題:** すべてのアーティストの `artist_id` と `name` を取得し、レコード型を使用してリストアップする PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    artist_rec RECORD; -- 任意の行構造を持つレコード型
BEGIN
    RAISE NOTICE 'アーティストリスト:';
    FOR artist_rec IN
        SELECT artist_id, name
        FROM artist
        ORDER BY artist_id
    LOOP
        RAISE NOTICE '  ID: %, 名前: %', artist_rec.artist_id, artist_rec.name;
    END LOOP;
END $$;
```

**解説:**

1. `artist_rec RECORD` は、クエリによって返される任意の列構造を持つことができる汎用的なレコード型です。
2. `FOR ... IN ... LOOP` でクエリの結果を 1 行ずつ `artist_rec` に格納し、ループ内でその列にアクセスします。

---

### 問題 43: 配列変数に複数のジャンル名を取得する

**問題:** すべてのジャンル名（`name`）を PL/pgSQL の文字列配列変数に取得し、配列の内容を一つずつ表示するコードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    genre_names VARCHAR(120)[]; -- 文字列の配列
    current_genre_name VARCHAR(120);
BEGIN
    SELECT ARRAY_AGG(name ORDER BY name) -- ジャンル名を配列として集約
    INTO genre_names
    FROM genre;

    RAISE NOTICE 'ジャンルリスト:';
    FOREACH current_genre_name IN ARRAY genre_names LOOP -- 配列の要素を順に処理
        RAISE NOTICE '  - %', current_genre_name;
    END LOOP;
END $$;
```

**解説:**

1. `VARCHAR(120)[]` で文字列の配列 `genre_names` を宣言します。
2. `ARRAY_AGG(name ORDER BY name)` 集計関数を使用して、`genre` テーブルの `name` 列の値を配列として `genre_names` に格納します。`ORDER BY name` で配列内の要素の順序を決定します。
3. `FOREACH ... IN ARRAY ... LOOP` は、配列の各要素をイテレートするための PL/pgSQL の構文です。

---

### 問題 44: 配列を使用して特定の`track_id`を持つトラック情報を取得する

**問題:** `track_id` が `1, 3, 5` のトラック情報をレコード型（`track%ROWTYPE`）の配列に取得し、それぞれのトラック名と単価を表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    target_track_ids INTEGER[] := ARRAY[1, 3, 5]; -- 検索対象のトラックIDの配列
    track_records track%ROWTYPE[]; -- trackテーブルの行の配列
    single_track_rec track%ROWTYPE;
BEGIN
    -- 配列内のIDに対応するトラック情報を取得
    SELECT ARRAY_AGG(t ORDER BY track_id) -- 行全体を配列として集約
    INTO track_records
    FROM track t
    WHERE track_id = ANY(target_track_ids); -- ANY演算子で配列内のいずれかの値と一致するかをチェック

    IF array_length(track_records, 1) > 0 THEN
        RAISE NOTICE '指定されたトラックIDの情報:';
        FOREACH single_track_rec IN ARRAY track_records LOOP
            RAISE NOTICE '  ID: %, 名前: %, 単価: %',
                         single_track_rec.track_id,
                         single_track_rec.name,
                         single_track_rec.rec.unit_price;
        END LOOP;
    ELSE
        RAISE NOTICE '指定されたトラックIDに対応する情報は見つかりませんでした。';
    END IF;
END $$;
```

**解説:**

1. `INTEGER[]` で検索対象の ID の配列 `target_track_ids` を宣言します。
2. `track%ROWTYPE[]` で `track` テーブルの行構造を持つレコード型の配列 `track_records` を宣言します。
3. `SELECT ARRAY_AGG(t ORDER BY track_id) INTO track_records FROM track t WHERE track_id = ANY(target_track_ids);` を使用して、指定された ID のトラックの全行をレコードの配列として取得します。`ARRAY_AGG(t)` は行全体を配列要素として集約します。
4. `WHERE track_id = ANY(target_track_ids)` は、`track_id` が `target_track_ids` 配列のいずれかの値と一致するかどうかをチェックします。
5. `FOREACH ... IN ARRAY ... LOOP` で配列 `track_records` の各要素（各トラックのレコード）を処理します。

---

### 問題 45: レコード型と条件分岐で顧客の居住地によってメッセージを変更する

**問題:** `customer_id` が `2` の顧客情報をレコード型に取得し、`country` が `'Canada'` または `'USA'` の場合は「北米の顧客」、それ以外の場合は「その他の地域の顧客」と表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    customer_info customer%ROWTYPE;
    target_customer_id INTEGER := 2;
BEGIN
    SELECT *
    INTO customer_info
    FROM customer
    WHERE customer_id = target_customer_id;

    IF customer_info.country = 'Canada' OR customer_info.country = 'USA' THEN
        RAISE NOTICE '顧客ID % (% %) は北米の顧客です。',
                     target_customer_id, customer_info.first_name, customer_info.last_name;
    ELSE
        RAISE NOTICE '顧客ID % (% %) はその他の地域の顧客です (国: %)。',
                     target_customer_id, customer_info.first_name, customer_info.last_name, customer_info.country;
    END IF;
END $$;
```

**解説:**

1. `customer%ROWTYPE` で顧客情報を取得します。
2. `IF ... OR ... THEN ... ELSE ... END IF;` 構文で `country` の値に基づいて条件分岐し、適切なメッセージを表示します。

---

### 問題 46: 複数の請求書情報をレコード型で処理し、合計金額を表示する

**問題:** `customer_id` が `3` の顧客のすべての請求書（`invoice`）情報を取得し、各請求書の `invoice_id` と `total` を表示した後、その顧客の全請求書の合計金額を表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    invoice_rec RECORD;
    target_customer_id INTEGER := 3;
    total_invoices_amount NUMERIC(10,2) := 0;
BEGIN
    RAISE NOTICE '顧客ID % の請求書リスト:', target_customer_id;
    FOR invoice_rec IN
        SELECT invoice_id, total
        FROM invoice
        WHERE customer_id = target_customer_id
        ORDER BY invoice_id
    LOOP
        RAISE NOTICE '  請求書ID: %, 合計金額: %', invoice_rec.invoice_id, invoice_rec.total;
        total_invoices_amount := total_invoices_amount + invoice_rec.total;
    END LOOP;

    RAISE NOTICE '---';
    RAISE NOTICE '顧客ID % の全請求書合計金額: %', target_customer_id, total_invoices_amount;
END $$;
```

**解説:**

1. `FOR ... IN ... LOOP` で、指定された顧客の各請求書を `invoice_rec` レコードに取得します。
2. ループ内で `total_invoices_amount` 変数に各請求書の `total` を加算して、合計金額を計算します。
3. ループ終了後に合計金額を表示します。

---

### 問題 47: 配列に特定の条件を満たす従業員 ID を取得し、後で処理する

**問題:** `city` が `'Calgary'` のすべての従業員の `employee_id` を配列に取得し、その配列の各 ID について「従業員 ID: [ID] はカルガリー出身です」というメッセージを表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    calgary_employee_ids INTEGER[];
    current_employee_id INTEGER;
    target_city VARCHAR(40) := 'Calgary';
BEGIN
    SELECT ARRAY_AGG(employee_id ORDER BY employee_id)
    INTO calgary_employee_ids
    FROM employee
    WHERE city = target_city;

    IF array_length(calgary_employee_ids, 1) > 0 THEN
        RAISE NOTICE 'カルガリー出身の従業員リスト:';
        FOREACH current_employee_id IN ARRAY calgary_employee_ids LOOP
            RAISE NOTICE '  従業員ID: % は % 出身です。', current_employee_id, target_city;
        END LOOP;
    ELSE
        RAISE NOTICE 'カルガリー出身の従業員は見つかりませんでした。';
    END IF;
END $$;
```

**解説:**

1. `ARRAY_AGG(employee_id ...)` で、指定された都市の従業員の ID を配列 `calgary_employee_ids` に取得します。
2. `FOREACH ... IN ARRAY ... LOOP` を使用して、配列の各従業員 ID を順に処理し、メッセージを表示します。

---

### 問題 48: レコード型と EXCEPTIONS ブロックで存在しないレコードを処理する

**問題:** `album_id` が `999` (存在しない ID) のアルバム情報をレコード型に取得しようと試み、もしレコードが見つからなかった場合は「アルバム ID [ID] は見つかりませんでした」というメッセージを表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    album_data album%ROWTYPE;
    target_album_id INTEGER := 999; -- 存在しない可能性のあるID
BEGIN
    BEGIN
        SELECT *
        INTO album_data
        FROM album
        WHERE album_id = target_album_id;

        IF NOT FOUND THEN -- SELECT INTO が行を返さなかった場合
            RAISE EXCEPTION 'AlbumNotFound: アルバムID % は見つかりませんでした。', target_album_id;
        END IF;

        RAISE NOTICE 'アルバムID % の情報: タイトル=%、アーティストID=%',
                     target_album_id,
                     album_data.title,
                     album_data.artist_id;

    EXCEPTION
        WHEN SQLSTATE 'P0001' THEN -- カスタム例外 'AlbumNotFound' をキャッチ
            RAISE NOTICE '%', SQLERRM;
        WHEN NO_DATA_FOUND THEN -- SELECT INTO が行を返さなかった場合の標準的な例外 (ただし、IF NOT FOUND を使用した方が明示的)
            RAISE NOTICE 'アルバムID % は見つかりませんでした。 (NO_DATA_FOUND)', target_album_id;
        WHEN OTHERS THEN
            RAISE NOTICE '予期せぬエラーが発生しました: %', SQLERRM;
    END;
END $$;
```

**解説:**

1. `BEGIN ... EXCEPTION ... END;` ブロックでエラーハンドリングを行います。
2. `SELECT * INTO album_data` でレコードを取得しようとします。
3. `IF NOT FOUND THEN RAISE EXCEPTION 'AlbumNotFound: ...'; END IF;` を使用して、`SELECT INTO` が行を返さなかった場合にカスタム例外を発生させます。
4. `EXCEPTION WHEN SQLSTATE 'P0001' THEN` でカスタム例外をキャッチし、メッセージを表示します。`NO_DATA_FOUND` も同様の状況で発生しますが、`IF NOT FOUND` を使うことで、より柔軟なエラー処理が可能です。

---

### 問題 49: 配列に顧客のフルネームを格納し、表示する

**問題:** すべての顧客のフルネーム（`first_name || ' ' || last_name`）を文字列の配列に格納し、各フルネームを表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    customer_full_names TEXT[];
    current_full_name TEXT;
BEGIN
    SELECT ARRAY_AGG(first_name || ' ' || last_name ORDER BY first_name, last_name)
    INTO customer_full_names
    FROM customer;

    RAISE NOTICE '顧客のフルネームリスト:';
    FOREACH current_full_name IN ARRAY customer_full_names LOOP
        RAISE NOTICE '  - %', current_full_name;
    END LOOP;
END $$;
```

**解説:**

1. `TEXT[]` で文字列の配列 `customer_full_names` を宣言します。
2. `ARRAY_AGG(first_name || ' ' || last_name ...)` で、結合されたフルネームを配列として取得します。
3. `FOREACH ... IN ARRAY ... LOOP` で配列の各要素を処理し、表示します。

---

### 問題 50: レコード型と CASE 文で従業員のタイトルに基づいてボーナスを計算する

**問題:** `employee_id` が `5` の従業員の情報をレコード型に取得し、`title` に基づいて仮想的なボーナス額（例: 'Sales Support Agent'なら 100, 'Sales Manager'なら 200, それ以外なら 50）を計算し、従業員の名前とボーナス額を表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    employee_info employee%ROWTYPE;
    target_employee_id INTEGER := 5;
    bonus_amount INTEGER;
BEGIN
    SELECT *
    INTO employee_info
    FROM employee
    WHERE employee_id = target_employee_id;

    CASE employee_info.title
        WHEN 'Sales Support Agent' THEN
            bonus_amount := 100;
        WHEN 'Sales Manager' THEN
            bonus_amount := 200;
        ELSE
            bonus_amount := 50;
    END CASE;

    RAISE NOTICE '従業員ID % (% %) のタイトル: "%" に基づくボーナス: %',
                 target_employee_id,
                 employee_info.first_name,
                 employee_info.last_name,
                 employee_info.title,
                 bonus_amount;
END $$;
```

**解説:**

1. `employee%ROWTYPE` で従業員情報を取得します。
2. `CASE WHEN ... THEN ... ELSE ... END CASE;` 構文を使用して、`title` の値に基づいて `bonus_amount` を決定します。
3. 従業員の名前と計算されたボーナス額を表示します。

---

### 問題 51: 配列に特定の期間の請求書 ID を格納し、合計金額を計算する

**問題:** 2011 年 1 月から 2011 年 3 月までの間に発行されたすべての請求書（`invoice`）の `invoice_id` を配列に取得し、その期間のすべての請求書の合計金額を表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    invoice_ids INTEGER[];
    current_invoice_id INTEGER;
    total_amount_in_period NUMERIC(10,2) := 0;
    start_date DATE := '2011-01-01';
    end_date DATE := '2011-03-31';
BEGIN
    SELECT ARRAY_AGG(invoice_id ORDER BY invoice_id)
    INTO invoice_ids
    FROM invoice
    WHERE invoice_date BETWEEN start_date AND end_date;

    IF array_length(invoice_ids, 1) > 0 THEN
        -- 配列内の各請求書IDの合計金額を合算
        SELECT SUM(total)
        INTO total_amount_in_period
        FROM invoice
        WHERE invoice_id = ANY(invoice_ids);

        RAISE NOTICE '% から % までの請求書ID: %', start_date, end_date, invoice_ids;
        RAISE NOTICE 'その期間の全請求書合計金額: %', total_amount_in_period;
    ELSE
        RAISE NOTICE '% から % の期間に請求書は見つかりませんでした。', start_date, end_date;
    END IF;
END $$;
```

**解説:**

1. `ARRAY_AGG(invoice_id ...)` で、指定された期間の `invoice_id` を配列 `invoice_ids` に取得します。
2. その後、`WHERE invoice_id = ANY(invoice_ids)` を使用して、配列内の ID に一致する請求書の `total` を `SUM` することで、期間内の合計金額を計算します。
3. 結果を表示します。

---

### 問題 52: レコード型と COALESCE で NULL 値を処理する

**問題:** `customer_id` が `8` の顧客情報をレコード型に取得し、もし `company` が `NULL` の場合は `'個人顧客'` と表示し、それ以外の場合は実際の `company` 名を表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    customer_data customer%ROWTYPE;
    target_customer_id INTEGER := 8;
    display_company_name VARCHAR(80);
BEGIN
    SELECT *
    INTO customer_data
    FROM customer
    WHERE customer_id = target_customer_id;

    display_company_name := COALESCE(customer_data.company, '個人顧客');

    RAISE NOTICE '顧客ID % (% %) の会社名: %',
                 target_customer_id,
                 customer_data.first_name,
                 customer_data.last_name,
                 display_company_name;
END $$;
```

**解説:**

1. `customer%ROWTYPE` で顧客情報を取得します。
2. `COALESCE(customer_data.company, '個人顧客')` 関数は、`customer_data.company` が `NULL` の場合は `'個人顧客'` を返し、そうでない場合は `customer_data.company` の値を返します。
3. 結果を表示します。

---

### 問題 53: 配列に重複するトラック ID が存在するかチェックする

**問題:** `track_id` の配列 `ARRAY[10, 20, 10, 30]` を作成し、この配列内に重複する ID があるかどうかをチェックし、結果をメッセージで表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    track_ids INTEGER[] := ARRAY[10, 20, 10, 30];
    has_duplicates BOOLEAN;
BEGIN
    SELECT COUNT(*) != COUNT(DISTINCT elem)
    INTO has_duplicates
    FROM UNNEST(track_ids) AS elem;

    IF has_duplicates THEN
        RAISE NOTICE '配列 % には重複するトラックIDが存在します。', track_ids;
    ELSE
        RAISE NOTICE '配列 % には重複するトラックIDは存在しません。', track_ids;
    END IF;
END $$;
```

**解説:**

1. `UNNEST(track_ids)` は配列を個々の要素のセットに展開します。
2. `COUNT(*) != COUNT(DISTINCT elem)` という条件は、全要素数と重複を除いた要素数を比較することで、重複が存在するかどうかを判断します。
3. 結果に基づいてメッセージを表示します。

---

### 問題 54: レコード型と複合型を組み合わせて請求書明細の情報を格納する

**問題:** 請求書明細（`invoice_line`）の情報を格納するための匿名レコード型を宣言し、`invoice_id` が `10` のすべての明細について、その匿名レコード型に `track_name` と `quantity` を取得して表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    -- 匿名レコード型は DECLARE で明示的に定義せず、SELECT INTO で直接使用
    invoice_line_item RECORD;
    target_invoice_id INTEGER := 10;
BEGIN
    RAISE NOTICE '請求書ID % の明細:', target_invoice_id;
    FOR invoice_line_item IN
        SELECT
            t.name AS track_name,
            il.quantity
        FROM
            invoice_line il
        JOIN
            track t ON il.track_id = t.track_id
        WHERE
            il.invoice_id = target_invoice_id
        ORDER BY
            il.invoice_line_id
    LOOP
        RAISE NOTICE '  - トラック名: %, 数量: %', invoice_line_item.track_name, invoice_line_item.quantity;
    END LOOP;
END $$;
```

**解説:**

1. `invoice_line_item RECORD` は、`FOR ... IN ... LOOP` 内でクエリが返す列構造を自動的に採用する匿名レコード型です。
2. `SELECT t.name AS track_name, il.quantity` のように、クエリの SELECT リストで列のエイリアスを定義することで、レコード変数で `invoice_line_item.track_name` のようにアクセスできます。

---

### 問題 55: 配列要素を更新する

**問題:** 文字列の配列 `my_playlist_items := ARRAY['Song A', 'Song B', 'Song C']` を作成し、2 番目の要素を `'New Song X'` に更新した後、配列全体を表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    my_playlist_items TEXT[] := ARRAY['Song A', 'Song B', 'Song C'];
BEGIN
    RAISE NOTICE '元の配列: %', my_playlist_items;

    my_playlist_items[2] := 'New Song X'; -- 2番目の要素を更新 (PostgreSQLの配列は1ベースインデックス)

    RAISE NOTICE '更新後の配列: %', my_playlist_items;
END $$;
```

**解説:**

1. `TEXT[] := ARRAY[...]` で文字列の配列を初期化します。
2. `my_playlist_items[2] := 'New Song X';` のように、配列名と角括弧でインデックスを指定して要素を更新します。PostgreSQL の配列はデフォルトで 1 ベースインデックスです。

---

### 問題 56: レコード型とサブクエリでアーティストとそのアルバム数を取得する

**問題:** 各アーティストの `artist_id`, `name`, およびそのアーティストが持つアルバムの総数（`album_count`）をレコード型で取得し、リストアップする PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    artist_album_count_rec RECORD;
BEGIN
    RAISE NOTICE 'アーティストとアルバム数:';
    FOR artist_album_count_rec IN
        SELECT
            ar.artist_id,
            ar.name AS artist_name,
            (SELECT COUNT(*) FROM album al WHERE al.artist_id = ar.artist_id) AS album_count
        FROM
            artist ar
        ORDER BY
            artist_name
    LOOP
        RAISE NOTICE '  ID: %, 名前: %, アルバム数: %',
                     artist_album_count_rec.artist_id,
                     artist_album_count_rec.artist_name,
                     artist_album_count_rec.album_count;
    END LOOP;
END $$;
```

**解説:**

1. メインクエリでアーティスト情報を取得し、サブクエリ `(SELECT COUNT(*) FROM album al WHERE al.artist_id = ar.artist_id)` を使用して、各アーティストのアルバム数を計算します。
2. `FOR ... IN ... LOOP` で結果をレコード型 `artist_album_count_rec` に取得し、各列にアクセスして表示します。

---

### 問題 57: 配列の要素数を取得する

**問題:** 文字列の配列 `genres := ARRAY['Rock', 'Pop', 'Jazz', 'Classical']` を作成し、その配列に含まれる要素の総数を取得して表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    genres TEXT[] := ARRAY['Rock', 'Pop', 'Jazz', 'Classical'];
    array_size INTEGER;
BEGIN
    array_size := array_length(genres, 1); -- 配列の次元の長さを取得

    RAISE NOTICE '配列 "%" の要素数: %', genres, array_size;
END $$;
```

**解説:**

1. `array_length(array_name, dimension)` 関数は、指定された次元の配列の長さを返します。一次元配列の場合、次元は `1` です。

---

### 問題 58: レコード型を使用して、顧客の郵便番号が有効かどうかをチェックする（簡単な正規表現）

**問題:** `customer_id` が `15` の顧客情報をレコード型に取得し、`postal_code` が数字 5 桁または 7 桁の形式（例: '12345' または '123-4567'）に一致するかどうかを簡単な正規表現でチェックし、結果をメッセージで表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    customer_data customer%ROWTYPE;
    target_customer_id INTEGER := 15;
    is_valid_postal_code BOOLEAN;
BEGIN
    SELECT *
    INTO customer_data
    FROM customer
    WHERE customer_id = target_customer_id;

    IF customer_data.postal_code ~ '^\d{5}$|^\d{3}-\d{4}$' THEN
        is_valid_postal_code := TRUE;
    ELSE
        is_valid_postal_code := FALSE;
    END IF;

    IF is_valid_postal_code THEN
        RAISE NOTICE '顧客ID % (% %) の郵便番号 "%" は有効な形式です。',
                     target_customer_id,
                     customer_data.first_name,
                     customer_data.last_name,
                     customer_data.postal_code;
    ELSE
        RAISE NOTICE '顧客ID % (% %) の郵便番号 "%" は無効な形式です。',
                     target_customer_id,
                     customer_data.first_name,
                     customer_data.last_name,
                     customer_data.postal_code;
    END IF;
END $$;
```

**解説:**

1. `customer%ROWTYPE` で顧客情報を取得します。
2. `~` 演算子を使用して正規表現マッチングを行います。
   - `^\d{5}$` は、文字列が先頭から末尾まで正確に 5 桁の数字で構成されていることを意味します。
   - `^\d{3}-\d{4}$` は、文字列が先頭から 3 桁の数字、ハイフン、4 桁の数字で構成されていることを意味します。
   - `|` は OR 条件です。
3. 結果に基づいてメッセージを表示します。

---

### 問題 59: 配列の要素をソートする

**問題:** 整数の配列 `numbers := ARRAY[5, 2, 8, 1, 9]` を作成し、その配列の要素を昇順にソートして表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    numbers INTEGER[] := ARRAY[5, 2, 8, 1, 9];
    sorted_numbers INTEGER[];
BEGIN
    RAISE NOTICE '元の配列: %', numbers;

    -- UNNESTで配列を分解し、ORDER BYでソート後、ARRAY_AGGで再構築
    SELECT ARRAY_AGG(n ORDER BY n)
    INTO sorted_numbers
    FROM UNNEST(numbers) AS n;

    RAISE NOTICE 'ソート後の配列 (昇順): %', sorted_numbers;
END $$;
```

**解説:**

1. `UNNEST(numbers)` で配列を一時的な行セットに展開します。
2. `ORDER BY n` で要素をソートします。
3. `ARRAY_AGG(n)` でソートされた要素を新しい配列 `sorted_numbers` に再集約します。

---

### 問題 60: レコード型のデータを使って別のテーブルに挿入する（架空のシナリオ）

**問題:** `customer_id` が `1` の顧客情報をレコード型に取得し、その `first_name`, `last_name`, `email` を使用して、架空の `archive_customers` テーブルに新しいレコードとして挿入する PL/pgSQL コードを作成してください。
（`archive_customers` テーブルが存在しない場合は、一時的に作成する DDL も記載してください。）

**解答:**

```sql
-- 事前に archive_customers テーブルが存在しない場合に実行
/*
CREATE TABLE IF NOT EXISTS archive_customers (
    archive_id SERIAL PRIMARY KEY,
    first_name VARCHAR(40) NOT NULL,
    last_name VARCHAR(20) NOT NULL,
    email VARCHAR(60) NOT NULL,
    archived_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
*/

DO $$
DECLARE
    customer_to_archive customer%ROWTYPE;
    target_customer_id INTEGER := 1;
    new_archive_id INTEGER;
BEGIN
    -- 顧客情報を取得
    SELECT *
    INTO customer_to_archive
    FROM customer
    WHERE customer_id = target_customer_id;

    IF FOUND THEN
        -- 取得したレコード型のデータを使って挿入
        INSERT INTO archive_customers (first_name, last_name, email)
        VALUES (customer_to_archive.first_name,
                customer_to_archive.last_name,
                customer_to_archive.email)
        RETURNING archive_id INTO new_archive_id;

        RAISE NOTICE '顧客ID % (% %) をアーカイブテーブルに挿入しました。アーカイブID: %',
                     target_customer_id,
                     customer_to_archive.first_name,
                     customer_to_archive.last_name,
                     new_archive_id;
    ELSE
        RAISE NOTICE '顧客ID % は見つかりませんでした。アーカイブできませんでした。', target_customer_id;
    END IF;
END $$;

-- 実行後、必要であれば一時テーブルを削除
-- DROP TABLE IF EXISTS archive_customers;
```

**解説:**

1. `customer%ROWTYPE` で対象顧客の全情報を取得します。
2. `IF FOUND THEN` でレコードが見つかったことを確認します。
3. `INSERT INTO archive_customers (...) VALUES (...) RETURNING archive_id INTO new_archive_id;` を使用して、レコード型から抽出した列の値を新しいテーブルに挿入し、新しく生成された `archive_id` を取得します。
4. この問題では、架空のテーブルを使用するため、DDL（`CREATE TABLE IF NOT EXISTS archive_customers ...`）もコメントアウトで提供しています。実行前に必要に応じてアンコメントしてテーブルを作成してください。

---

## PL/pgSQL 問題集 4 (エラーハンドリングに関する追加 20 問)

下記 postgresql のエラー一覧

> https://www.postgresql.jp/docs/9.4/errcodes-appendix.html

---

### 問題 61: 存在しない ID への SELECT INTO で NO_DATA_FOUND を処理する

**問題:** `customer_id` が `999` (存在しない ID) の顧客情報を `customer%ROWTYPE` に取得しようと試み、`NO_DATA_FOUND` 例外をキャッチして「指定された顧客 ID は存在しません」と表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    customer_rec customer%ROWTYPE;
    target_id INTEGER := 999; -- 存在しないID
BEGIN
    BEGIN
        SELECT * INTO customer_rec FROM customer WHERE customer_id = target_id;
        RAISE NOTICE '顧客ID % の情報: % %', target_id, customer_rec.first_name, customer_rec.last_name;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE NOTICE 'エラー: 顧客ID % は存在しません。', target_id;
    END;
END $$;
```

**解説:**

1. `BEGIN ... EXCEPTION ... END;` ブロック内で `SELECT INTO` を実行します。
2. `customer_id` が存在しないため、`SELECT INTO` は行を返さず、PL/pgSQL は `NO_DATA_FOUND` 例外を発生させます。
3. `WHEN NO_DATA_FOUND THEN` ブロックでこの例外をキャッチし、ユーザーフレンドリーなメッセージを表示します。

---

### 問題 62: NULL 値を NOT NULL 列に挿入しようとして NOT_NULL_VIOLATION を処理する

**問題:** `genre` テーブルに `name` が `NULL` の新しいジャンルを挿入しようと試み、`NOT_NULL_VIOLATION` 例外をキャッチして「ジャンル名は NULL にできません」と表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    new_genre_name VARCHAR(120) := NULL; -- NULL値を設定
BEGIN
    BEGIN
        INSERT INTO genre (name) VALUES (new_genre_name);
        RAISE NOTICE '新しいジャンルが追加されました。';
    EXCEPTION
        WHEN NOT_NULL_VIOLATION THEN
            RAISE NOTICE 'エラー: ジャンル名はNULLにできません。';
        WHEN OTHERS THEN
            RAISE NOTICE '予期せぬエラーが発生しました: %', SQLERRM;
    END;
END $$;
```

**解説:**

1. `name` 列は `NOT NULL` 制約があるため、`NULL` を挿入しようとすると `NOT_NULL_VIOLATION` 例外が発生します。
2. `WHEN NOT_NULL_VIOLATION THEN` ブロックで例外をキャッチし、適切なメッセージを表示します。

---

### 問題 63: 外部キー制約違反(FOREIGN_KEY_VIOLATION)を処理する

**問題:** `album` テーブルに存在しない `artist_id` (`999`) を持つ新しいアルバムを挿入しようと試み、`FOREIGN_KEY_VIOLATION` 例外をキャッチして「指定されたアーティスト ID は存在しません」と表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    new_album_title VARCHAR(160) := 'Non-existent Artist Album';
    non_existent_artist_id INTEGER := 999; -- 存在しないArtist ID
BEGIN
    BEGIN
        INSERT INTO album (title, artist_id) VALUES (new_album_title, non_existent_artist_id);
        RAISE NOTICE '新しいアルバムが追加されました。';
    EXCEPTION
        WHEN FOREIGN_KEY_VIOLATION THEN
            RAISE NOTICE 'エラー: アルバムを作成できません。指定されたアーティストID % は存在しません。', non_existent_artist_id;
        WHEN OTHERS THEN
            RAISE NOTICE '予期せぬエラーが発生しました: %', SQLERRM;
    END;
END $$;
```

**解説:**

1. `album.artist_id` は `artist.artist_id` への外部キー制約を持っています。存在しない `artist_id` を挿入しようとすると `FOREIGN_KEY_VIOLATION` 例外が発生します。
2. `WHEN FOREIGN_KEY_VIOLATION THEN` ブロックで例外をキャッチし、エラーメッセージを表示します。

---

### 問題 64: ZERO_DIVISION を処理する

**問題:** 0 で除算しようと試み、`ZERO_DIVISION` 例外をキャッチして「0 で除算することはできません」と表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    numerator INTEGER := 10;
    denominator INTEGER := 0;
    result NUMERIC;
BEGIN
    BEGIN
        result := numerator / denominator;
        RAISE NOTICE '計算結果: %', result;
    EXCEPTION
        WHEN ZERO_DIVISION THEN
            RAISE NOTICE 'エラー: 0で除算することはできません。';
        WHEN OTHERS THEN
            RAISE NOTICE '予期せぬエラーが発生しました: %', SQLERRM;
    END;
END $$;
```

**解説:**

1. `numerator / denominator` で 0 除算が発生します。
2. `WHEN ZERO_DIVISION THEN` ブロックで例外をキャッチし、適切なメッセージを表示します。

---

### 問題 65: TOO_MANY_ROWS を処理する

**問題:** `SELECT INTO` で複数の行が返される可能性があるクエリを実行し（例: `artist` テーブルからすべての `name` を単一変数に取得）、`TOO_MANY_ROWS` 例外をキャッチして「複数の行が返されました。単一の結果を期待しています」と表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    artist_name VARCHAR(120);
BEGIN
    BEGIN
        -- 複数のアーティスト名が返される可能性がある
        SELECT name INTO artist_name FROM artist;
        RAISE NOTICE '取得したアーティスト名: %', artist_name;
    EXCEPTION
        WHEN TOO_MANY_ROWS THEN
            RAISE NOTICE 'エラー: 複数の行が返されました。単一の結果を期待しています。';
        WHEN OTHERS THEN
            RAISE NOTICE '予期せぬエラーが発生しました: %', SQLERRM;
    END;
END $$;
```

**解説:**

1. `SELECT name INTO artist_name FROM artist;` は、`artist` テーブルに複数の行がある場合、`TOO_MANY_ROWS` 例外を発生させます。
2. `WHEN TOO_MANY_ROWS THEN` ブロックで例外をキャッチし、エラーメッセージを表示します。

---

### 問題 66: DML 操作中の SQLSTATE と SQLERRM の利用

**問題:** 存在しないテーブルを `UPDATE` しようと試み、`OTHERS` 例外をキャッチして、`SQLSTATE` と `SQLERRM` を使用して詳細なエラー情報を表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
BEGIN
    BEGIN
        UPDATE non_existent_table SET column_name = 'value';
        RAISE NOTICE 'テーブルが正常に更新されました。';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE NOTICE 'DMLエラーが発生しました。';
            RAISE NOTICE '  SQLSTATE: %', SQLSTATE;
            RAISE NOTICE '  SQLERRM: %', SQLERRM;
    END;
END $$;
```

**解説:**

1. `UPDATE non_existent_table` は `SQLSTATE '42P01'` (undefined_table) のエラーを発生させます。
2. `WHEN OTHERS THEN` でこのエラーをキャッチし、PL/pgSQL の組み込み変数 `SQLSTATE` (エラーコード) と `SQLERRM` (エラーメッセージ) を使用して、エラーの詳細を表示します。

---

### 問題 67: カスタム例外を定義し、RAISE EXCEPTION で発生させる

**問題:** 仮想的に「在庫不足」の状況をシミュレートし、`RAISE EXCEPTION` を使用してカスタム例外を発生させ、それを `WHEN SQLSTATE 'P0001'` (またはカスタム SQLSTATE) でキャッチしてメッセージを表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    item_id INTEGER := 101;
    requested_quantity INTEGER := 50;
    available_stock INTEGER := 30;
BEGIN
    BEGIN
        IF requested_quantity > available_stock THEN
            RAISE EXCEPTION 'InventoryError: アイテムID % の在庫が不足しています。要求数: %, 在庫数: %',
                            item_id, requested_quantity, available_stock;
        ELSE
            RAISE NOTICE 'アイテムID % の注文を処理しました。', item_id;
        END IF;
    EXCEPTION
        WHEN SQLSTATE 'P0001' THEN -- デフォルトのユーザー定義例外のSQLSTATE
            RAISE NOTICE 'カスタムエラーをキャッチ: %', SQLERRM;
        WHEN OTHERS THEN
            RAISE NOTICE '予期せぬエラーが発生しました: %', SQLERRM;
    END;
END $$;
```

**解説:**

1. `RAISE EXCEPTION 'メッセージ'` を使用して、カスタムエラーメッセージと共に例外を発生させます。
2. ユーザー定義例外のデフォルトの `SQLSTATE` は `'P0001'` です。`WHEN SQLSTATE 'P0001' THEN` でこれをキャッチし、`SQLERRM` で例外メッセージを取得します。

---

### 問題 68: RAISE NOTICE と RAISE WARNING を使い分ける

**問題:** 顧客の `email` が無効な形式の場合（例: '@' が含まれていない）に `RAISE WARNING` を、処理が成功した場合は `RAISE NOTICE` を表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    customer_rec customer%ROWTYPE;
    target_customer_id INTEGER := 1;
BEGIN
    SELECT * INTO customer_rec FROM customer WHERE customer_id = target_customer_id;

    IF customer_rec.email NOT LIKE '%@%' THEN
        RAISE WARNING '警告: 顧客ID % (% %) のメールアドレス "%" は無効な形式の可能性があります。',
                      target_customer_id, customer_rec.first_name, customer_rec.last_name, customer_rec.email;
    ELSE
        RAISE NOTICE '顧客ID % (% %) のメールアドレス "%" は有効な形式です。処理を続行します。',
                     target_customer_id, customer_rec.first_name, customer_rec.last_name, customer_rec.email;
    END IF;
END $$;
```

**解説:**

1. `RAISE WARNING` は、処理を中断せずに警告メッセージを出力します。これは、潜在的な問題を示すが、致命的ではない場合に便利です。
2. `RAISE NOTICE` は、情報メッセージを出力します。
3. `LIKE '%@%'` を使用して、メールアドレスに `@` が含まれているかを確認します。

---

### 問題 69: GET STACKED DIAGNOSTICS を使用してエラーコンテキストを取得する

**問題:** 意図的にエラーを発生させ（例: 0 除算）、`GET STACKED DIAGNOSTICS` を使用して、エラーメッセージ (`MESSAGE_TEXT`) と呼び出しスタック (`PG_CONTEXT`) を表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
BEGIN
    BEGIN
        PERFORM 1 / 0; -- 意図的に0除算エラーを発生させる
    EXCEPTION
        WHEN OTHERS THEN
            GET STACKED DIAGNOSTICS
                v_state   = RETURNED_SQLSTATE,
                v_msg     = MESSAGE_TEXT,
                v_detail  = PG_EXCEPTION_DETAIL,
                v_hint    = PG_EXCEPTION_HINT,
                v_context = PG_EXCEPTION_CONTEXT;

            RAISE NOTICE 'エラーが発生しました:';
            RAISE NOTICE '  SQLSTATE: %', v_state;
            RAISE NOTICE '  メッセージ: %', v_msg;
            IF v_detail IS NOT NULL THEN
                RAISE NOTICE '  詳細: %', v_detail;
            END IF;
            IF v_hint IS NOT NULL THEN
                RAISE NOTICE '  ヒント: %', v_hint;
            END IF;
            IF v_context IS NOT NULL THEN
                RAISE NOTICE '  コンテキスト: %', v_context;
            END IF;
    END;
END $$;
```

**解説:**

1. `PERFORM 1 / 0;` で 0 除算エラーを発生させます。
2. `GET STACKED DIAGNOSTICS` は、現在の例外に関する詳細情報を取得するための PL/pgSQL ステートメントです。
3. `RETURNED_SQLSTATE`, `MESSAGE_TEXT`, `PG_EXCEPTION_DETAIL`, `PG_EXCEPTION_HINT`, `PG_EXCEPTION_CONTEXT` などの項目を使用して、エラーの原因とコンテキストを深く掘り下げることができます。

---

### 問題 70: データ型の不一致(DATATYPE_MISMATCH)を処理する

**問題:** `customer` テーブルの `customer_id` (`INT`) に文字列を挿入しようと試み、`DATATYPE_MISMATCH` または `INVALID_TEXT_REPRESENTATION` (PostgreSQL の動作による) 例外をキャッチして「データ型が一致しません」と表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    invalid_id_value TEXT := 'abc'; -- INT型に挿入できない文字列
BEGIN
    BEGIN
        -- customer_idはSERIALなので、直接INSERTは通常行わないが、
        -- データ型不一致の例として無理やりUPDATEを試みる
        UPDATE customer SET customer_id = invalid_id_value::INT WHERE customer_id = 1;
        RAISE NOTICE 'データ型が更新されました。';
    EXCEPTION
        WHEN DATATYPE_MISMATCH THEN
            RAISE NOTICE 'エラー: データ型が一致しません。';
        WHEN INVALID_TEXT_REPRESENTATION THEN -- PostgreSQLでは通常こちらでキャッチされる
            RAISE NOTICE 'エラー: 無効なテキスト表現です (データ型が一致しません)。';
        WHEN OTHERS THEN
            RAISE NOTICE '予期せぬエラーが発生しました: %', SQLERRM;
    END;
END $$;
```

**解説:**

1. `invalid_id_value::INT` で文字列を無理やり整数にキャストしようとすると、データ型の不一致エラーが発生します。PostgreSQL では、このような場合に `INVALID_TEXT_REPRESENTATION` (SQLSTATE '22P02') がよく発生します。
2. `WHEN DATATYPE_MISMATCH` または `WHEN INVALID_TEXT_REPRESENTATION` で例外をキャッチし、適切なメッセージを表示します。

---

### 問題 71: 例外内でトランザクションを明示的にコミット/ロールバックしない（DO ブロックの性質）

**問題:** DO ブロック内で DML 操作とエラー発生のシナリオを作成し、明示的な `COMMIT` や `ROLLBACK` を行わずに、DO ブロックのトランザクションがどのように処理されるかを観察する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    customer_count_before INTEGER;
    customer_count_after INTEGER;
    test_customer_id INTEGER;
BEGIN
    -- 0. 初期状態を確認
    SELECT COUNT(*) INTO customer_count_before FROM customer;
    RAISE NOTICE '--- 開始 ---';
    RAISE NOTICE '処理前の顧客数: %', customer_count_before;

    BEGIN
        -- 1. 新しい顧客を挿入
        INSERT INTO customer (first_name, last_name, email)
        VALUES ('Test', 'User', 'test@example.com')
        RETURNING customer_id INTO test_customer_id;
        RAISE NOTICE '一時顧客 (ID: %) を挿入しました。', test_customer_id;

        -- 2. 意図的にエラーを発生させる (0除算)
        PERFORM 1 / 0;

        -- この行はエラーのため実行されない
        RAISE NOTICE 'このメッセージは表示されません。';

    EXCEPTION
        WHEN ZERO_DIVISION THEN
            RAISE NOTICE '例外をキャッチしました: 0除算エラー。';
            -- ここで明示的な ROLLBACK は行わない
        WHEN OTHERS THEN
            RAISE NOTICE 'その他の例外をキャッチ: %', SQLERRM;
    END;

    -- DOブロック全体が1つのトランザクションなので、
    -- 内部でエラーが発生すると、すべてのDMLは自動的にロールバックされる
    SELECT COUNT(*) INTO customer_count_after FROM customer;
    RAISE NOTICE '--- 終了 ---';
    RAISE NOTICE '処理後の顧客数: %', customer_count_after;

    IF customer_count_before = customer_count_after THEN
        RAISE NOTICE 'DOブロック内でエラーが発生したため、挿入はロールバックされました。';
    ELSE
        RAISE NOTICE 'DOブロック内でエラーが発生しましたが、挿入はコミットされたようです（予期しない動作）。';
    END IF;

END $$;
```

**解説:**

1. DO ブロックは単一のトランザクションとして実行されます。内部でエラーが発生し、それがキャッチされても、そのエラーが DO ブロック全体のトランザクションをアボートさせます。
2. この例では、顧客を挿入した後で 0 除算エラーを発生させています。`EXCEPTION` ブロックでエラーをキャッチしても、DO ブロック全体は失敗したとみなされ、挿入された顧客レコードは自動的にロールバックされます。
3. 外部の `SELECT COUNT(*)` で、挿入がロールバックされたことを確認できます。

---

### 問題 72: 例外ブロック内でさらに RAISE EXCEPTION する（再スロー）

**問題:** 存在しない顧客 ID への `SELECT INTO` で `NO_DATA_FOUND` をキャッチし、その例外ブロック内でさらにカスタムメッセージを付けて `RAISE EXCEPTION` することで、例外を再スローする PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    customer_rec customer%ROWTYPE;
    target_id INTEGER := 999;
BEGIN
    BEGIN -- 内部例外ブロック
        SELECT * INTO customer_rec FROM customer WHERE customer_id = target_id;
        RAISE NOTICE '顧客が見つかりました: %', customer_rec.first_name;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE EXCEPTION 'CustomerNotFoundError: 顧客ID % はシステムで見つかりません。', target_id;
    END;
EXCEPTION
    WHEN SQLSTATE 'P0001' THEN -- 外部例外ブロックで再スローされたカスタム例外をキャッチ
        RAISE NOTICE '外部ハンドラでキャッチ: %', SQLERRM;
    WHEN OTHERS THEN
        RAISE NOTICE '外部ハンドラで予期せぬエラーをキャッチ: %', SQLERRM;
END $$;
```

**解説:**

1. 内部の `BEGIN ... EXCEPTION ... END;` ブロックで `NO_DATA_FOUND` をキャッチします。
2. その例外ブロック内で `RAISE EXCEPTION 'CustomerNotFoundError: ...'` を使用して、より具体的なカスタム例外を発生させます。これは、例外の再スロー（re-raise）として機能します。
3. 外部の `EXCEPTION` ブロックで、再スローされたカスタム例外を `WHEN SQLSTATE 'P0001' THEN` でキャッチし、最終的なメッセージを表示します。

---

### 問題 73: CONSTRAINT_VIOLATION の一般的な処理

**問題:** `customer` テーブルに重複する `email` アドレスを持つ新しい顧客を挿入しようと試み（`email` 列に UNIQUE 制約があると仮定）、`CONSTRAINT_VIOLATION` 例外をキャッチして「重複するメールアドレスです」と表示する PL/pgSQL コードを作成してください。（`email` 列に UNIQUE 制約がない場合は、一時的に追加してください。）

**解答:**

```sql
-- 事前に email 列に UNIQUE 制約を追加 (実行前に確認/追加してください)
-- ALTER TABLE customer ADD CONSTRAINT customer_email_unique UNIQUE (email);

DO $$
DECLARE
    existing_customer_email VARCHAR(60);
    new_first_name VARCHAR(40) := 'Duplicate';
    new_last_name VARCHAR(20) := 'Email';
BEGIN
    -- 既存のメールアドレスを一つ取得 (例: customer_id = 1 のメールアドレス)
    SELECT email INTO existing_customer_email FROM customer WHERE customer_id = 1;

    BEGIN
        INSERT INTO customer (first_name, last_name, email)
        VALUES (new_first_name, new_last_name, existing_customer_email);
        RAISE NOTICE '新しい顧客が追加されました。';
    EXCEPTION
        WHEN CONSTRAINT_VIOLATION THEN
            RAISE NOTICE 'エラー: 重複するメールアドレスです ("%")。', existing_customer_email;
        WHEN OTHERS THEN
            RAISE NOTICE '予期せぬエラーが発生しました: %', SQLERRM;
    END;
END $$;

-- 制約を削除したい場合
-- ALTER TABLE customer DROP CONSTRAINT IF EXISTS customer_email_unique;
```

**解説:**

1. `customer.email` 列に `UNIQUE` 制約を追加していることを前提としています。
2. 既存のメールアドレスを新しい顧客の挿入に使用しようとすると、`UNIQUE` 制約違反が発生し、`CONSTRAINT_VIOLATION` 例外がスローされます。
3. `WHEN CONSTRAINT_VIOLATION THEN` で例外をキャッチし、適切なメッセージを表示します。

---

### 問題 74: NUMERIC_VALUE_OUT_OF_RANGE を処理する

**問題:** `track` テーブルの `unit_price` (`NUMERIC(10,2)`) に許容範囲を超える大きな数値を更新しようと試み、`NUMERIC_VALUE_OUT_OF_RANGE` 例外をキャッチして「数値が許容範囲を超えています」と表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    target_track_id INTEGER := 1;
    too_large_price NUMERIC(15,2) := 1234567891234.56; -- NUMERIC(10,2)の範囲を超える
BEGIN
    BEGIN
        UPDATE track SET unit_price = too_large_price WHERE track_id = target_track_id;
        RAISE NOTICE 'トラックID % の価格が更新されました。', target_track_id;
    EXCEPTION
        WHEN NUMERIC_VALUE_OUT_OF_RANGE THEN
            RAISE NOTICE 'エラー: トラックID % の単価が許容範囲 (NUMERIC(10,2)) を超えています。', target_track_id;
        WHEN OTHERS THEN
            RAISE NOTICE '予期せぬエラーが発生しました: %', SQLERRM;
    END;
END $$;
```

**解説:**

1. `NUMERIC(10,2)` は、合計 10 桁（小数点以下 2 桁）の数値を格納できます。つまり、小数点より前は 8 桁までです。`1234567891234.56` はこの範囲を大きく超えるため、`NUMERIC_VALUE_OUT_OF_RANGE` 例外が発生します。
2. `WHEN NUMERIC_VALUE_OUT_OF_RANGE THEN` で例外をキャッチし、適切なメッセージを表示します。

---

### 問題 75: 無効な日付フォーマット(INVALID_TEXT_REPRESENTATION)を処理する

**問題:** `employee` テーブルの `birth_date` (`TIMESTAMP`) に無効な文字列を更新しようと試み、`INVALID_TEXT_REPRESENTATION` 例外をキャッチして「日付フォーマットが無効です」と表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    target_employee_id INTEGER := 1;
    invalid_date_string TEXT := '2023-XX-YY'; -- 無効な日付フォーマット
BEGIN
    BEGIN
        UPDATE employee SET birth_date = invalid_date_string::TIMESTAMP WHERE employee_id = target_employee_id;
        RAISE NOTICE '従業員ID % の誕生日が更新されました。', target_employee_id;
    EXCEPTION
        WHEN INVALID_TEXT_REPRESENTATION THEN
            RAISE NOTICE 'エラー: 従業員ID % の日付フォーマットが無効です ("%")。', target_employee_id, invalid_date_string;
        WHEN OTHERS THEN
            RAISE NOTICE '予期せぬエラーが発生しました: %', SQLERRM;
    END;
END $$;
```

**解説:**

1. `invalid_date_string::TIMESTAMP` で無効な文字列を `TIMESTAMP` 型にキャストしようとすると、`INVALID_TEXT_REPRESENTATION` 例外が発生します。
2. `WHEN INVALID_TEXT_REPRESENTATION THEN` で例外をキャッチし、適切なメッセージを表示します。

---

### 問題 76: READ_ONLY_SQL_TRANSACTION_EXCEPTION を処理する

**問題:** `READ ONLY` トランザクションモードで `UPDATE` 文を実行しようと試み、`READ_ONLY_SQL_TRANSACTION_EXCEPTION` をキャッチして「読み取り専用トランザクションでは書き込み操作はできません」と表示する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    target_customer_id INTEGER := 1;
    new_address VARCHAR(70) := 'New Readonly Address';
BEGIN
    -- 現在のDOブロックを読み取り専用で実行
    SET LOCAL transaction_read_only TO ON;

    BEGIN
        UPDATE customer SET address = new_address WHERE customer_id = target_customer_id;
        RAISE NOTICE '顧客ID % の住所が更新されました。', target_customer_id;
    EXCEPTION
        WHEN READ_ONLY_SQL_TRANSACTION_EXCEPTION THEN
            RAISE NOTICE 'エラー: 読み取り専用トランザクションでは書き込み操作はできません。';
        WHEN OTHERS THEN
            RAISE NOTICE '予期せぬエラーが発生しました: %', SQLERRM;
    END;

    -- LOCAL設定はDOブロック終了時に自動的に元に戻る
    SET LOCAL transaction_read_only TO OFF; -- 明示的に戻す必要はないが、分かりやすさのため
END $$;
```

**解説:**

1. `SET LOCAL transaction_read_only TO ON;` を使用して、現在の DO ブロックのトランザクションを読み取り専用モードに設定します。
2. 読み取り専用モードで `UPDATE` を実行しようとすると、`READ_ONLY_SQL_TRANSACTION_EXCEPTION` 例外が発生します。
3. `WHEN READ_ONLY_SQL_TRANSACTION_EXCEPTION THEN` で例外をキャッチし、適切なメッセージを表示します。

---

### 問題 77: CHECK 制約違反 (CHECK_VIOLATION) を処理する

**問題:** `track` テーブルに `unit_price` が `0` または負の数を挿入しようと試み、`CHECK_VIOLATION` 例外をキャッチして「単価は正の数である必要があります」と表示する PL/pgSQL コードを作成してください。（`unit_price` に `CHECK (unit_price > 0)` 制約がない場合は、一時的に追加してください。）

**解答:**

```sql
-- 事前に track テーブルに CHECK 制約を追加
-- ALTER TABLE track ADD CONSTRAINT track_unit_price_positive CHECK (unit_price > 0);

DO $$
DECLARE
    album_id_val INTEGER;
    media_type_id_val INTEGER;
    genre_id_val INTEGER;
    invalid_price NUMERIC(10,2) := -0.50; -- CHECK制約に違反する価格
BEGIN
    -- 既存の有効なIDを取得してINSERTの他の制約を満たす
    SELECT album_id INTO album_id_val FROM album ORDER BY album_id LIMIT 1;
    SELECT media_type_id INTO media_type_id_val FROM media_type ORDER BY media_type_id LIMIT 1;
    SELECT genre_id INTO genre_id_val FROM genre ORDER BY genre_id LIMIT 1;

    BEGIN
        INSERT INTO track (name, album_id, media_type_id, genre_id, milliseconds, unit_price)
        VALUES ('Invalid Price Track', album_id_val, media_type_id_val, genre_id_val, 10000, invalid_price);
        RAISE NOTICE '新しいトラックが追加されました。';
    EXCEPTION
        WHEN CHECK_VIOLATION THEN
            RAISE NOTICE 'エラー: トラックの単価は正の数である必要があります (入力: %)。', invalid_price;
        WHEN OTHERS THEN
            RAISE NOTICE '予期せぬエラーが発生しました: %', SQLERRM;
    END;
END $$;

-- 制約を削除したい場合
-- ALTER TABLE track DROP CONSTRAINT IF EXISTS track_unit_price_positive;
```

**解説:**

1. `track.unit_price` に `CHECK (unit_price > 0)` 制約を追加していることを前提としています。
2. 負の `unit_price` を挿入しようとすると、`CHECK` 制約違反が発生し、`CHECK_VIOLATION` 例外がスローされます。
3. `WHEN CHECK_VIOLATION THEN` で例外をキャッチし、適切なメッセージを表示します。

---

### 問題 78: 複数の例外を同じブロックで処理する

**問題:** `NO_DATA_FOUND` と `TOO_MANY_ROWS` の両方の例外を同じ `EXCEPTION` ブロック内で異なるメッセージで処理する PL/pgSQL コードを作成してください。

**解答:**

```sql
DO $$
DECLARE
    my_value VARCHAR(100);
    test_case INTEGER := 1; -- 1: NO_DATA_FOUND, 2: TOO_MANY_ROWS, 3: Success
BEGIN
    BEGIN
        IF test_case = 1 THEN
            -- NO_DATA_FOUND を引き起こす
            SELECT name INTO my_value FROM genre WHERE genre_id = 999;
        ELSIF test_case = 2 THEN
            -- TOO_MANY_ROWS を引き起こす
            SELECT name INTO my_value FROM genre; -- 複数のジャンル名を単一変数に
        ELSE
            -- 成功ケース
            SELECT name INTO my_value FROM genre WHERE genre_id = 1;
        END IF;

        RAISE NOTICE '取得した値: %', my_value;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE NOTICE 'エラー: 期待されるデータが見つかりませんでした。';
        WHEN TOO_MANY_ROWS THEN
            RAISE NOTICE 'エラー: 複数のデータが見つかりました。単一の結果を期待していました。';
        WHEN OTHERS THEN
            RAISE NOTICE '予期せぬエラーが発生しました: %', SQLERRM;
    END;
END $$;
```

**解説:**

1. `test_case` 変数を変更することで、`NO_DATA_FOUND`、`TOO_MANY_ROWS`、または成功のいずれかのシナリオをシミュレートできます。
2. `EXCEPTION` ブロック内で `WHEN NO_DATA_FOUND THEN` と `WHEN TOO_MANY_ROWS THEN` の両方を定義し、それぞれの例外に対して異なる処理（メッセージ表示）を行います。

---

### 問題 79: ロールバックポイントの利用（SAVEPOINT と ROLLBACK TO SAVEPOINT）

**問題:** DO ブロック内で `SAVEPOINT` を設定し、その後に発生したエラーをキャッチして `ROLLBACK TO SAVEPOINT` を実行し、その後も処理を継続する PL/pgSQL コードを作成してください。（DO ブロック全体が単一トランザクションのため、これは DO ブロック内部でのみ有効で、DO ブロック終了時にはすべてコミットまたはロールバックされます。）

**解答:**

```sql
DO $$
DECLARE
    customer_count_before INTEGER;
    customer_count_after INTEGER;
    temp_customer_id INTEGER;
BEGIN
    SELECT COUNT(*) INTO customer_count_before FROM customer;
    RAISE NOTICE '--- 開始 ---';
    RAISE NOTICE '処理前の顧客数: %', customer_count_before;

    -- 最初の一時顧客を挿入 (これはロールバックされないことを期待)
    INSERT INTO customer (first_name, last_name, email)
    VALUES ('First', 'Customer', 'first@example.com');
    RAISE NOTICE '最初の顧客を挿入しました。';

    SAVEPOINT my_savepoint; -- セーブポイントを設定

    BEGIN -- ネストされたトランザクションブロック
        -- 2番目の一時顧客を挿入
        INSERT INTO customer (first_name, last_name, email)
        VALUES ('Second', 'Customer', 'second@example.com')
        RETURNING customer_id INTO temp_customer_id;
        RAISE NOTICE '2番目の顧客 (ID: %) を挿入しました。', temp_customer_id;

        -- 意図的にエラーを発生させる
        PERFORM 1 / 0;

        RAISE NOTICE 'このメッセージは表示されません。';
    EXCEPTION
        WHEN ZERO_DIVISION THEN
            RAISE NOTICE '例外をキャッチしました: 0除算エラー。セーブポイントにロールバックします。';
            ROLLBACK TO SAVEPOINT my_savepoint; -- セーブポイントに戻る
            RAISE NOTICE 'セーブポイントにロールバックしました。';
        WHEN OTHERS THEN
            RAISE NOTICE 'その他の例外をキャッチ: %', SQLERRM;
    END;

    -- セーブポイント以降の処理を継続
    RAISE NOTICE 'エラー処理後も処理を継続します。';
    INSERT INTO customer (first_name, last_name, email)
    VALUES ('Third', 'Customer', 'third@example.com');
    RAISE NOTICE '3番目の顧客を挿入しました。';


    SELECT COUNT(*) INTO customer_count_after FROM customer;
    RAISE NOTICE '--- 終了 ---';
    RAISE NOTICE '処理後の顧客数: %', customer_count_after;

    -- 注意: DOブロック全体が成功した場合、全てのINSERTがコミットされます。
    -- この例では、最終的に全ての挿入がコミットされることを示しています。
    -- 0除算エラーはセーブポイントまでロールバックされるものの、DOブロック全体としてはエラーにはなりません。
END $$;
```

**解説:**

1. `SAVEPOINT my_savepoint;` でセーブポイントを設定します。
2. 内部 `BEGIN ... EXCEPTION ... END;` ブロック内でエラーを発生させ、`WHEN ZERO_DIVISION THEN ROLLBACK TO SAVEPOINT my_savepoint;` でセーブポイントまでロールバックします。これにより、セーブポイント以降の DML 操作が元に戻されます。
3. エラーがキャッチされてロールバックされた後も、DO ブロック内の残りのコードが実行されます。
4. **重要:** DO ブロック全体が 1 つのトランザクションなので、この例ではセーブポイント後のエラー処理が成功した場合、DO ブロック全体としては成功と見なされ、すべての挿入（最初の顧客と 3 番目の顧客
