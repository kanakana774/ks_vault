### PL/pgSQL の基本的な構文と制御構造 (続き)

#### 5. エラーハンドリング

PL/pgSQL では、実行時のエラー（例外）を捕捉し、適切に処理するための強力なメカニズムが提供されています。これにより、スクリプトが予期せぬエラーで停止するのを防ぎ、堅牢なアプリケーションを構築できます。

##### 5.1. 例外ブロック (`EXCEPTION`)

`BEGIN ... END` ブロックの内部に `EXCEPTION` セクションを追加することで、そのブロック内で発生したエラーを捕捉して処理できます。

**構文:**

```sql
[ <<label>> ]
[ DECLARE
    declarations ]
BEGIN
    statements;
EXCEPTION
    WHEN condition [ OR condition ... ] THEN
        handler_statements;
    [ WHEN condition [ OR condition ... ] THEN
        handler_statements; ]
    [ ... ]
END [ label ];
```

###### 定義済み例外条件 (例: `NO_DATA_FOUND`, `TOO_MANY_ROWS`, `DUPLICATE_KEY_VALUE`)

PostgreSQL には、多くの定義済み例外条件が用意されています。これらを使用して、特定のエラータイプに対応できます。

- **`NO_DATA_FOUND`**: `SELECT INTO` が行を返さなかった場合に発生します。（ただし、デフォルトでは変数は `NULL` になるため、明示的に `STRICT` を付けないと例外は発生しません。`SELECT STRICT INTO` を使うか、`IF variable IS NULL THEN RAISE EXCEPTION '...'` のように手動で例外を発生させる必要があります。）
- **`TOO_MANY_ROWS`**: `SELECT INTO` が複数行を返した場合に発生します。
- **`DUPLICATE_KEY_VALUE`**: 一意性制約（PRIMARY KEY, UNIQUE 制約）に違反する `INSERT` や `UPDATE` を試みた場合に発生します。

**例 (TOO_MANY_ROWS):** `SELECT INTO` で複数行が返された場合のエラーを捕捉します。

```sql
DO $$
DECLARE
    first_customer_rec customer%ROWTYPE;
BEGIN
    RAISE NOTICE '--- TOO_MANY_ROWS 例外の捕捉 ---';
    BEGIN
        -- customer_id = 1 を指定すると1行だが、WHERE句をなくすと複数行となりエラー
        SELECT * INTO first_customer_rec FROM customer; -- 複数行を返すためエラーになる
        RAISE NOTICE 'これは表示されません: %', first_customer_rec.first_name; -- エラーでスキップ
    EXCEPTION
        WHEN TOO_MANY_ROWS THEN
            RAISE NOTICE 'エラー: 複数行が返されました。単一行のSELECT INTOには適しません。';
            -- エラーから回復し、別の処理を続行
    END;
    RAISE NOTICE '例外処理後もスクリプトは続行されます。';
END
$$;
```

**例 (DUPLICATE_KEY_VALUE):** 既に存在する ID で `artist` を挿入しようとした場合のエラーを捕捉します。

```sql
DO $$
DECLARE
    test_artist_id INTEGER := 1; -- 既存のID
    test_artist_name TEXT := 'Test Artist';
BEGIN
    RAISE NOTICE '--- DUPLICATE_KEY_VALUE 例外の捕捉 ---';
    BEGIN
        -- artist_id は SERIAL なので通常は指定しないが、テストのため明示的に指定
        INSERT INTO artist (artist_id, name) VALUES (test_artist_id, test_artist_name);
        RAISE NOTICE 'これは表示されません。';
    EXCEPTION
        WHEN DUPLICATE_KEY_VALUE THEN
            RAISE NOTICE 'エラー: Artist ID % は既に存在します。重複キーエラーを捕捉しました。', test_artist_id;
    END;
    RAISE NOTICE '例外処理後もスクリプトは続行されます。';
END
$$;
```

###### カスタム例外 (`RAISE EXCEPTION`)

特定のビジネスロジックに基づいて、独自のエラー条件を定義し、それを `RAISE EXCEPTION` で発生させることができます。

**構文:**

```sql
RAISE { INFO | LOG | NOTICE | WARNING | EXCEPTION } 'format' [, expression [, ...]] [ USING option = expression [, ...] ];
```

- `EXCEPTION`: エラーを発生させ、現在のトランザクションをロールバックさせます（デフォルト）。
- `NOTICE`, `WARNING`, `INFO`, `LOG`: エラーではなく、単なるメッセージをログに出力したりクライアントに表示したりします。スクリプトの実行は停止しません。

**例:** 顧客の年齢が特定の値より低い場合にカスタム例外を発生させます（`customer` テーブルには年齢情報がないため、架空の例）。

```sql
DO $$
DECLARE
    customer_age INTEGER := 17;
BEGIN
    RAISE NOTICE '--- カスタム例外の発生 ---';
    IF customer_age < 18 THEN
        RAISE EXCEPTION '顧客は未成年です (年齢: %)。サービス提供不可。', customer_age
        USING HINT = '18歳以上の顧客のみが対象です。';
    END IF;
    RAISE NOTICE 'このメッセージは表示されません。'; -- 上の例外でスクリプトが停止するため
EXCEPTION
    WHEN OTHERS THEN -- 他のすべての例外を捕捉
        RAISE NOTICE 'カスタム例外を捕捉しました: %', SQLERRM;
        RAISE NOTICE 'ヒント: %', SQLSTATE; -- SQLSTATE はエラーコードを返す
END
$$;
```

**注:** 上記の例では、`RAISE EXCEPTION` で発生した例外を `WHEN OTHERS` で捕捉しています。`USING HINT` も使用しています。

###### エラー情報の取得 (`SQLSTATE`, `SQLERRM`)

例外ハンドラ内では、以下の特殊変数を使用してエラーの詳細情報を取得できます。

- **`SQLSTATE`**: 5 文字の標準 SQL エラーコード（例: `'22001'` は文字列データ右辺長エラー、`'23505'` は一意性違反）。
- **`SQLERRM`**: エラーメッセージのテキスト。

**例 (SQLSTATE, SQLERRM):**

```sql
DO $$
BEGIN
    RAISE NOTICE '--- SQLSTATE と SQLERRM の取得 ---';
    BEGIN
        -- 意図的にエラーを発生させる (例: 存在しない関数を呼び出す)
        SELECT non_existent_function();
    EXCEPTION
        WHEN OTHERS THEN -- すべての例外を捕捉
            RAISE NOTICE 'エラーが発生しました！';
            RAISE NOTICE 'SQLSTATE: %', SQLSTATE; -- 例外の種類を示すコード
            RAISE NOTICE 'SQLERRM: %', SQLERRM;   -- エラーメッセージ
    END;
    RAISE NOTICE 'スクリプトは続行されます。';
END
$$;
```

##### 5.2. `RAISE` 文

`RAISE` 文は、メッセージを出力したり、エラーを発生させたりするために使用されます。

###### 通知レベル (`NOTICE`, `WARNING`, `EXCEPTION`)

- **`RAISE NOTICE`**: クライアントに情報メッセージを出力します。スクリプトの実行は継続されます。
- **`RAISE WARNING`**: クライアントに警告メッセージを出力します。スクリプトの実行は継続されます。
- **`RAISE EXCEPTION`**: エラーを発生させ、現在のトランザクションを中断し、変更をロールバックします。

**例:**

```sql
DO $$
BEGIN
    RAISE INFO 'これは情報メッセージです。';
    RAISE NOTICE 'これは通知メッセージです。';
    RAISE WARNING 'これは警告メッセージです。注意してください。';

    -- RAISE EXCEPTION はスクリプトを中断するため、この後に続くメッセージは表示されない
    -- RAISE EXCEPTION 'これは致命的なエラーです！';
    RAISE NOTICE 'この行は、RAISE EXCEPTION がコメントアウトされている場合にのみ表示されます。';
END
$$;
```

###### エラーメッセージのカスタマイズ

`RAISE` 文では、`USING` 句を使ってエラーメッセージに詳細な情報（`DETAIL`, `HINT`, `SCHEMA`, `TABLE`, `COLUMN`, `CONSTRAINT`, `DATA_TYPE`, `MESSAGE`）を追加できます。

**例:** カスタムエラーメッセージとヒントを付けて例外を発生させます。

```sql
DO $$
DECLARE
    invalid_value INTEGER := -5;
BEGIN
    IF invalid_value < 0 THEN
        RAISE EXCEPTION '無効な入力値: %', invalid_value
        USING HINT = '正の整数を入力してください。',
              DETAIL = '値が負であるため処理を続行できません。';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'エラーを捕捉: %', SQLERRM;
        RAISE NOTICE '詳細: %', PG_EXCEPTION_DETAIL; -- PG_EXCEPTION_DETAIL は詳細情報を取得する特殊変数 (PostgreSQL 12以降)
        RAISE NOTICE 'ヒント: %', PG_EXCEPTION_HINT;   -- PG_EXCEPTION_HINT はヒントを取得する特殊変数 (PostgreSQL 12以降)
END
$$;
```

##### 5.3. トランザクションとエラー処理の連携

PL/pgSQL ブロック全体は、暗黙的にトランザクションの一部として実行されます（`DO` ブロックは通常、単一のトランザクション内で実行されます）。

- **`RAISE EXCEPTION` が発生すると、現在のトランザクションは自動的にロールバックされます。** これは、エラーが発生した場合にデータベースの整合性を保つための重要な動作です。
- `EXCEPTION` ブロックでエラーを捕捉し、そこで `RAISE EXCEPTION` を再度発行しなければ、トランザクションはロールバックされず、`COMMIT` される可能性があります（`DO` ブロックや関数が終了した場合）。ただし、これは通常、トランザクション全体を失敗させる意図があるため、注意が必要です。
- 通常、`DO` ブロック内で捕捉された例外は、そのブロックの外のトランザクションをロールバックしません。しかし、`RAISE EXCEPTION` を `EXCEPTION` ブロック内で再発行すると、外側のトランザクションに伝播し、最終的にロールバックされます。

**例:** 複数回の更新操作中にエラーが発生した場合、全体をロールバックさせる例。

```sql
DO $$
DECLARE
    customer_id_1 INTEGER := 1;
    customer_id_2 INTEGER := 99999; -- 存在しないID
    affected_rows INTEGER;
BEGIN
    RAISE NOTICE '--- トランザクションとエラー処理の連携 ---';

    -- 明示的なトランザクションブロック（オプションだが、PL/pgSQL関数では暗黙的）
    BEGIN
        -- 最初の更新 (成功)
        UPDATE customer SET city = 'Updated City A' WHERE customer_id = customer_id_1;
        GET DIAGNOSTICS affected_rows = ROW_COUNT;
        RAISE NOTICE '顧客ID % を更新しました。影響行数: %', customer_id_1, affected_rows;

        -- 2番目の更新 (失敗する可能性がある操作)
        -- 意図的にエラーを起こすために、存在しないIDを更新しようとする
        UPDATE customer SET city = 'Updated City B' WHERE customer_id = customer_id_2;
        GET DIAGNOSTICS affected_rows = ROW_COUNT;
        -- もし customer_id_2 が見つからなければ affected_rows は0
        IF affected_rows = 0 THEN
            RAISE EXCEPTION '顧客ID % は見つかりませんでした。更新失敗。', customer_id_2;
        END IF;

        RAISE NOTICE 'このメッセージは表示されません。'; -- 上の例外でスキップ
    EXCEPTION
        WHEN OTHERS THEN
            RAISE NOTICE 'エラーが発生しました: %', SQLERRM;
            RAISE NOTICE 'トランザクションがロールバックされます。';
            -- ここで捕捉したエラーを再スローしない限り、DOブロック自体はコミットされる
            -- しかし、RAISE EXCEPTION が発生した場合、DOブロック全体がロールバックされる
            -- DOブロックは自身のトランザクションで実行されるため、その中でRAISE EXCEPTIONが発生すれば全体がロールバック
    END;
    RAISE NOTICE 'DOブロックの実行が終了しました。';
    -- 例外が捕捉され、再スローされなかった場合、ここまでの変更はコミットされる可能性がある
    -- しかし、RAISE EXCEPTION が捕捉されても、その例外によってDOブロックのトランザクションはロールバックされる。
END
$$;
```

**解説の補足:** `DO $$ ... END $$;` ブロックは、それ自体が単一のトランザクション内で実行されることがほとんどです。そのため、`DO` ブロック内で `RAISE EXCEPTION` が発生すると、たとえ `EXCEPTION` ハンドラで捕捉されたとしても、`DO` ブロック全体でなされた変更は自動的にロールバックされます。`EXCEPTION` ハンドラで、`RAISE` （引数なし）を使ってエラーを再スローしない限り、PL/pgSQL の実行は中断せず、例外ハンドラが完了すると、次のステートメント（`END $$;` の後）が実行され、結果としてトランザクションはコミットされます。しかし、`DO` ブロックではそれが起こりません。`RAISE EXCEPTION` が発生した場合、PL/pgSQL の**実行コンテキスト**が終了し、トランザクション全体がロールバックされるという動作が起こります。

---

### 練習問題

以下の指示に従って PL/pgSQL の `DO` ブロックを作成してください。

#### 問題 1: `NO_DATA_FOUND` (STRICT 使用) と `TOO_MANY_ROWS` の捕捉

1.  `DO` ブロック内で、`target_track_id` という名前の `INTEGER` 型の変数を宣言し、初期値として `99999` (存在しない ID) を代入してください。
2.  `track_name_val` 変数を `track.name%TYPE` で宣言してください。
3.  内側の `BEGIN ... EXCEPTION ... END` ブブロックを作成し、その中で以下の処理を行ってください。
    - `SELECT STRICT name INTO track_name_val FROM track WHERE track_id = target_track_id;` (存在しない ID の場合、`NO_DATA_FOUND` が発生するはずです)
    - `RAISE NOTICE` でトラック名を出力する行を含めてください (この行は `NO_DATA_FOUND` でスキップされるはずです)。
4.  `EXCEPTION` セクションで、`WHEN NO_DATA_FOUND THEN` と `WHEN TOO_MANY_ROWS THEN` を捕捉し、それぞれ適切な `RAISE NOTICE` メッセージ（例: `'指定されたトラックIDが見つかりませんでした。'`, `'複数のトラックが見つかりました。'`）を出力してください。
5.  `target_track_id` の初期値を `99999` でテストした後、`1` に変更して `TOO_MANY_ROWS` が発生しないことを確認し、さらに `WHERE` 句なしで `SELECT STRICT name INTO track_name_val FROM track;` を実行して `TOO_MANY_ROWS` が発生することも確認してください。

#### 問題 2: `DUPLICATE_KEY_VALUE` の捕捉とロールバックの確認

1.  `DO` ブロック内で、`test_genre_name` という名前の `TEXT` 型の変数を宣言し、初期値として `'Test Genre'` を代入してください。
2.  `test_genre_id` という名前の `INTEGER` 型の変数を宣言し、`genre` テーブルの現在の最大 `genre_id` + 1 の値で初期化してください。
    - ヒント: `SELECT MAX(genre_id) + 1 INTO test_genre_id FROM genre;`
3.  外側の `BEGIN ... EXCEPTION ... END` ブロックを作成し、その中で以下の処理を行ってください。
    - 最初に `test_genre_id` と `test_genre_name` を使って `genre` テーブルに新しいレコードを挿入してください。
    - その後に、同じ `test_genre_id` を使って再度 `genre` テーブルに同じ名前（または別の名前）を挿入しようとする行を含めてください。これにより、2 回目の挿入で `DUPLICATE_KEY_VALUE` エラーが発生するはずです。
4.  `EXCEPTION` セクションで `WHEN DUPLICATE_KEY_VALUE THEN` を捕捉し、`RAISE NOTICE` で `'重複するジャンルIDの挿入を試みました。'` と出力してください。
5.  **確認:** この `DO` ブロック全体がロールバックされるため、最終的に `genre` テーブルには `'Test Genre'` が追加されないことを確認してください。

#### 問題 3: カスタム例外 (`RAISE EXCEPTION`) とエラー情報の取得

1.  `DO` ブロック内で、`customer_country_param` という名前の `TEXT` 型の変数を宣言し、初期値として `'InvalidCountry'` を代入してください。
2.  内側の `BEGIN ... EXCEPTION ... END` ブブロックを作成してください。
3.  その中で、`customer_country_param` が `'USA'` または `'Canada'` のいずれでもない場合に、カスタム例外を発生させてください。
    - `RAISE EXCEPTION 'サポートされていない国: %', customer_country_param USING HINT = '有効な国はUSAまたはCanadaです。';` の形式を使用してください。
4.  `EXCEPTION` セクションで `WHEN OTHERS THEN` を捕捉し、以下の情報を `RAISE NOTICE` で出力してください。
    - `'エラーが発生しました！'`
    - `'SQLSTATE:' || SQLSTATE`
    - `'SQLERRM:' || SQLERRM`
    - `'詳細:' || PG_EXCEPTION_DETAIL` (PostgreSQL 12 以降の場合)
    - `'ヒント:' || PG_EXCEPTION_HINT` (PostgreSQL 12 以降の場合)
5.  `customer_country_param` の初期値を `'InvalidCountry'` でテストした後、`'USA'` に変更して例外が発生しないことを確認してください。

#### 問題 4: `RAISE NOTICE/WARNING` と `UPDATE` の組み合わせ

1.  `DO` ブロック内で、`invoice_id_to_check` という名前の `INTEGER` 型の変数を宣言し、初期値として `10` を代入してください。
2.  `total_amount` 変数を `invoice.total%TYPE` で宣言してください。
3.  `invoice_id_to_check` に対応する `invoice` の `total` 金額を `total_amount` に取得してください。
4.  以下の条件に基づいて `RAISE` 文を使用してください。
    - もし `total_amount` が `1.00` 未満の場合、`RAISE WARNING '請求ID % の合計金額が非常に低い (% ドル)。'` を出力してください。
    - もし `total_amount` が `1.00` 以上 `10.00` 未満の場合、`RAISE NOTICE '請求ID % の合計金額は標準です (% ドル)。'` を出力してください。
    - もし `total_amount` が `10.00` 以上の場合、`RAISE NOTICE '請求ID % の合計金額は高いです (% ドル)。'` を出力してください。
5.  `RAISE EXCEPTION` は使用せず、スクリプトが完了することを確認してください。
6.  `invoice_id_to_check` の値を変更して、異なる `total_amount` のケースをテストしてください。 (例: `1`, `5`, `20` など)

---

### 解答

#### 問題 1: `NO_DATA_FOUND` (STRICT 使用) と `TOO_MANY_ROWS` の捕捉

```sql
DO $$
DECLARE
    target_track_id INTEGER := 99999; -- 存在しないID
    track_name_val track.name%TYPE;
BEGIN
    RAISE NOTICE '--- NO_DATA_FOUND / TOO_MANY_ROWS 例外のテスト ---';

    -- NO_DATA_FOUND のテスト
    BEGIN
        RAISE NOTICE 'トラックID % で SELECT STRICT INTO を試みます (NO_DATA_FOUNDの期待)。', target_track_id;
        SELECT STRICT name INTO track_name_val FROM track WHERE track_id = target_track_id;
        RAISE NOTICE 'これは表示されません: トラック名: %', track_name_val;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE NOTICE '捕捉: 指定されたトラックID % は見つかりませんでした。', target_track_id;
        WHEN TOO_MANY_ROWS THEN
            RAISE NOTICE '捕捉: 複数のトラックが見つかりました。単一行のSELECT STRICT INTOには適しません。';
        WHEN OTHERS THEN
            RAISE NOTICE 'その他のエラー: %', SQLERRM;
    END;

    -- TOO_MANY_ROWS のテスト
    BEGIN
        RAISE NOTICE 'すべてのトラックで SELECT STRICT INTO を試みます (TOO_MANY_ROWSの期待)。';
        SELECT STRICT name INTO track_name_val FROM track; -- 複数行を返すため TOO_MANY_ROWS
        RAISE NOTICE 'これは表示されません: トラック名: %', track_name_val;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE NOTICE '捕捉: 指定されたトラックIDは見つかりませんでした。';
        WHEN TOO_MANY_ROWS THEN
            RAISE NOTICE '捕捉: 複数のトラックが見つかりました。単一行のSELECT STRICT INTOには適しません。';
        WHEN OTHERS THEN
            RAISE NOTICE 'その他のエラー: %', SQLERRM;
    END;

    RAISE NOTICE 'テストが完了しました。';
END
$$;
```

#### 問題 2: `DUPLICATE_KEY_VALUE` の捕捉とロールバックの確認

```sql
DO $$
DECLARE
    test_genre_name TEXT := 'Test Genre PLPGSQL'; -- 衝突を避けるためユニークな名前に
    test_genre_id INTEGER;
    affected_rows INTEGER;
BEGIN
    RAISE NOTICE '--- DUPLICATE_KEY_VALUE 例外のテストとロールバック確認 ---';

    -- 現在の最大 genre_id を取得し、+1 して新しいIDとする
    SELECT COALESCE(MAX(genre_id), 0) + 1 INTO test_genre_id FROM genre;
    RAISE NOTICE '新しいジャンルIDとして % を使用します。', test_genre_id;

    BEGIN
        -- 1回目の挿入 (成功するはず)
        INSERT INTO genre (genre_id, name) VALUES (test_genre_id, test_genre_name);
        GET DIAGNOSTICS affected_rows = ROW_COUNT;
        RAISE NOTICE '1回目の挿入成功: ジャンルID %, 名前 "%" (影響行数: %)', test_genre_id, test_genre_name, affected_rows;

        -- 2回目の挿入 (DUPLICATE_KEY_VALUE エラーが発生するはず)
        RAISE NOTICE '2回目の挿入を試みます (重複キーエラーを期待)...';
        INSERT INTO genre (genre_id, name) VALUES (test_genre_id, 'Another Name');
        RAISE NOTICE 'このメッセージは表示されません。'; -- エラーでスキップされる
    EXCEPTION
        WHEN DUPLICATE_KEY_VALUE THEN
            RAISE NOTICE '捕捉: 重複するジャンルID % の挿入を試みました。', test_genre_id;
            RAISE NOTICE 'SQLSTATE: %', SQLSTATE;
            RAISE NOTICE 'SQLERRM: %', SQLERRM;
            -- ここでRAISE EXCEPTIONを再発行しない限り、このブロックは終了するが、
            -- DOブロック全体としては最初のINSERTもロールバックされるはず。
    END;

    -- DOブロックは自身のトランザクションで実行されるため、
    -- 内部でRAISE EXCEPTION（DUPLICATE_KEY_VALUEはこれに相当）が発生した場合、
    -- 捕捉してもDOブロック全体のトランザクションはロールバックされる。
    RAISE NOTICE 'DOブロックの実行が終了しました。ジャンルテーブルを確認してください。';
    RAISE NOTICE 'ジャンル "%" (ID: %) は挿入されていないはずです。', test_genre_name, test_genre_id;
END
$$;
```

#### 問題 3: カスタム例外 (`RAISE EXCEPTION`) とエラー情報の取得

```sql
DO $$
DECLARE
    customer_country_param TEXT := 'InvalidCountry'; -- テスト用: InvalidCountry, USA, Canada
BEGIN
    RAISE NOTICE '--- カスタム例外とエラー情報取得のテスト ---';
    BEGIN
        IF customer_country_param NOT IN ('USA', 'Canada') THEN
            RAISE EXCEPTION 'サポートされていない国: %', customer_country_param
            USING HINT = '有効な国はUSAまたはCanadaです。',
                  DETAIL = '提供された国の値が許可リストに含まれていません。';
        ELSE
            RAISE NOTICE '有効な国: %', customer_country_param;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE NOTICE 'エラーが発生しました！';
            RAISE NOTICE 'SQLSTATE: %', SQLSTATE;
            RAISE NOTICE 'SQLERRM: %', SQLERRM;
            RAISE NOTICE '詳細: %', PG_EXCEPTION_DETAIL; -- PostgreSQL 12以降
            RAISE NOTICE 'ヒント: %', PG_EXCEPTION_HINT;   -- PostgreSQL 12以降
    END;
    RAISE NOTICE 'テストが完了しました。';
END
$$;
```

#### 問題 4: `RAISE NOTICE/WARNING` と `UPDATE` の組み合わせ

```sql
DO $$
DECLARE
    invoice_id_to_check INTEGER := 10; -- テスト用: 1 (total: 1.98), 5 (total: 8.91), 20 (total: 13.86)
    total_amount invoice.total%TYPE;
BEGIN
    RAISE NOTICE '--- 請求合計金額に応じた通知/警告 ---';

    SELECT total INTO total_amount
    FROM invoice
    WHERE invoice_id = invoice_id_to_check;

    IF total_amount IS NULL THEN
        RAISE WARNING '請求ID % が見つかりませんでした。', invoice_id_to_check;
    ELSIF total_amount < 1.00 THEN
        RAISE WARNING '請求ID % の合計金額が非常に低い (% ドル)。', invoice_id_to_check, total_amount;
    ELSIF total_amount >= 1.00 AND total_amount < 10.00 THEN
        RAISE NOTICE '請求ID % の合計金額は標準です (% ドル)。', invoice_id_to_check, total_amount;
    ELSE -- total_amount >= 10.00
        RAISE NOTICE '請求ID % の合計金額は高いです (% ドル)。', invoice_id_to_check, total_amount;
    END IF;

    RAISE NOTICE '請求合計金額のチェックが完了しました。スクリプトは継続されます。';
END
$$;
```
