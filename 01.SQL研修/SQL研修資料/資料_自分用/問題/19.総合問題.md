# PostgreSQL 総合練習問題 (応用編)

目的
複数のテーブルを結合し、集計関数やサブクエリを適切に用いて複雑なクエリを構築する能力を養うことを目的とします。

PostgreSQL 総合練習問題（回答と解説）

## 問題 1: 複数の結合と集計

すべての顧客について、それぞれの顧客が注文した商品カテゴリごとの合計注文金額を計算してください。
結果は顧客名、カテゴリ名、合計金額を一覧で表示し、合計金額の降順で並べてください。

### 回答:

```SQL
SELECT
    C.name AS customer_name,
    Cat.category_name,
    SUM(OI.quantity * P.price) AS total_amount
FROM Orders AS O
JOIN Customers AS C ON O.customer_id = C.customer_id
JOIN OrderItems AS OI ON O.order_id = OI.order_id
JOIN Products AS P ON OI.product_id = P.product_id
JOIN Categories AS Cat ON P.category_id = Cat.category_id
GROUP BY C.name, Cat.category_name
ORDER BY total_amount DESC;
```

### 解説:

Orders, Customers, OrderItems, Products, Categories の 5 つのテーブルを結合し、顧客名とカテゴリ名でグループ化して、注文金額を計算しています。

## 問題 2: サブクエリと条件指定

レビューの平均評価(rating)が 4.5 を超える商品カテゴリ(category_name)を特定し、そのカテゴリに属する商品の合計在庫数(stock_quantity)を計算してください。

### 回答:

```SQL
SELECT
    SUM(I.stock_quantity) AS total_stock_quantity
FROM Inventory AS I
JOIN Products AS P ON I.product_id = P.product_id
JOIN Categories AS Cat ON P.category_id = Cat.category_id
WHERE Cat.category_id IN (
    SELECT T2.category_id
    FROM Reviews AS T1
    JOIN Products AS T2 ON T1.product_id = T2.product_id
    GROUP BY T2.category_id
    HAVING AVG(T1.rating) > 4.5
);
```

### 解説:

サブクエリで平均評価が 4.5 を超えるカテゴリ ID を取得し、外側のクエリでそのカテゴリに属する商品の在庫数を集計しています。

## 問題 3: 結合、集計、そしてウィンドウ関数

"各顧客"の"各注文"について、その注文の総額と、その顧客の全注文の平均総額を並べて表示してください。
ヒント: ウィンドウ関数 AVG() を使用します。

### 回答:

```SQL
SELECT
    O.order_id,
    O.customer_id,
    SUM(OI.quantity * P.price) AS order_total,
    AVG(SUM(OI.quantity * P.price)) OVER (PARTITION BY O.customer_id) AS customer_avg_total
FROM Orders AS O
JOIN OrderItems AS OI ON O.order_id = OI.order_id
JOIN Products AS P ON OI.product_id = P.product_id
GROUP BY O.order_id, O.customer_id
ORDER BY O.customer_id, O.order_id;
```

### 解説:

OVER (PARTITION BY ...) を使用して、顧客(customer_id)ごとに注文の総額の平均値を計算しています。SUM() と AVG() を同時に使うことで、各注文の合計と顧客ごとの平均を同時に取得できます。

<!-- ## 問題 4: 結合、サブクエリ、および日付関数

2023 年に注文を完了した顧客(Customers.customer_id)のうち、最も多く注文をキャンセルした顧客を特定してください。
その顧客の ID、名前、およびキャンセル数を表示してください。

### 回答:

```SQL
SELECT
    C.customer_id,
    C.name,
    COUNT(O.order_id) AS canceled_orders_count
FROM Orders AS O
JOIN Customers AS C ON O.customer_id = C.customer_id
WHERE O.status = 'Canceled' AND EXTRACT(YEAR FROM O.order_date) = 2023
GROUP BY C.customer_id, C.name
ORDER BY canceled_orders_count DESC
LIMIT 1;
```

### 解説:

WHERE 句で注文ステータスと注文年をフィルタリングし、GROUP BY で顧客ごとに集計しています。LIMIT 1 で最もキャンセル数の多い顧客を特定します。 -->

## 問題 4: 複数の結合と条件付き集計

特定の都市(city)に住む顧客による、注文ステータス(status)ごとの注文総数を計算してください。
例えば、「東京」に住む顧客の「Completed」および「Pending」の注文数をそれぞれ表示します。

### 回答:

```SQL
SELECT
    C.city,
    SUM(CASE WHEN O.status = 'Completed' THEN 1 ELSE 0 END) AS completed_orders,
    SUM(CASE WHEN O.status = 'Pending' THEN 1 ELSE 0 END) AS pending_orders
FROM Customers AS C
JOIN Orders AS O ON C.customer_id = O.customer_id
GROUP BY C.city
HAVING C.city = '東京' -- ここはwhereでもよい;
```

### 解説:

CASE 文を使用して、特定の条件に応じて値を集計しています。これにより、1 つのクエリで複数のステータスの合計を同時に計算できます。HAVING を使用して特定の都市に絞り込んでいます。

## 問題 5: 複雑なサブクエリと HAVING 句

Products テーブル内で、同じ価格(price)を持つ商品が 2 つ以上存在するカテゴリ(category_name)をすべて見つけてください。

### 回答:

```SQL
SELECT T2.category_name
FROM Products AS T1
JOIN Categories AS T2 ON T1.category_id = T2.category_id
WHERE T1.price IN (
    SELECT price
    FROM Products
    GROUP BY price
    HAVING COUNT(product_id) >= 2
)
GROUP BY T2.category_name;
```

### 別解：

```SQL
SELECT
    C.CATEGORY_NAME, P.PRICE
FROM
    PRODUCTS P
JOIN
    CATEGORIES C ON P.CATEGORY_ID = C.CATEGORY_ID
GROUP BY
    C.CATEGORY_NAME, -- どのカテゴリの
    P.PRICE         -- どの価格か
HAVING
    COUNT(P.PRODUCT_ID) >= 2 -- その価格の商品が2つ以上あるか
ORDER BY
    C.CATEGORY_NAME;
```

### 解説:

内側のサブクエリで、price でグループ化し、同じ価格を持つ商品の数が 2 つ以上ある価格(price)を取得しています。その結果を使って外側のクエリでカテゴリ名を抽出しています。

## 問題 6: 結合と CASE 文

各注文(order_id)について、その注文に最も多く含まれる商品のカテゴリ名を表示してください。
同数の場合は、いずれか一つのカテゴリを表示すれば構いません。

### 回答:

```SQL
SELECT
    O.order_id,
    MAX(CASE WHEN T2.rn = 1 THEN T2.category_name ELSE NULL END) AS most_frequent_category
FROM Orders AS O
JOIN (
    SELECT
        OI.order_id,
        Cat.category_name,
        ROW_NUMBER() OVER (PARTITION BY OI.order_id ORDER BY COUNT(OI.product_id) DESC) AS rn
    FROM OrderItems AS OI
    JOIN Products AS P ON OI.product_id = P.product_id
    JOIN Categories AS Cat ON P.category_id = Cat.category_id
    GROUP BY OI.order_id, Cat.category_name
) AS T2 ON O.order_id = T2.order_id
GROUP BY O.order_id;
```

### 解説:

このクエリは、まずサブクエリで各注文内のカテゴリごとの商品数を集計し、ウィンドウ関数 ROW_NUMBER() を使って各注文内で最も多いカテゴリにランク付けします。外側のクエリでは、その結果を結合し、CASE 文と MAX() を使ってランク 1 のカテゴリ名を取り出しています。

## 問題 7: 複数の結合と在庫の分析

各倉庫(Warehouses.warehouse_name)に現在在庫がある商品のうち、まだ一度も注文されていない商品(OrderItems テーブルに存在しない商品)の数を計算してください。

### 回答:

```SQL
SELECT
    W.warehouse_name,
    COUNT(I.product_id) AS products_not_ordered
FROM Inventory AS I
JOIN Warehouses AS W ON I.warehouse_id = W.warehouse_id
LEFT JOIN OrderItems AS OI ON I.product_id = OI.product_id
WHERE OI.order_item_id IS NULL
GROUP BY W.warehouse_name;
```

### 解説:

LEFT JOIN を使用することで、OrderItems テーブルに一致する行がない Inventory の行をすべて保持します。WHERE OI.order_item_id IS NULL で、一度も注文されていない商品のみをフィルタリングしています。

## 問題 8: 顧客の行動分析

注文を 3 回以上行っており、かつ平均注文金額が $100.00 を超える顧客の ID と名前、および平均注文金額をリストアップしてください。

### 回答:

```SQL
SELECT
    C.customer_id,
    C.name,
    AVG(T2.total_order_amount) AS avg_order_amount
FROM Customers AS C
JOIN (
    SELECT
        O.customer_id,
        SUM(OI.quantity * P.price) AS total_order_amount
    FROM Orders AS O
    JOIN OrderItems AS OI ON O.order_id = OI.order_id
    JOIN Products AS P ON OI.product_id = P.product_id
    GROUP BY O.order_id, O.customer_id
) AS T2 ON C.customer_id = T2.customer_id
GROUP BY C.customer_id, C.name
HAVING COUNT(T2.total_order_amount) >= 3 AND AVG(T2.total_order_amount) > 100.00;
```

### 解説:

内側のサブクエリで顧客ごとの注文金額を計算し、外側のクエリでその結果を GROUP BY と HAVING を使ってさらに集計・フィルタリングしています。

## 問題 9: 全テーブルの総合的な結合と分析

すべてのテーブルを適切に結合し、各顧客の会員ランク(rank_name)と、その顧客が支払った合計金額、および合計割引額(合計金額 × 割引率)を計算して表示してください。
結果は、顧客 ID、顧客名、会員ランク、合計支払額、合計割引額を一覧で示してください。

### 回答:

```SQL
SELECT
    C.customer_id,
    C.name AS customer_name,
    M.rank_name,
    SUM(OI.quantity * P.price) AS total_payment,
    SUM(OI.quantity * P.price * (M.discount_rate / 100)) AS total_discount
FROM Customers AS C
JOIN Memberships AS M ON C.membership_id = M.membership_id
JOIN Orders AS O ON C.customer_id = O.customer_id
JOIN OrderItems AS OI ON O.order_id = OI.order_id
JOIN Products AS P ON OI.product_id = P.product_id
GROUP BY C.customer_id, C.name, M.rank_name, M.discount_rate
ORDER BY C.customer_id;
```

### 解説:

複数の JOIN 文を使って必要なすべてのテーブルを結合し、顧客、会員ランク、支払い、商品情報を統合しています。GROUP BY を適切に使い、顧客ごとの合計金額と合計割引額を計算しています。
