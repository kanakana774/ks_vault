## 問題1：
「東京都に住んでいる顧客が行ったすべての注文ID」を取得してください。



## 問題4：
「在庫数がすべての倉庫の平均在庫数より多い商品」を取得してください。
⇒ どの列を出力すべきか指示したほうがいいかも

```SQL
SELECT
	P.PRODUCT_ID,
	P.PRODUCT_NAME
FROM
	PRODUCTS P
	INNER JOIN INVENTORY I ON P.PRODUCT_ID = I.PRODUCT_ID
WHERE
	I.STOCK_QUANTITY > (
		SELECT
			AVG(STOCK_QUANTITY)
		FROM
			INVENTORY
	);
```

```SQL
-- 別に商品名出さなくてもいい。
SELECT
	PRODUCT_ID,
	STOCK_QUANTITY,
	(
		SELECT
			AVG(STOCK_QUANTITY)
		FROM
			INVENTORY
	) AS AVG_STOCK_QUANTITY -- 平均価格を並べることもできますね
FROM
	INVENTORY
WHERE
	STOCK_QUANTITY >= (
		SELECT
			AVG(STOCK_QUANTITY)
		FROM
			INVENTORY
	);
```

## 問 5：
「支払い金額が全体のトップ 3 に入る注文 ID と金額」を取得してください。

```SQL
SELECT
	ORDER_ID,
	AMOUNT
FROM
	PAYMENTS
WHERE
	AMOUNT IN (
		SELECT
			AMOUNT
		FROM
			PAYMENTS
		ORDER BY
			AMOUNT DESC
		LIMIT
			3
	);
```

⇒ 下記のように同率のものも出るようにするために amount でサブクエリを使ってる

```
"payment_id"	"order_id"	"payment_date"	"amount"	"method"
1	1	"2022-01-06"	1240.00	"Credit Card"
2	2	"2022-01-11"	800.00	"Cash"
3	3	"2022-01-16"	60.00	"Credit Card"
4	3	"2022-01-06"	60.00	"Credit Card"
5	3	"2022-01-06"	50.00

結果
"order_id"	"amount"
1	1240.00
2	800.00
3	60.00 →ここが同率 3 位
3	60.00 →ここが同率 3 位
```

## 問 6：
「最も多く売れた商品（数量ベース）の商品名と販売数量合計」を取得してください。

```SQL
SELECT
	P.PRODUCT_NAME,
	T.TOTAL_QUANTITY
FROM
	PRODUCTS P
	INNER JOIN (
		SELECT
			PRODUCT_ID,
			SUM(QUANTITY) AS TOTAL_QUANTITY
		FROM
			ORDERITEMS
		GROUP BY
			PRODUCT_ID
		ORDER BY
			TOTAL_QUANTITY DESC
		LIMIT
			1
	) AS T ON P.PRODUCT_ID = T.PRODUCT_ID;
```

## 問 7：
==相関サブクエリ==

各顧客が「最も高額な注文」で支払った金額を取得してください。

パターン 1: サブクエリ（集計 + 相関サブクエリ）

```SQL
SELECT
	C.CUSTOMER_ID,
	C.NAME,
	(
		SELECT
			MAX(P.AMOUNT)
		FROM
			ORDERS O
			INNER JOIN PAYMENTS P ON O.ORDER_ID = P.ORDER_ID
		WHERE
			O.CUSTOMER_ID = C.CUSTOMER_ID
	) AS MAX_PAYMENT
FROM
	CUSTOMERS C;
```

パターン 2: JOIN + GROUP BY で一発集計

```SQL
SELECT
	C.CUSTOMER_ID,
	C.NAME,
	MAX(P.AMOUNT) AS MAX_ORDER_TOTAL
FROM
	CUSTOMERS C
	LEFT JOIN ORDERS O ON C.CUSTOMER_ID = O.CUSTOMER_ID
	LEFT JOIN PAYMENTS P ON P.ORDER_ID = O.ORDER_ID
GROUP BY
	C.CUSTOMER_ID,
	C.NAME;
```

パターン 3: 二重集計（派生テーブル）

```SQL
-- まず注文ごとの合計
WITH OrderTotals AS (
    SELECT
        O.customer_id,
        O.order_id,
        SUM(P.price * OI.quantity) AS order_total
    FROM Orders O
    JOIN OrderItems OI ON O.order_id = OI.order_id
    JOIN Products P ON OI.product_id = P.product_id
    GROUP BY O.customer_id, O.order_id
)
-- 次に顧客ごとに最大注文を抽出
SELECT
    C.customer_id,
    C.name,
    MAX(OT.order_total) AS max_order_total
FROM Customers C
JOIN OrderTotals OT ON C.customer_id = OT.customer_id
GROUP BY C.customer_id, C.name;
```

特徴：
- クエリが見やすい。

## 問 8：
==相関サブクエリ==

平均より高い価格の商品だけを購入したことがある顧客の名前を取得してください

```SQL
SELECT
	C.CUSTOMER_ID,
	C.NAME
FROM
	CUSTOMERS C
WHERE
	NOT EXISTS ( -- 平均より低い価格の商品を買った履歴が存在しない
		SELECT
			1
		FROM
			ORDERS O
			INNER JOIN ORDERITEMS OI ON O.ORDER_ID = OI.ORDER_ID
			INNER JOIN PRODUCTS P ON OI.PRODUCT_ID = P.PRODUCT_ID
		WHERE
			O.CUSTOMER_ID = C.CUSTOMER_ID
			AND P.PRICE <= (
				SELECT
					AVG(PRICE)
				FROM
					PRODUCTS
			)
	);
```

==⇒ただこれだと一度も購入したことがない顧客も出てしまう。。。==


① NOT EXISTS + EXISTS

「平均以下の商品を買ったことがない」＋「少なくとも 1 回は購入している」

```SQL
SELECT C.customer_id, C.name
FROM Customers C
WHERE EXISTS ( -- 模範解答では一度も購入したことがない顧客も出てしまっているので、注文テーブルに存在してるか（＝購入履歴があるか）を条件に入れておく
    SELECT 1
    FROM Orders O
    JOIN OrderItems OI ON O.order_id = OI.order_id
    WHERE O.customer_id = C.customer_id
)
AND NOT EXISTS (
    SELECT 1
    FROM Orders O
    JOIN OrderItems OI ON O.order_id = OI.order_id
    JOIN Products P ON OI.product_id = P.product_id
    WHERE O.customer_id = C.customer_id
      AND P.price <= (SELECT AVG(price) FROM Products)
);
```

長所: 安全で意図が明確、実務でよく使われる
短所: サブクエリが 2 つありやや冗長

② MIN(price) を使う方法

「その顧客が買った商品の最小価格が平均より大きい」

```SQL
SELECT C.customer_id, C.name
FROM Customers C
WHERE (
    SELECT MIN(P.price)
    FROM Orders O
    JOIN OrderItems OI ON O.order_id = OI.order_id
    JOIN Products P ON OI.product_id = P.product_id
    WHERE O.customer_id = C.customer_id
) > (SELECT AVG(price) FROM Products);
```

長所: すっきりして読みやすい
短所: 「購入が 1 件もない場合 → MIN() = NULL → 比較不可」で自動的に除外される（逆にこれが利点になることも）

③ HAVING + 集約（JOINとGROUP BYで解決する方法）

顧客ごとにまとめてから判定する方法。

```SQL
SELECT O.customer_id, C.name
FROM Orders O
JOIN Customers C ON O.customer_id = C.customer_id
JOIN OrderItems OI ON O.order_id = OI.order_id
JOIN Products P ON OI.product_id = P.product_id
GROUP BY O.customer_id, C.name
HAVING MIN(P.price) > (SELECT AVG(price) FROM Products);
```

長所: 集計ベースのレポートなどと組み合わせやすい
短所: JOIN が多く、全件集計するのでパフォーマンス的にはやや重い

⇒joinで解決するとサブクエリの課題にならないので今回はNGか

④ NOT IN（非相関サブクエリで書いてしまう）

平均以下を買った顧客を除外する方法。

```SQL
SELECT C.customer_id, C.name
FROM Customers C
WHERE C.customer_id NOT IN (
    SELECT O.customer_id
    FROM Orders O
    JOIN OrderItems OI ON O.order_id = OI.order_id
    JOIN Products P ON OI.product_id = P.product_id
    WHERE P.price <= (SELECT AVG(price) FROM Products)
);
```

長所: シンプルで短い
短所: サブクエリ結果に NULL が含まれると全件返らなくなる（危険）
実務では非推奨（NULL 安全性のため）
⇒ただ、customer_idはnullにはならないのではないか。

---

実務観点での推奨順位

1. パターン ①（EXISTS + NOT EXISTS） … 一番安全で意図も明確
2. パターン ②（MIN 比較） … 条件が最小/最大値で表せるときはスッキリ
3. パターン ③（HAVING） … 集計レポート系の場面で便利
4. パターン ④（NOT IN） … 実務では避けるのが無難
