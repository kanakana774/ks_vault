最も外側のクエリ (`CUSTOMERS C` から `CUSTOMER_ID`, `NAME` を取得する部分) が主導し、その各行に対してサブクエリが実行されます。

### 各行の解説

1.  **"Seq Scan on customers c (cost=0.00..4741.28 rows=120 width=254) (actual time=0.053..0.087 rows=5 loops=1)"**

    - これは最も外側のクエリで、`CUSTOMERS` テーブルをシーケンシャルスキャン（全件スキャン）しています。
    - `loops=1` は、このスキャンが 1 回実行されたことを意味します。
    - `rows=5` は、最終的に 5 行が`CUSTOMERS`テーブルから選択されたことを示しています。

2.  **"SubPlan 1"**

    - ここがサブクエリの実行計画の開始です。`CUSTOMERS`テーブルの 1 行ごとにこのサブプランが実行されます。
    - **重要なポイント: `loops=5` は、このサブプラン全体が`CUSTOMERS`テーブルの 5 行に対してそれぞれ実行されたことを示します。つまり、相関サブクエリなので、外側のクエリの行数分だけサブクエリが繰り返し実行されます。**

3.  **"-> Aggregate (cost=39.41..39.42 rows=1 width=32) (actual time=0.012..0.012 rows=1 loops=5)"**

    - サブクエリ内で`MAX(P.AMOUNT)`を計算する部分です。
    - `loops=5` は、この Aggregate 処理が`CUSTOMERS`テーブルの各行（5 回）に対して実行されたことを示します。
    - `rows=1` は、`MAX`関数なので、結果として 1 行（最大の支払い額）が返されることを意味します。

4.  **"-> Hash Join (cost=20.43..39.40 rows=3 width=16) (actual time=0.008..0.008 rows=1 loops=5)"**

    - サブクエリ内で`ORDERS`と`PAYMENTS`を`ORDER_ID`で結合する部分です。
    - これも`loops=5`で、外側のクエリの各行に対して実行されています。
    - `rows=1` は、結合の結果として平均 1 行が見つかったことを意味します。（ただし、サブクエリの Filter が適用される前の段階での平均なので、後続の`rows Removed by Filter`と合わせて見るとより正確です）

5.  **"Hash Cond: (p.order_id = o.order_id)"**

    - ハッシュ結合の条件です。

6.  **"-> Seq Scan on payments p (cost=0.00..17.10 rows=710 width=20) (actual time=0.002..0.002 rows=5 loops=3)"**

    - ハッシュ結合のために`PAYMENTS`テーブルをスキャンしています。
    - **`loops=3`** となっているのは、実行計画全体の最適化の結果として、プランナーが`PAYMENTS`テーブルを 3 回スキャンしたことを示唆しています。（これはサブクエリのループ回数とは直接関係しません。結合のハッシュテーブルを構築する際などに複数回参照される可能性があります）

7.  **"-> Hash (cost=20.38..20.38 rows=4 width=4) (actual time=0.004..0.004 rows=1 loops=5)"**

    - ハッシュ結合のために、`ORDERS`テーブルから取得したデータをハッシュテーブルに構築しています。
    - `loops=5` は、このハッシュテーブルの構築が外側のクエリの各行（5 回）に対して行われたことを示します。

8.  **"-> Seq Scan on orders o (cost=0.00..20.38 rows=4 width=4) (actual time=0.002..0.002 rows=1 loops=5)"**

    - サブクエリ内で`ORDERS`テーブルをスキャンしています。
    - `loops=5` は、このスキャンが外側のクエリの各行（5 回）に対して実行されたことを示します。

9.  **"Filter: (customer_id = c.customer_id)"**

    - ここで相関サブクエリの条件が適用されています。外側の`CUSTOMERS`テーブルの`C.CUSTOMER_ID`が、サブクエリ内の`ORDERS`テーブルの`O.CUSTOMER_ID`と一致する行のみが選択されます。

10. **"Rows Removed by Filter: 3"**
    - `Filter`によって 3 行が除外され、平均で 1 行だけが条件を満たしたことを示します。これは`(4 rows - 3 rows removed = 1 row remaining)`と計算できます。

### 相関サブクエリの実行計画のポイント

- **`loops` の値:** 最も重要です。外側のクエリの各行に対して実行されるノードは、外側のクエリの行数（この例では`customers c`の`rows=5`）と同じ`loops`値を持つ傾向があります。これにより、サブクエリが繰り返し実行されていることがわかります。
- **ネストされた構造:** 実行計画はインデントによって階層的に表現されており、サブクエリがどのように外側のクエリの内部で実行されているかを示しています。

### この実行計画からわかること

- `CUSTOMERS`テーブルの各行に対して、`ORDERS`と`PAYMENTS`テーブルの結合と集計が繰り返し行われています。
- `ORDERS`テーブルには`customer_id`で絞り込むフィルターが適用されていますが、テーブル自体はシーケンシャルスキャンされています。もし`orders.customer_id`にインデックスがあれば、より効率的な`Index Scan`になる可能性があります。
- サブクエリ内の結合は`Hash Join`で行われていますが、結合対象のテーブルサイズ（特に`ORDERS`）が小さいため、それほど大きなオーバーヘッドにはなっていないようです。

### 改善のヒント

もし`CUSTOMERS`テーブルの行数が非常に多かったり、サブクエリの実行に時間がかかっている場合は、以下の点を検討すると良いでしょう。

- **`orders.customer_id` にインデックスを追加する:** サブクエリ内の`ORDERS`テーブルのフィルタリングが高速化されます。
- **JOIN への書き換え:** 相関サブクエリを避け、外部結合（LEFT JOIN など）や共通テーブル式（CTE）を使って、より効率的な結合に書き換えられないか検討します。今回のケースであれば、`MAX(P.AMOUNT)`が`GROUP BY O.CUSTOMER_ID`と結合される形に書き換えられる可能性が高いです。

```sql
SELECT
    C.CUSTOMER_ID,
    C.NAME,
    MAX(P.AMOUNT) AS MAX_PAYMENT
FROM
    CUSTOMERS C
LEFT JOIN
    ORDERS O ON C.CUSTOMER_ID = O.CUSTOMER_ID
LEFT JOIN
    PAYMENTS P ON O.ORDER_ID = P.ORDER_ID
GROUP BY
    C.CUSTOMER_ID, C.NAME;
```

このように書き換えると、通常はより効率的な実行計画が生成されることが多いです。

この解説がお役に立てれば幸いです！実行計画の読み込みは慣れの部分も大きいので、色々なクエリで試してみてください。
