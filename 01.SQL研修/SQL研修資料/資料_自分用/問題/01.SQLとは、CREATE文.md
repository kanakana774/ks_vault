以下の要件を満たすためのテーブルを作成する SQL を記述してください。

顧客情報:（customers_mst（顧客マスタ））
顧客ごとに一意の ID（customer_id） を割り当てる。
顧客の名前（customer_name）、uniqe なメールアドレス（email）、登録日（created_date）を記録する。
顧客が退会した場合、データを物理的に削除せず、論理的に削除した日時を記録する。（deleted_at）

商品情報:（products_mst（商品マスタ））
商品ごとに一意の ID（product_id） を割り当てる。
商品のカテゴリ（category）、名前（product_name）、価格（price）、在庫数（stock_quantity）を記録する。
商品の説明を自由に記述できるようにする。（memo）
販売終了となった商品は、論理的に削除した日時を記録する。（deleted_at）

注文情報:（orders_trn（注文トランザクション））
注文ごとに一意の ID を割り当てる。（order_id）
どの顧客（customer_id）が、いつ注文したかを記録する。（order_date）
注文がキャンセルされた場合、論理的に削除した日時を記録する。（deleted_at）
顧客情報テーブルとの関連付け（外部キー設定）を行う。（customer_id）

注文明細:（order_details_trn（注文明細トランザクション））
注文と商品の組み合わせで一意になるようにする。(order_id, product_id)
各注文に、どの商品が、いくつ含まれているかを記録する。（quantity）
注文の一部がキャンセルされた場合、論理的に削除した日時を記録する。（deleted_at）
注文情報テーブルおよび商品情報テーブルとの関連付け（外部キー設定）を行う。(order_id, product_id)

備考：
・データ型はどれがふさわしいか考えてみてください。（１００％正解はないので考える機会と思って、、、）
・not null 制約は適宜必要だと思った場合に追加してください。
・外部キーを使用し、テーブル間の関係を表現してください。

### 答え

```SQL
-- 顧客マスタ (customers_mst)
CREATE TABLE customers_mst (
customer_id SERIAL PRIMARY KEY,
customer_name VARCHAR(255) NOT NULL,
email VARCHAR(255) UNIQUE NOT NULL,
created_date DATE NOT NULL,
deleted_at TIMESTAMPTZ -- これは所謂メタカラム（論理削除のフラグ替わりなので正確な時間をTIMESTAMPTZで記録する意図）
);

-- 商品マスタ (products_mst)
CREATE TABLE products_mst (
product_id SERIAL PRIMARY KEY,
category VARCHAR(100) NOT NULL,
product_name VARCHAR(255) NOT NULL,
price NUMERIC(10, 2) NOT NULL,
stock_quantity INTEGER NOT NULL,
memo TEXT,
deleted_at TIMESTAMPTZ
);

-- 注文トランザクション (orders_trn)
CREATE TABLE orders_trn (
order_id SERIAL PRIMARY KEY,
customer_id INTEGER NOT NULL,
order_date DATE NOT NULL,
deleted_at TIMESTAMPTZ,
FOREIGN KEY (customer_id) REFERENCES customers_mst(customer_id)
);

-- 注文明細トランザクション (order_details_trn)
CREATE TABLE order_details_trn (
order_id INTEGER NOT NULL,
product_id INTEGER NOT NULL,
quantity INTEGER NOT NULL,
deleted_at TIMESTAMPTZ,
PRIMARY KEY (order_id, product_id),
FOREIGN KEY (order_id) REFERENCES orders_trn(order_id),
FOREIGN KEY (product_id) REFERENCES products_mst(product_id)
);

```

### 完了したら答えのテーブルに差し替えてもらって、下記サンプルデータを投入する。

### 備考：後の問題で使用します。

```SQL
-- サンプルデータの挿入
-- customers_mst にデータ挿入
INSERT INTO customers_mst (customer_id, customer_name, email, created_date, deleted_at) VALUES
(1, '佐藤 太郎', 'sato.taro@example.com', '2023-01-15', NULL),
(2, '鈴木 花子', 'suzuki.hanako@example.com', '2023-02-20', NULL),
(3, '田中 健太', 'tanaka.kenta@example.com', '2023-03-01', NULL),
(4, '山田 恵美', 'yamada.emi@example.com', '2023-04-10', '2023-09-15 10:00:00+0900'), -- 【狙い①】論理削除された顧客
(5, '渡辺 剛', 'watanabe.takeshi@example.com', '2023-05-05', NULL),
(6, '高橋 明', 'takahashi.akira@example.com', '2023-06-12', NULL),
(7, '中村 友子', 'nakamura.tomoko@example.com', '2023-07-25', NULL),
(8, '小林 大輔', 'kobayashi.daisuke@example.com', '2023-08-01', NULL),
(9, '伊藤 さやか', 'ito.sayaka@example.com', '2023-09-18', NULL); -- 【狙い②】未購入の顧客

-- products_mst にデータ挿入
INSERT INTO products_mst (product_id, category, product_name, price, stock_quantity, memo, deleted_at) VALUES
(1, 'Electronics', 'ワイヤレスイヤホン', 12800.00, 150, '高音質でノイズキャンセリング機能付き', NULL),
(2, 'Books', 'SQL 入門', 2500.00, 200, NULL, NULL),
(3, 'Home & Kitchen', '電気ケトル', 4500.00, 80, '1L 容量、自動電源オフ機能', NULL),
(4, 'Electronics', 'スマートウォッチ', 29800.00, 100, '心拍数モニタリング、GPS 搭載', NULL),
(5, 'Books', 'Python プログラミング', 3200.00, 120, '初心者向けの解説書', NULL),
(6, 'Food', 'オーガニックコーヒー豆', 1800.00, 300, NULL, NULL),
(7, 'Home & Kitchen', '高性能ブレンダー', 9800.00, 0, 'スムージー作りに最適', NULL), -- 【狙い④】在庫が0の商品
(8, 'Electronics', 'USB 充電器', 1500.00, 500, 'PD 対応、急速充電可能', NULL),
(9, 'Books', 'データ分析の基礎', 3800.00, 90, '統計学の基本から学習', NULL),
(10, 'Food', '高級チョコレートアソート', 2200.00, 180, 'ギフトにも最適', NULL),
(11, 'Electronics', 'ゲーミングマウス', 7800.00, 70, NULL, '2023-09-20 18:00:00+0900'), -- 【狙い①】論理削除された商品
(12, 'Home & Kitchen', 'セラミックフライパン', 5500.00, 110, '焦げ付きにくい加工', NULL),
(13, 'Books', '自己啓発の法則', 1800.00, 250, '成功へのヒント', NULL),
(14, 'Electronics', 'ポータブルバッテリー', 3980.00, 220, '大容量、軽量設計', NULL),
(15, 'Food', '国産はちみつ', 1200.00, 400, '100%純粋なはちみつ', NULL),
(16, 'Stationery', '多機能ボールペン', 2800.00, 300, '5色ボールペン+シャープペンシル', NULL); -- 【狙い③】未販売の商品

-- orders_trn にデータ挿入
INSERT INTO orders_trn (order_id, customer_id, order_date, deleted_at) VALUES
(1, 1, '2023-08-01', NULL), -- 佐藤太郎
(2, 2, '2023-08-05', NULL), -- 鈴木花子
(3, 1, '2023-08-10', NULL), -- 佐藤太郎 (2回目)
(4, 3, '2023-08-12', NULL), -- 田中健太
(5, 4, '2023-08-15', NULL), -- 山田恵美 (退会前の注文)
(6, 2, '2023-08-20', NULL), -- 鈴木花子 (2回目)
(7, 5, '2023-08-22', NULL), -- 渡辺剛
(8, 1, '2023-08-25', NULL), -- 佐藤太郎 (3回目)
(9, 6, '2023-09-01', '2023-09-02 11:30:00+0900'), -- 【狙い①】キャンセルされた注文
(10, 7, '2023-09-05', NULL), -- 中村友子
(11, 8, '2023-09-10', NULL); -- 小林大輔

-- order_details_trn にデータ挿入
INSERT INTO order_details_trn (order_id, product_id, quantity, deleted_at) VALUES
(1, 1, 1, NULL),  -- 佐藤: ワイヤレスイヤホン
(1, 6, 2, NULL),  -- 佐藤: オーガニックコーヒー豆
(2, 2, 1, NULL),  -- 鈴木: SQL 入門
(2, 3, 1, NULL),  -- 鈴木: 電気ケトル
(3, 4, 1, NULL),  -- 佐藤: スマートウォッチ
(3, 8, 3, NULL),  -- 佐藤: USB 充電器
(4, 5, 1, NULL),  -- 田中: Python プログラミング
(4, 7, 1, NULL),  -- 田中: 高性能ブレンダー
(5, 1, 1, NULL),  -- 山田: ワイヤレスイヤホン
(5, 9, 1, NULL),  -- 山田: データ分析の基礎
(6, 10, 2, NULL), -- 鈴木: 高級チョコレートアソート
(7, 11, 1, NULL), -- 渡辺: ゲーミングマウス (販売終了前の注文)
(7, 14, 1, NULL), -- 渡辺: ポータブルバッテリー
(8, 2, 1, NULL),  -- 佐藤: SQL 入門
(8, 12, 1, NULL), -- 佐藤: セラミックフライパン
(9, 13, 1, '2023-09-02 11:30:00+0900'), -- 【狙い①】キャンセルされた注文の明細
(10, 15, 500, NULL), -- 【狙い④】在庫数を超える大量注文
(11, 1, 1, NULL);  -- 小林: ワイヤレスイヤホン

-- SERIALのシーケンスを手動でリセット（データ投入後にIDの続きから始まるようにするため） 
SELECT setval('customers_mst_customer_id_seq', (SELECT MAX(customer_id) FROM customers_mst)); 
SELECT setval('products_mst_product_id_seq', (SELECT MAX(product_id) FROM products_mst)); 
SELECT setval('orders_trn_order_id_seq', (SELECT MAX(order_id) FROM orders_trn));
```

## 追加問題

### 問題：蔵書管理システムのテーブル設計

### 要件

- **著者（authors）**は、名前（name）と生年月日（birth_date）を持つ。また、著者を一意に特定するためのサロゲートキー（author_id）を主キーとする。書籍は 1 人以上の著者を持つことがある。
- **書籍（books）**には、タイトル（title）、著者（著者（authors）の主キーを参照する）、出版年（publish_year） が含まれる。また、書籍を一意に特定するためのサロゲートキー（book_id）を主キーとする。
- **利用者（users）**は、名前（name）、メールアドレス（email）、会員登録日（registered_date）を持つ。また、利用者を一意に特定するためのサロゲートキー（user_id）を主キーとする。
- **貸出履歴（loans）**は、書籍（書籍情報）が誰に（利用者情報）いつ貸し出され（loan_date）、いつ返却されたか（return_date）を記録する。また、貸出履歴を一意に特定するためのサロゲートキー（loan_id）を主キーとする。

テーブル同士の関係を表現するため、外部キーは適宜使用してください。
時間があれば、共同著者が存在するバージョン（著者と書籍の関係を多対多になる場合にどうなるか考えてみてください。）

解答例：テーブル定義（PostgreSQL）

```SQL
-- 著者テーブル
CREATE TABLE authors (
author_id SERIAL PRIMARY KEY,
name VARCHAR(100) NOT NULL,
birth_date DATE
);

-- 書籍テーブル
CREATE TABLE books (
book_id SERIAL PRIMARY KEY,
title VARCHAR(200) NOT NULL,
publish_year INT, -- これdateがいいか
author_id INT REFERENCES authors(author_id)
);

-- 利用者テーブル
CREATE TABLE users (
user_id SERIAL PRIMARY KEY,
name VARCHAR(100) NOT NULL,
email VARCHAR(100) UNIQUE NOT NULL,
registered_date DATE DEFAULT CURRENT_DATE
);

-- 貸出履歴テーブル
CREATE TABLE loans (
loan_id SERIAL PRIMARY KEY,
book_id INT REFERENCES books(book_id),
user_id INT REFERENCES users(user_id),
loan_date DATE NOT NULL,
return_date DATE
);

サンプルデータ
-- 著者
INSERT INTO authors (name, birth_date) VALUES
('村上 春樹', '1949-01-12'),
('東野 圭吾', '1958-02-04');

-- 書籍
INSERT INTO books (title, publish_year, author_id) VALUES
('ノルウェイの森', 1987, 1),
('白夜行', 1999, 2);

-- 利用者
INSERT INTO users (name, email) VALUES
('佐藤 太郎', 'taro.sato@example.com'),
('鈴木 花子', 'hanako.suzuki@example.com');

-- 貸出履歴
INSERT INTO loans (book_id, user_id, loan_date, return_date) VALUES
(1, 1, '2025-08-20', '2025-09-01'),
(2, 2, '2025-09-01', NULL);
```

💡 補足

- books テーブルの author_id は外部キーとして authors に紐づいています。
- loans テーブルは、books と users の両方に外部キーを持ち、貸出履歴を管理します。
- 実際のシステムでは、著者と書籍の関係を多対多にする場合、book_authors のような中間テーブルを設けることもあります。

著者と書籍の関係を**多対多（many-to-many）**にするには、**中間テーブル（junction table）**が必要です。現在の books テーブルには author_id が直接入っていて、1 冊の本に 1 人の著者しか紐づけられません。これを複数著者に対応させるには、author_id を削除し、代わりに book_authors のような中間テーブルを作成します。

🛠 中間テーブルの設計例：book_authors

```SQL
CREATE TABLE book_authors (
    book_id INT REFERENCES books(book_id) ON DELETE CASCADE,
    author_id INT REFERENCES authors(author_id) ON DELETE CASCADE,
    PRIMARY KEY (book_id, author_id)
);
```

### 説明

- book_id と author_id の組み合わせで主キーを構成し、重複を防ぎます。
- ON DELETE CASCADE を使うことで、元の books や authors が削除されたときに関連レコードも自動削除されます（必要に応じて）。
- このテーブルにより、1 冊の本に複数の著者、1 人の著者が複数の本を書くことが可能になります。

### 書籍テーブルの修正案

```SQL
CREATE TABLE books (
    book_id SERIAL PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    publish_date DATE -- 年だけなら INT でもOKだが、DATE の方が柔軟
);
```

author_id は削除して、著者との紐づけは book_authors に任せます。

もし「著者の役割（例：監修、共著、翻訳）」なども管理したい場合は、book_authors に role カラムを追加するのもアリです：

```SQL
role VARCHAR(50) -- 例: '著者', '翻訳者', '監修者'
```
