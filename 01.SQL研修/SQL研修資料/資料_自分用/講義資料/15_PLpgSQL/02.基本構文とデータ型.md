## II. 基本構文とデータ型 (Basic Syntax and Data Types)

PL/pgSQL で意味のある処理を行うには、データを一時的に保存しておく「変数」が不可欠です。この単元では、変数をどのように宣言し、どのような種類のデータを扱えるのか、そして変数に値を設定する方法を学びます。

### 1. 宣言とスコープ

#### 変数の宣言とデータ型指定

変数は、`DECLARE`セクションで宣言します。宣言の基本構文は以下の通りです。

`variable_name [ CONSTANT ] data_type [ NOT NULL ] [ { DEFAULT | := | = } expression ];`

- `CONSTANT`: 変数を定数として宣言します。一度代入すると、その後は値を変更できなくなるため、意図しない書き換えを防ぎ、コードの安全性を高めます。（例: 消費税率など）
- `NOT NULL`: 変数が`NULL`値を持つことを禁止します。これにより、予期せぬ`NULL`が原因で処理がエラーになることを防ぎ、より堅牢なコードを書く助けとなります。

  **【補足】変数の命名規則に関する慣習**
  必須ではありませんが、コードの可読性を高めるために、変数の役割に応じた接頭辞（プレフィックス）を付けることが推奨されます。
* `v_` : 一般的な変数 (例: `v_user_name`)
* `p_` : 関数の引数 (例: `p_employee_id`)
* `c_` : 定数 (例: `c_tax_rate`)
* `r_` または `rec_` : レコード型の変数 (例: `r_employee`)

**具体例：基本的な変数を宣言する**

```sql
DO $$
DECLARE
    v_user_name   text;  -- TEXT型の変数を宣言
    v_user_id     integer := 101;  -- 宣言と同時に初期値を代入
    d_signup_date date DEFAULT '2025-11-01'; -- DEFAULT句で初期値を代入
    b_is_active   boolean NOT NULL = true; -- NULLを許容しない制約
    C_PI          CONSTANT numeric := 3.14159; -- 定数の宣言
BEGIN
    v_user_name := 'Hanako Suzuki';

    RAISE NOTICE 'User ID: %, Name: %, Active: %', v_user_id, v_user_name, b_is_active;
    RAISE NOTICE 'Signup Date: %', d_signup_date;
    RAISE NOTICE 'PI: %', C_PI;
END;
$$ LANGUAGE plpgsql;
```

**実行結果:**

```
NOTICE:  User ID: 101, Name: Hanako Suzuki, Active: true
NOTICE:  Signup Date: 2025-11-01
NOTICE:  PI: 3.14159
```

#### スコープ：変数が有効な範囲

変数が使える範囲（スコープ）は、その変数が宣言された`BEGIN ... END`ブロックの内部に限られます。ブロックを入れ子にすることもでき、内側のブロックは外側のブロックで宣言された変数にアクセスできます。

**具体例：ブロックのスコープを確認する**

```sql
DO $$
DECLARE
    v_outer_variable integer := 10;
BEGIN
    RAISE NOTICE 'Outer block: v_outer_variable = %', v_outer_variable; -- => 10

    -- 内側のブロックを開始
    DECLARE
        v_inner_variable integer := 20;
    BEGIN
        RAISE NOTICE 'Inner block: v_outer_variable = %', v_outer_variable; -- 外側の変数にアクセス可能 => 10
        RAISE NOTICE 'Inner block: v_inner_variable = %', v_inner_variable; -- => 20
    END;
    -- 内側のブロックが終了

    -- ここでv_inner_variableにアクセスしようとするとエラーになる
    -- RAISE NOTICE 'Outer block: v_inner_variable = %', v_inner_variable; -- ERROR: "v_inner_variable" does not exist
END;
$$ LANGUAGE plpgsql;
```

#### ラベル付きブロックと修飾名

ブロックには `<<label_name>>` という形式で**ラベル**を付けることができます。これは、主に 2 つの目的で役立ちます。

1.  **変数名の競合を解決する**: 内側と外側のブロックで同じ名前の変数を宣言した場合でも、`label_name.variable_name` という「修飾名」を使うことで、外側のブロックの変数を明示的に参照できます。
2.  **ループの制御**: `LOOP` 構文と組み合わせることで、多重ループの中から特定のループを `EXIT` したり `CONTINUE` したりできます（詳細は制御構造の章で解説）。

**具体例：ラベルを使って同名変数にアクセスする**

```sql
DO $$
<<outer_block>>
DECLARE
    v_counter integer := 1;
BEGIN
    RAISE NOTICE 'Outer block counter: %', outer_block.v_counter; -- => 1

    <<inner_block>>
    DECLARE
        v_counter integer := 2;
    BEGIN
        RAISE NOTICE 'Inner block counter: %', inner_block.v_counter; -- => 2

        -- ラベルを使って外側のブロックの変数にアクセスする
        RAISE NOTICE 'Outer counter from inner block: %', outer_block.v_counter; -- => 1

        -- ラベルを付けないと、最も内側のスコープにある変数が参照される
        RAISE NOTICE 'Counter without label in inner block: %', v_counter; -- => 2
    END;

    RAISE NOTICE 'Back in outer block, counter is: %', v_counter; -- => 1
END;
$$ LANGUAGE plpgsql;
```


### 2. 主要なデータ型と操作

PL/pgSQL では、PostgreSQL がサポートするすべてのデータ型を利用できます。ここでは特に利用頻度の高いものを紹介します。

**基本的なデータ型**

| カテゴリ        | データ型           | 説明                                                         |
| :-------------- | :----------------- | :----------------------------------------------------------- |
| **数値型**      | `integer`          | 整数を格納します。                                           |
|                 | `numeric(p, s)`    | 固定小数点数を正確に格納します。金額計算などに適しています。 |
|                 | `double precision` | 浮動小数点数を格納します。                                   |
| **文字列型**    | `text`             | 長さ制限のない可変長の文字列を格納します。                   |
|                 | `varchar(n)`       | 最大長 n の可変長文字列を格納します。                        |
| **日付/時刻型** | `date`             | 日付のみを格納します。                                       |
|                 | `time`             | 時刻のみを格納します。                                       |
|                 | `timestamp`        | 日付と時刻の両方を格納します。                               |
| **論理型**      | `boolean`          | `true`, `false`, `NULL`のいずれかの値を格納します。          |

#### 便利な属性：`%TYPE` と `%ROWTYPE`

テーブルの定義が変わるたびに PL/pgSQL のコードを修正するのは大変です。`%TYPE`と`%ROWTYPE`を使うと、テーブル定義に連動する変数を簡単に作成でき、メンテナンス性が向上します。

- **`%TYPE`**: テーブルの**特定の列と同じデータ型**を持つ変数を宣言します。
- **`%ROWTYPE`**: テーブルの**行全体と同じ構造**を持つレコード型変数を宣言します。

**具体例：`%TYPE`で列の型を利用する**
(この例を実行するには、`employees`テーブルが必要です: `CREATE TABLE employees (id serial primary key, name text); INSERT INTO employees (name) VALUES ('Taro Yamada');`)

```sql
CREATE OR REPLACE FUNCTION get_employee_name(p_employee_id integer)
RETURNS text AS $$
DECLARE
    -- employeesテーブルのname列と同じ型を持つ変数を宣言
    v_employee_name employees.name%TYPE;
BEGIN
    SELECT name INTO v_employee_name
    FROM employees
    WHERE id = p_employee_id;

    RETURN v_employee_name;
END;
$$ LANGUAGE plpgsql;
```

このコードは、将来`employees`テーブルの`name`列のデータ型が`text`から`varchar(100)`に変更されても、修正する必要がありません。

**具体例：`%ROWTYPE`で宣言し、フィールドにアクセスする**

```sql
DO $$
DECLARE
    -- employeesテーブルの行全体を表すレコード型変数を宣言
    r_employee employees%ROWTYPE;
BEGIN
    -- レコードの各フィールドに値を代入
    r_employee.id := 101;
    r_employee.name := 'Hanako Suzuki';
    r_employee.salary := 5000000;

    RAISE NOTICE 'ID: %, Name: %, Salary: %', r_employee.id, r_employee.name, r_employee.salary;
END;
$$ LANGUAGE plpgsql;
```

このように`%ROWTYPE`で宣言した変数は、`.`（ドット）でテーブルの各列にアクセスできます。

#### 複合型 (`CREATE TYPE`) と レコード型 (`RECORD`)

複数のデータをひとまとめにして扱いたい場合に便利です。

- **複合型 (Composite Type)**: 事前に`CREATE TYPE`で型（フィールド名とデータ型のセット）を定義しておく必要があります。構造が固定されている場合に適しています。
- **レコード型 (Record Type)**: 型を事前に定義する必要がない、柔軟な複合型です。`SELECT`の結果を一時的に格納する際に、その問い合わせの列構造に応じて**動的に構造が決まります**。

**具体例：複合型 (`CREATE TYPE`) を利用する**

```sql
-- 1. 住所を格納するための複合型を定義（他の関数とかでも使いまわせる）
CREATE TYPE address_type AS (
    postal_code text,
    prefecture  text,
    city        text
);

-- 2. 複合型を変数として利用する
DO $$
DECLARE
    -- address_type型の変数を宣言
    v_office_address address_type;
BEGIN
    -- 各フィールドに値を代入
    v_office_address.postal_code := '100-0001';
    v_office_address.prefecture  := '東京都';
    v_office_address.city        := '千代田区';

    RAISE NOTICE 'City: %', v_office_address.city; -- フィールドにアクセス

    -- ROWコンストラクタを使って一括で代入も可能
    v_office_address := ROW('108-0075', '東京都', '港区');
    RAISE NOTICE 'New City: %', v_office_address.city;
END;
$$ LANGUAGE plpgsql;
```

**具体例：`RECORD`型の基本的な使い方**
```SQL
DECLARE
    r_employee employees%ROWTYPE;
BEGIN
    SELECT * INTO r_employee FROM employees WHERE id = 1;
    RAISE NOTICE '%', r_employee.name;
END;
```

**具体例：`RECORD`型をループで利用する**
`RECORD`型は、特に`FOR ... IN ... LOOP`構文（後の章で詳解）でクエリの結果を一行ずつ処理する際に、事前の型定義なしで使えるため非常に便利です。

```sql
-- employeesテーブルのデータを使ってループ処理
DO $$
DECLARE
    -- recという変数をRECORD型として暗黙的に宣言
    rec RECORD;
BEGIN
    FOR rec IN SELECT id, name FROM employees ORDER BY id
    LOOP
        -- recのフィールドは、SELECTリストの列名に応じて動的に決まる
        RAISE NOTICE 'ID: %, Name: %', rec.id, rec.name;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

##### 使い分け
`%ROWTYPE`も一種のレコード型ですが、PL/pgSQLではより柔軟な`RECORD`型や、事前に定義する複合型（`CREATE TYPE`）も利用できます。これらの使い分けは以下の通りです。

| 型 | 特徴 | 主な用途 |
| :--- | :--- | :--- |
| **`%ROWTYPE`** | **既存のテーブル/ビューの行構造**に束縛される。 | 特定のテーブルの行データをそのまま扱いたい場合。 |
| **複合型 (`CREATE TYPE`)** | **永続的な独自の行構造**を定義する。関数の引数や戻り値、テーブルの列としても利用可能。 | 複数の関数で共通のデータ構造を使い回したい場合。 |
| **`RECORD`** | 構造が**固定されていない**。代入されるまで構造が未定。 | `FOR`ループでのクエリ結果や、動的に変わる`SELECT`リストの結果を一時的に受け取りたい場合。 |

#### 列挙型 (`ENUM`)

`CREATE TYPE ... AS ENUM` を使うと、事前定義された定数のリストの中から値を選択する、独自のデータ型を作成できます。状態管理（例: '保留中', '承認済', '却下'）などに最適です。

**具体例: タスクの状態を管理する ENUM 型**

```sql
-- 1. ENUM型を定義
CREATE TYPE task_status AS ENUM ('pending', 'in_progress', 'completed', 'cancelled');

-- 2. ENUM型を使う関数
DO $$
DECLARE
    v_current_status task_status;
BEGIN
    v_current_status := 'in_progress';
    RAISE NOTICE 'Current task status: %', v_current_status;

    -- 型に定義されていない値を代入しようとするとエラーになる
    -- v_current_status := 'waiting'; -- ERROR: invalid input value for enum task_status
END;
$$ LANGUAGE plpgsql;
```

#### 配列 (`ARRAY`)

同じデータ型の要素の集まりを格納できます。

**具体例：配列をループ処理する**

```sql
DO $$
DECLARE
    -- テキスト型の配列を宣言し、初期化
    v_user_names text[] := ARRAY['Alice', 'Bob', 'Charlie'];
    v_name text;
BEGIN
    RAISE NOTICE 'Third user is: %', v_user_names[3]; -- 配列のインデックスは1から始まる
    RAISE NOTICE 'Array length is: %', array_length(v_user_names, 1); -- 配列の長さを取得

    -- FOREACHを使って配列の各要素をループ処理
    FOREACH v_name IN ARRAY v_user_names
    LOOP
        RAISE NOTICE 'Processing user: %', v_name;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

##### 配列の作成方法と操作

`DECLARE`句で `ARRAY[...]` を使って静的に初期化する以外に、クエリの結果を使って動的に配列を作成することも頻繁に行われます。

**具体例：クエリ結果から配列を作成する**

```sql
DO $$
DECLARE
    -- 1. 特定の1列を配列に格納するための変数 (array_aggを使用)
    v_name_list text[];

    -- 2. 行全体を配列に格納するための変数 (ARRAY(サブクエリ)を使用)
    r_employees employees%ROWTYPE[];

    -- 3. 配列の要素を更新するための変数
    v_tags text[] := ARRAY['SQL', 'PL/pgSQL'];
BEGIN
    -- [array_agg] 複数行の特定列(name)を集約して配列を作成
    SELECT array_agg(name ORDER BY id)
    INTO v_name_list
    FROM employees;
    RAISE NOTICE '従業員名リスト: %', v_name_list;

    -- [ARRAY(サブクエリ)] 複数行の行データ全体をレコードの配列として作成
    SELECT ARRAY(SELECT e FROM employees e ORDER BY e.id)
    INTO r_employees;
    -- レコードの配列から、2番目の要素(従業員)の名前(name)フィールドにアクセス
    RAISE NOTICE '2番目の従業員名: %', r_employees[2].name;

    -- 配列要素の更新
    RAISE NOTICE '更新前のタグ: %', v_tags;
    v_tags[2] := 'PostgreSQL'; -- 2番目の要素を更新
    RAISE NOTICE '更新後のタグ: %', v_tags;
END;
$$ LANGUAGE plpgsql;
```
**実行結果:**
```
NOTICE:  従業員名リスト: {"Taro Yamada","Hanako Suzuki","Jiro Tanaka"}
NOTICE:  2番目の従業員名: Hanako Suzuki
NOTICE:  更新前のタグ: {SQL,"PL/pgSQL"}
NOTICE:  更新後のタグ: {SQL,PostgreSQL}
```
#### JSON/JSONB

現代のアプリケーションで多用される JSON 形式のデータを扱うための強力なデータ型です。特に理由がなければ、インデックスが利用でき効率的な**`JSONB`**を使いましょう。

**具体例：JSONB データから情報を取り出す**

```sql
DO $$
DECLARE
    j_user_info jsonb;
BEGIN
    j_user_info := '{ "id": 123, "name": "David", "is_premium": true, "tags": ["A", "B", "C"] }';

    RAISE NOTICE 'Original JSON: %', j_user_info;

    -- 主要な演算子
    RAISE NOTICE 'Name (text): %', j_user_info ->> 'name'; -- `->>`: textで取得
    RAISE NOTICE 'Tags (jsonb): %', j_user_info -> 'tags'; -- `->`: jsonbで取得
    RAISE NOTICE 'Second tag (text): %', j_user_info -> 'tags' ->> 1; -- 配列要素にアクセス(0-indexed)
    RAISE NOTICE 'Is name key exists?: %', j_user_info ? 'name'; -- `?`: トップレベルのキーが存在するか
END;
$$ LANGUAGE plpgsql;
```

##### JSONBデータの動的な構築

静的な文字列だけでなく、`jsonb_build_object()` や `jsonb_build_array()` といった関数を使い、変数から動的にJSONBデータを作成することもできます。

**具体例：変数から `jsonb_build_object` を使ってJSONBを作成する**

```sql
DO $$
DECLARE
    v_id integer := 123;
    v_name text := 'David';
    v_tags text[] := ARRAY['A', 'B', 'C'];
    j_user_info jsonb;
BEGIN
    -- キーと値のペアを交互に指定して、JSONBオブジェクトを構築する
    j_user_info := jsonb_build_object(
        'id', v_id,
        'name', v_name,
        'is_premium', true,
        'tags', to_jsonb(v_tags) -- 配列型をJSONB配列に変換
    );

    RAISE NOTICE '構築されたJSONB: %', j_user_info;
    RAISE NOTICE '構築されたJSONBから名前を取得: %', j_user_info ->> 'name';
END;
$$ LANGUAGE plpgsql;
```
**実行結果:**
```
NOTICE:  構築されたJSONB: {"id": 123, "name": "David", "tags": ["A", "B", "C"], "is_premium": true}
NOTICE:  構築されたJSONBから名前を取得: David
```


### 3. 代入と式

#### 基本的な代入と式

**代入演算子 (`:=` または `=`)**
変数に値を設定するには、`:=` を使うのが一般的です。`=`も使えますが、SQL の比較演算子と見分けにくくなるため、PL/pgSQL 内では `:=` の使用が推奨されます。

**PL/pgSQL 内での SQL 式の評価**
変数の代入や計算には、数値計算だけでなく、PostgreSQL の組み込み関数なども自由に使用できます。

**具体例：税込み価格を計算する**

```sql
DO $$
DECLARE
    v_price           numeric := 1000;
    c_tax_rate        numeric := 0.1;
    v_price_with_tax  numeric;
    dt_current_time   timestamp;
    v_current_user    text;
BEGIN
    -- 変数と定数を使った計算
    v_price_with_tax := v_price * (1 + c_tax_rate);

    -- SQL関数（now()やcurrent_user）の結果を変数に代入
    dt_current_time := now();
    v_current_user := current_user;

    -- 型変換（キャスト）して表示
    RAISE NOTICE 'Price with tax: %', v_price_with_tax::text;

    RAISE NOTICE 'Current time: %', dt_current_time;
    RAISE NOTICE 'DB User: %', v_current_user;
END;
$$ LANGUAGE plpgsql;
```

#### クエリ結果の代入
##### `RETURNING ... INTO ...` による DML 結果の取得

`INSERT`, `UPDATE`, `DELETE`文を実行した際に、実際に操作対象となった行の情報を取得したい場合があります。その際に `RETURNING`句が非常に役立ちます。

**主な用途**

- `serial`型などで自動採番された ID を取得する。
- 更新後の値を確認する。

**具体例：`INSERT`で自動採番された ID を取得する**

```sql
DO $$
DECLARE
    -- 新しく作成される従業員のIDを格納する変数
    v_new_employee_id employees.id%TYPE;
BEGIN
    -- 新しい従業員を登録し、その際に発行されたIDをRETURNING句で受け取る
    INSERT INTO employees (name, salary)
    VALUES ('Jiro Tanaka', 4500000)
    RETURNING id INTO v_new_employee_id;

    RAISE NOTICE '新しい従業員を登録しました。ID: %', v_new_employee_id;
END;
$$ LANGUAGE plpgsql;
```

**具体例：`UPDATE`で更新後の値を取得する**
```sql
DO $$
DECLARE
    -- 更新後の給与を格納する変数
    v_updated_salary employees.salary%TYPE;
BEGIN
    -- id=2の従業員の給与を5,000,000に更新し、その新しい給与を変数に格納する
    UPDATE employees
    SET salary = 5000000
    WHERE id = 2
    RETURNING salary INTO v_updated_salary;

    RAISE NOTICE 'ID=2の従業員の新しい給与は % です。', v_updated_salary;
END;
$$ LANGUAGE plpgsql;
```
#### 実行情報の取得と結果の破棄
##### `GET DIAGNOSTICS`：実行結果の情報を取得する

直前に実行したSQL文に関する診断情報（メタデータ）を取得するためのコマンドです。最もよく使われるのが、`UPDATE`や`DELETE`文が**何行に影響を与えたか**を取得する`ROW_COUNT`です。

**具体例：`UPDATE`で影響を受けた行数を取得する**
```sql
DO $$
DECLARE
    v_updated_rows integer;
BEGIN
    -- 給与が500万円未満の従業員の給与を10%上げる
    UPDATE employees SET salary = salary * 1.1 WHERE salary < 5000000;

    -- 直前のUPDATE文で何行が更新されたかを変数に格納
    GET DIAGNOSTICS v_updated_rows = ROW_COUNT;

    RAISE NOTICE '%件の従業員の給与情報を更新しました。', v_updated_rows;
END;
$$ LANGUAGE plpgsql;
````

`ROW_COUNT`は、後の章で学ぶ`IF`文と組み合わせて、「もし 1 件も更新されなかったら警告を出す」といった処理を実装する際に不可欠です。

##### `PERFORM`：結果を破棄するクエリの実行

`PERFORM`は、**クエリの結果（戻り値）を必要としない場合**に使用する特殊なコマンドです。これがなぜ必要かを理解するには、PL/pgSQL の重要なルールを知る必要があります。

**【重要】PL/pgSQL における `SELECT` のルール**
PL/pgSQL ブロック内で `SELECT` 文を直接実行する場合、その結果は**必ず**どこかに格納されなければなりません。通常は `SELECT ... INTO ...` 構文を使って変数に格納します。もし `INTO` 句なしで `SELECT` を実行すると、「`query has no destination for result data`」というエラーが発生します。

しかし、関数の中には、データの取得が目的ではなく、**副作用（データの変更、ログの記録、一時停止など）**を目的とするものがあります。これらの関数の結果は不要ですが、`SELECT` を使って呼び出すと上記のエラーが発生してしまいます。

そこで `PERFORM` の出番です。`PERFORM` は、`SELECT` 文を実行し、その**結果セットをすべて破棄**します。これにより、エラーを回避しつつ、関数の副作用だけを安全に実行できます。

**`PERFORM` の主な用途**

1.  **戻り値が不要な関数を呼び出す**
    `pg_sleep()` のようなシステム関数や、`INSERT` を内部で行う自作関数など、戻り値自体には関心がない場合に利用します。

2.  **トリガー関数内での存在チェック**
    トリガー内で「特定の条件を満たすレコードが存在するかどうか」だけを確認し、その内容自体は不要な場合などに使われます。

**具体例：`PERFORM` の必要性を理解する**

```sql
DO $$
BEGIN
    -- 【エラーになる例】
    -- SELECT now(); -- ERROR: query has no destination for result data
    -- now()は値を返すが、その値を格納する INTO句 がないためエラーになる。

    -- 【正しい例】
    -- now() の結果は不要で、単に実行したい（または副作用が目的の関数を呼びたい）場合
    PERFORM now();
    RAISE NOTICE 'The PERFORM statement executed successfully.';

    -- データ変更言語（DML）は PERFORM がなくても直接実行可能
    -- INSERT, UPDATE, DELETE は値を返さないため、そのまま記述できる
    -- CREATE TABLE IF NOT EXISTS logs (message text, created_at timestamptz);
    -- INSERT INTO logs (message, created_at) VALUES ('PERFORM test', now());

END;
$$ LANGUAGE plpgsql;
```

このように、`PERFORM`は「値を返すけれども、その値は要らない」という状況で、PL/pgSQL の構文ルールを守るために不可欠なコマンドです。主に `SELECT` 文に対して使われ、`INSERT` や `UPDATE` などには通常不要です。


### 4. 発展：複数行の結果セットを扱うテクニック

これまでの説明で、`%ROWTYPE`や`RECORD`といったレコード型変数が**一度に1行分のデータしか格納できない**こと、そして`SELECT ... INTO`構文が厳密に1行の結果を要求することを学びました。

では、クエリが複数の行を返す場合、PL/pgSQL内ではどのように扱えばよいのでしょうか。ここでは、そのための代表的な4つのテクニックを紹介します。

このセクションの例を実行するには、事前に`employees`テーブルに複数行のデータが必要です: 
```SQL
CREATE TABLE employees (id serial primary key, name text, salary integer); 
INSERT INTO employees (name, salary) VALUES ('Taro Yamada', 6000000), ('Hanako Suzuki', 4800000), ('Jiro Tanaka', 4500000);
```


#### 方法1: ループによる逐次処理 (基本)

最も一般的でメモリ効率が良い方法です。クエリの結果セットをカーソルのように1行ずつループで処理します。一度に1行分のデータしかメモリに読み込まないため、数百万行といった大量のデータを扱う場合でも安定して動作します。`FOR ... IN`構文を使うのが最もシンプルです。

**具体例：`FOR ... IN`ループで給与500万未満の従業員を処理する**

```sql
DO $$
DECLARE
    -- ループ内で使用されるレコード変数は暗黙的に宣言されるため、事前の宣言は不要
    rec RECORD;
BEGIN
    RAISE NOTICE '給与が500万円未満の従業員:';
    FOR rec IN SELECT id, name, salary FROM employees WHERE salary < 5000000 ORDER BY id
    LOOP
        -- ループの各回で、rec変数には現在の行のデータが格納される
        RAISE NOTICE '  ID: %, Name: %, Salary: %', rec.id, rec.name, rec.salary;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

#### 方法2: 配列 (`ARRAY`) への一括格納

クエリの結果セット全体をメモリ上の配列変数に一括で格納する方法です。データ量が比較的少ないことが分かっており、後からインデックス（例: `array[3]`）を指定して特定のデータにランダムアクセスしたい場合に便利です。

クエリ結果から配列を作成するには、主に2つの方法があり、**「何を配列にしたいか」**で使い分けます。

1.  **`array_agg(column_name)`**: **複数行の「特定の一列」**を配列にしたい場合
    集約関数の一種で、複数行にわたる**特定の1列の値**だけをまとめて1つの配列にします。例えば、「全従業員の名前リスト」や「全商品のIDリスト」といった用途に適しています。

2.  **`ARRAY(SELECT ...)`**: **複数行の「行全体（レコード）」**を配列にしたい場合
    配列コンストラクタの一種で、サブクエリの結果を配列に変換します。サブクエリは単一の列を返す必要がありますが、その列のデータ型が `employees` のような**レコード型（行全体）**であっても構いません。

**具体例1：`array_agg`で「名前のリスト」を配列に格納する**

```sql
DO $$
DECLARE
    v_employee_names text[];
BEGIN
    -- employeesテーブルからname列だけを集約して配列にする
    SELECT array_agg(name ORDER BY id)
    INTO v_employee_names
    FROM employees;

    RAISE NOTICE '従業員リスト: %', v_employee_names;
    RAISE NOTICE '2番目の従業員: %', v_employee_names[2];
END;
$$ LANGUAGE plpgsql;
```

**具体例2：`ARRAY(SELECT ...)`で「従業員レコードのリスト」を配列に格納する**

```sql
DO $$
DECLARE
    r_employees employees%ROWTYPE[];
BEGIN
    -- employeesテーブルの行全体(e)を要素とする配列を作成
    SELECT ARRAY(SELECT e FROM employees e ORDER BY e.id)
    INTO r_employees;

    RAISE NOTICE '全従業員のデータ: %', r_employees;
    -- 配列の2番目の要素(レコード)から、salaryフィールドの値を取得
    RAISE NOTICE '2番目の従業員の給与: %', r_employees[2].salary;
END;
$$ LANGUAGE plpgsql;
```

#### 方法3: JSON/JSONB への集約

複数行の結果を、単一の`JSON`または`JSONB`の配列として変数に格納する方法です。特に、関数の戻り値として階層構造を持つ複雑なデータセットを返却したい場合や、Web APIとの連携でJSON形式が求められる場合に非常に強力です。

**具体例：`jsonb_agg` を使って複数行を単一のJSONB配列にする**

```sql
DO $$
DECLARE
    j_employees jsonb;
BEGIN
    -- employeesテーブルの各行をjsonオブジェクトに変換し、それをjsonb配列に集約する
    SELECT jsonb_agg(emp ORDER BY id)
    INTO j_employees
    FROM (SELECT id, name, salary FROM employees) AS emp;

    RAISE NOTICE '従業員データ (JSONB): %', j_employees;
    -- 最初の従業員の名前をJSONB演算子で取り出す
    RAISE NOTICE '最初の従業員の名前: %', j_employees -> 0 ->> 'name'; -- JSON配列のインデックスは0から
END;
$$ LANGUAGE plpgsql;
```

#### 方法4: 一時テーブルの利用 (高度な処理)

処理が複数ステップに及ぶ複雑なロジックや、中間結果を保持して別のクエリから参照したい場合に有効な方法です。`CREATE TEMP TABLE`で作成されたテーブルは、そのデータベースセッション内でのみ有効で、セッションが終了すると自動的に破棄されるため、後片付けの心配がありません。

**具体例：一時テーブルに結果を格納し、後続の処理で利用する**

```sql
DO $$
BEGIN
    -- 1. 処理対象のデータを格納するための一時テーブルを作成
    CREATE TEMP TABLE tmp_high_earners (
        id integer,
        name text,
        bonus numeric
    );

    -- 2. クエリの結果を一時テーブルにINSERT
    INSERT INTO tmp_high_earners (id, name, bonus)
    SELECT id, name, salary * 0.1
    FROM employees
    WHERE salary >= 5000000;

    -- 3. 一時テーブルを使ってさらに処理を行う (ここでは件数を表示)
    DECLARE
        v_count integer;
    BEGIN
        SELECT count(*) INTO v_count FROM tmp_high_earners;
        RAISE NOTICE 'ボーナス対象者は % 名です。', v_count;
    END;

    -- この後も、このDOブロック（トランザクション）が終了するまで
    -- tmp_high_earnersテーブルは他のクエリから参照できる
END;
$$ LANGUAGE plpgsql;
```

#### どの方法を選ぶべきか？

| 方法 | メリット | デメリット/注意点 | 主な用途 |
| :--- | :--- | :--- | :--- |
| **ループ** | **メモリ効率が非常に良い**。シンプルで直感的。 | 結果全体を一度に保持できない。 | ほとんどの逐次処理。**特にデータ量が多い場合**の第一選択肢。 |
| **配列** | 全データをメモリ上で保持。インデックスで**高速なランダムアクセス**が可能。 | **メモリ消費量が大きい**。大量データには不向き。 | データ量が少ないことが保証され、後でランダムアクセスが必要な場合。 |
| **JSON/JSONB** | **複雑な階層構造**を表現可能。Web APIとの親和性が高い。 | メモリ消費量が大きい。操作に専用の関数/演算子が必要。 | 構造化されたデータをまとめて返却したい関数。外部システム連携。 |
| **一時テーブル** | **大量データに最適**。SQLで柔軟に操作できる。トランザクショナル。 | コードがやや冗長になる。ディスクI/Oが発生する可能性がある。 | 複数ステップに渡る**複雑なデータ処理**。中間結果の保存。 |