### V. エラーハンドリングとデバッグ (Error Handling and Debugging)

この単元では、プログラム実行中に予期せぬ事態が発生した際に、どのように対処するかを学びます。意図的にエラーを発生させる方法、発生したエラーを捕捉して処理を続ける方法、そして開発中にコードの問題点を見つけ出すためのテクニックを習得します。

#### 1. エラーとメッセージの通知 (`RAISE`)

`RAISE`ステートメントは、メッセージ、警告、あるいは処理を中断させるためのエラーを意図的に発生させるコマンドです。

##### `RAISE`のレベル

*   `NOTICE`: ユーザーに情報を通知します。処理は中断されません。（デバッグで多用）
*   `WARNING`: 警告メッセージを通知します。処理は中断されません。
*   `EXCEPTION`: **エラーを発生させ、現在のトランザクションを中断・ロールバックします。**

##### `RAISE`の基本的な使い方
`RAISE level 'メッセージフォーマット', 変数...;`

**具体例：`RAISE NOTICE` でデバッグメッセージを表示する**
```sql
DO $$
DECLARE
    user_id integer := 123;
BEGIN
    RAISE NOTICE 'Processing start for user_id: %', user_id;
    -- ... 処理 ...
    RAISE NOTICE 'Processing finished.';
END;
$$ LANGUAGE plpgsql;
```

##### `USING`句：エラーへの詳細情報の追加
`RAISE EXCEPTION` に `USING` 句を追加することで、エラーメッセージに加えて、より構造化された情報を付加できます。これは、アプリケーション側でエラー内容を機械的に処理したい場合に非常に有効です。

*   `DETAIL`: エラーに関するより詳細な情報。
*   `HINT`: エラーの解決策に関するヒント。
*   `ERRCODE`: SQLSTATEエラーコードを指定します。`P0001` (`raise_exception`) や、`P`で始まるカスタムコードなどが使えます。

**具体例：残高不足エラーに詳細情報を付加する**
```sql
CREATE OR REPLACE PROCEDURE withdraw_money(p_id int, amount numeric) AS $$
DECLARE
    current_balance numeric;
BEGIN
    SELECT balance INTO STRICT current_balance FROM accounts WHERE id = p_id;

    IF current_balance < amount THEN
        RAISE EXCEPTION 'Insufficient funds for account %', p_id
            USING
                DETAIL = format('Attempted to withdraw % but only % is available.', amount, current_balance),
                HINT = 'Check the account balance or reduce the withdrawal amount.',
                ERRCODE = 'P0002'; -- カスタムエラーコード 'InsufficientFunds'
    END IF;

    UPDATE accounts SET balance = balance - amount WHERE id = p_id;
END;
$$ LANGUAGE plpgsql;
```
このようにすると、エラーを受け取ったアプリケーションは、エラーコード`P0002`を識別して特別な処理を行う、といった実装が可能になります。

#### 2. 例外処理 (`EXCEPTION`)

`BEGIN ... EXCEPTION ... END` ブロックを使うことで、エラーを捕捉し、代替処理を行うことができます。

##### 特定の例外を捕捉する
`no_data_found` や `unique_violation` のように、PostgreSQLが定義した条件名を指定して、特定のエラーのみを捕捉できます。

**具体例：`SELECT INTO`でデータが見つからないエラーを捕捉する**
```sql
DO $$
DECLARE
    emp_name text;
BEGIN
    -- STRICT を付けると結果が0行の場合に no_data_found エラーが発生する
    SELECT name INTO STRICT emp_name FROM employees WHERE id = 999;
EXCEPTION
    WHEN no_data_found THEN
        RAISE NOTICE 'Employee with ID 999 not found.';
        emp_name := 'Unknown';
END;
$$;
```

##### `SELECT INTO` と `STRICT` オプション
`SELECT INTO`文には`STRICT`というオプションがあり、これを使うかどうかで結果が0行だった場合の挙動が変わります。堅牢なコードのためには `STRICT` の使用が強く推奨されます。

*   **`STRICT`なし (デフォルト)**
    *   結果が**0行**: エラーにならず、代入先の変数は**`NULL`**になります。
    *   結果が1行: 変数に値が代入されます。
    *   結果が2行以上: `too_many_rows`エラーが発生します。⇒なんかエラーにならなかったかも。
*   **`STRICT`あり**
    *   結果が**0行**: **`no_data_found`エラーが発生します。**
    *   結果が1行: 変数に値が代入されます。
    *   結果が2行以上: `too_many_rows`エラーが発生します。

`STRICT`なしの場合、結果が0行でも処理が続行され、変数が`NULL`のまま後続の処理で使われることで、予期せぬ不具合（NULLポインタエラーなど）の原因となり得ます。「データが存在しない」という状態をエラーとして明確に検知できるため、`STRICT`を付けて`EXCEPTION`ブロックで捕捉するのが安全な書き方です。

**具体例：`STRICT`の有無による挙動の違い**
```sql
DO $$
DECLARE
    emp_name text;
BEGIN
    -- STRICTなし: 存在しないIDで検索。emp_nameはNULLになるがエラーは起きない
    SELECT name INTO emp_name FROM employees WHERE id = 999;
    RAISE NOTICE 'Without STRICT, emp_name is: %', emp_name; -- "emp_name is: NULL" と表示される

    -- STRICTあり: ここで no_data_found エラーが発生し、EXCEPTIONブロックに飛ぶ
    SELECT name INTO STRICT emp_name FROM employees WHERE id = 999;
    RAISE NOTICE 'This message will not be displayed.';
EXCEPTION
    WHEN no_data_found THEN
        RAISE NOTICE 'With STRICT, caught no_data_found error as expected.';
END;
$$;
```


##### あらゆるエラーを捕捉する (`WHEN OTHERS`)
`WHEN OTHERS` は、指定されなかった他のすべてのエラーを捕捉します。エラーの原因を問わず、何らかのクリーンアップ処理（ログ記録など）を行いたい場合に便利です。

**`SQLSTATE` と `SQLERRM`**
`EXCEPTION`ブロックの中では、特殊変数 `SQLSTATE` (エラーコード) と `SQLERRM` (エラーメッセージ) を使ってエラーの詳細を取得できます。

**具体例：発生したエラーの詳細をログに記録する**
```sql
DO $$
BEGIN
    PERFORM 1 / 0; -- ゼロ除算エラーを発生させる
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING 'An error occurred. SQLSTATE: %, SQLERRM: %', SQLSTATE, SQLERRM;
        -- ここでログテーブルにエラー情報をINSERTするなどの処理を行う
END;
$$;
```

##### エラーの再スロー (`RAISE`)
エラーを捕捉してログ記録などの処理を行った後、**呼び出し元にもエラーが発生したことを伝えたい**場合があります。その場合、`EXCEPTION`ブロック内で引数なしの `RAISE` を実行すると、捕捉したのと同じエラーを再度発生させることができます。

**具体例：エラーをログに記録してから再スローする**
```sql
CREATE OR REPLACE PROCEDURE safe_update(...) AS $$
BEGIN
    -- ... 何らかの更新処理 ...
EXCEPTION
    WHEN OTHERS THEN
        -- まずエラー情報をログに記録
        INSERT INTO execution_log (log_message)
        VALUES ('Update failed. SQLSTATE: ' || SQLSTATE || ' - SQLERRM: ' || SQLERRM);

        -- 処理を中断させるため、捕捉したエラーをそのまま呼び出し元に伝える
        RAISE;
END;
$$ LANGUAGE plpgsql;
```
このパターンにより、エラーを見過ごすことなく、確実なログ記録と正常なエラー伝達を両立できます。

##### 例外発生時のトランザクションとロールバック
PL/pgSQLにおけるエラーハンドリングを理解する上で、トランザクションがどのように扱われるかを知ることは極めて重要です。

**基本原則:**
*   **`BEGIN ... EXCEPTION ... END`ブロックは「サブトランザクション」を形成します。**
*   ブロック内で**捕捉されなかったエラー**は、外側のブロックへと伝播し、最終的にどの`EXCEPTION`句でも捕捉されなければ、**トランザクション全体がロールバック**されます。
*   `EXCEPTION`句で**捕捉されたエラー**は、そのサブトランザクション（つまり、その`BEGIN...END`ブロック内で行われた変更）**のみをロールバック**し、処理は`EXCEPTION`ブロックの終了後から続行されます。

**シナリオ1：内側のブロックでエラーを捕捉する（サブトランザクションのみロールバック）**
内側の`BEGIN...END`ブロックで発生したエラーを、そのブロック自身の`EXCEPTION`句で捕捉するケースです。

```SQL
-- 実行前の状態: accounts id=1 balance=1000, id=2 balance=500
DO $$
BEGIN
    -- 1. 主トランザクションでの変更
    UPDATE accounts SET balance = 1100 WHERE id = 1;
    RAISE NOTICE 'Main transaction: Updated account 1.';

    -- 2. サブトランザクション開始
    BEGIN
        RAISE NOTICE '  Sub-transaction: Started.';
        -- この変更は後でロールバックされる
        UPDATE accounts SET balance = 600 WHERE id = 2;
        -- わざとエラーを発生させる
        PERFORM 1 / 0;
    EXCEPTION
        WHEN division_by_zero THEN
            -- 3. 内側のEXCEPTIONでエラーを捕捉
            RAISE NOTICE '  Sub-transaction: Caught error. Rolling back sub-transaction.';
    END;
    -- 4. サブトランザクション終了。主トランザクションの処理は続行される
    RAISE NOTICE 'Main transaction: Resumed after exception.';
END;
$$;

-- 実行後の確認
SELECT * FROM accounts ORDER BY id;
-- 結果: id=1のbalanceは1100に更新されているが、id=2のbalanceは500のまま。
--       サブトランザクション内の変更だけが取り消されたことがわかる。
```

**シナリオ2：外側のブロックでエラーを捕捉する（より広範囲のロールバック）**
内側のブロックで発生したエラーが、そこでは捕捉されずに外側のブロックの`EXCEPTION`句で捕捉されるケースです。

```SQL
-- 実行前の状態: accounts id=1 balance=1000, id=2 balance=500
DO $$
BEGIN -- 外側のブロック
    -- 1. この変更は、最終的に外側ブロック全体がロールバックされるため、残らない
    UPDATE accounts SET balance = 1100 WHERE id = 1;
    RAISE NOTICE 'Outer block: Updated account 1.';

    BEGIN -- 内側のブロック (EXCEPTION句なし)
        RAISE NOTICE '  Inner block: Started.';
        -- 2. エラー発生
        PERFORM 1 / 0;
    END;
    RAISE NOTICE 'This message will not be displayed.';
EXCEPTION
    WHEN division_by_zero THEN
        -- 3. 外側のEXCEPTIONでエラーを捕捉
        RAISE NOTICE 'Outer block: Caught error from inner block. Rolling back outer block.';
END; -- 外側のブロック終了
$$;

-- 実行後の確認
SELECT * FROM accounts ORDER BY id;
-- 結果: id=1もid=2も元の残高(1000, 500)のまま。
--       エラーが外側で捕捉されたため、外側のBEGIN以降の全ての変更がロールバックされた。
```

この挙動を理解することで、「一部の処理の失敗は許容して処理を続けたい」のか、「何か一つでも失敗したら全てを無かったことにしたい」のかに応じて、`EXCEPTION`ブロックを適切に配置することができます。

---
#### 3. デバッグ手法

##### `RAISE NOTICE` を利用した「printfデバッグ」
最も手軽で基本的なデバッグ手法です。処理の要所要所で`RAISE NOTICE`を使い、変数の値やプログラムがどのルートを通ったかを確認します。

##### `ASSERT` 文による条件チェック
`ASSERT`は、「この条件は絶対に真であるはずだ」という表明を行うための文で、開発中の前提条件チェックに役立ちます。条件が偽であった場合、エラーを発生させます。
（注意: `plpgsql.check_asserts = on` の設定が必要です）

**具体例：関数の引数が正の数であることを表明する**
```sql
-- このセッションでASSERTを有効にする
SET plpgsql.check_asserts = on;

CREATE OR REPLACE FUNCTION calculate_square_root(num numeric) RETURNS numeric AS $$
BEGIN
    ASSERT num >= 0, 'Input for square root must be non-negative.';
    RETURN sqrt(num);
END;
$$ LANGUAGE plpgsql;

-- 実行
SELECT calculate_square_root(-1); -- ASSERTが失敗し、エラーになる
```

##### 高度なデバッグ：`pldebugger`拡張機能
`RAISE NOTICE`でのデバッグが複雑になってきた場合、より高度なツールを検討できます。
**`pldebugger`** は、PostgreSQLの公式拡張機能で、PL/pgSQLに関数対する対話的なデバッグ機能を提供します。

*   **ブレークポイント**: コードの特定の行で実行を一時停止できます。
*   **ステップ実行**: 1行ずつコードを実行できます (`Step Over`, `Step Into`)。
*   **変数確認**: 現在のスコープにある変数の値をリアルタイムで確認・変更できます。

`pldebugger`は pgAdmin などのGUIツールと統合されており、よりモダンなデバッグ体験を提供します。利用するにはサーバー側でのセットアップが必要ですが、複雑なビジネスロジックのデバッグ効率を劇的に向上させます。