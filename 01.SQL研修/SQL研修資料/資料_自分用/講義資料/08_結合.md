# JOINによる複数テーブルの結合

## 1. なぜテーブルを結合するのか？

データベースでは、データの重複をなくし、一貫性を保つために、関連するデータを複数のテーブルに分割して管理します（これを**正規化**と呼びます）。

例えば、「学生」と「部活」の情報を一つの巨大なテーブルで管理すると、部活名を変更する際に、その部活に属するすべての学生のデータを一つずつ修正する必要があり、更新漏れやデータ不整合の原因となります。

正規化によってテーブルを分割することで、データの管理は効率的になりますが、分析やレポート作成の際には、これらの分割されたテーブルを一時的に一つにまとめて情報を引き出す必要があります。

この「複数のテーブルを関連付けて一つの結果セットにする」操作が**JOIN**（**結合**）です。JOINは、SQLを扱う上で最も重要かつ強力な機能の一つです。

## 2. JOINの種類と概要

JOINにはいくつかの種類があり、どのデータを基準に、どのようにテーブルを結合するかによって使い分けます。

| JOINの種類 | 説明 | 実務での重要度 |
| :--- | :--- | :--- |
| **INNER JOIN** | **内部結合**：両方のテーブルに共通して存在するデータのみを結合します。 | **非常に高** |
| **LEFT JOIN** | **左外部結合**：左側のテーブルのデータをすべて保持し、右側のテーブルから一致するデータを結合します。一致しない場合はNULLになります。 | **非常に高** |
| （**RIGHT JOIN**） | **右外部結合**：右側のテーブルのデータをすべて保持し、左側のテーブルから一致するデータを結合します。LEFT JOINの逆ですが、実務ではLEFT JOINが主に使われます。 | **低** |
| （**FULL OUTER JOIN**） | **完全外部結合**：両方のテーブルのデータをすべて保持し、一致しない部分はNULLで補います。 | **中** |
| （**CROSS JOIN**） | **交差結合**：両方のテーブルのすべての行の組み合わせ（総当たり）を作成します。 | **低** |
| （**SELF JOIN**） | **自己結合**：同じテーブルを別名で扱い、自分自身と結合します。**特にself joinというキーワードを使った構文があるわけではないです。単に同じテーブルを結合するだけです。** | **中** |

---

### サンプルデータ
以降の説明では、主に以下の2つのテーブルを使用します。

**students テーブル** (`s`):

| student_id | student_name | club_id |
| :--- | :--- | :--- |
| 1 | 田中 | 1 |
| 2 | 鈴木 | 1 |
| 3 | 佐藤 | 2 |
| 4 | 高橋 | `NULL` |
| 5 | 伊藤 | 2 |

**clubs テーブル** (`c`):

| club_id | club_name |
| :--- | :--- |
| 1 | 野球部 |
| 2 | サッカー部 |
| 3 | テニス部 |

---

## 3. INNER JOIN (内部結合)

`INNER JOIN`は、**両方のテーブルで結合条件に一致する行のみ**を返します。最も基本で、最も頻繁に使用される結合です。

#### 基本構文
```sql
SELECT 列リスト
FROM テーブル1 AS t1
INNER JOIN テーブル2 AS t2 ON t1.共通列 = t2.共通列;
```

#### 例：部活に所属している学生とその部活名を取得する
```sql
WITH students (student_id, student_name, club_id) AS (
    VALUES
        (1, '田中', 1),
        (2, '鈴木', 1),
        (3, '佐藤', 2),
        (4, '高橋', NULL),
        (5, '伊藤', 2)
),
clubs (club_id, club_name) AS (
    VALUES
        (1, '野球部'),
        (2, 'サッカー部'),
        (3, 'テニス部')
)
SELECT
    s.student_name,
    c.club_name
FROM
    students AS s
INNER JOIN
    clubs AS c ON s.club_id = c.club_id;
```

**実行結果：**
`students.club_id`と`clubs.club_id`が一致する行だけが結果として返されます。部活に未所属の`高橋`（club_idがNULL）や、部員が誰もいない`テニス部`は結果に含まれません。

| student_name | club_name |
| :--- | :--- |
| 田中 | 野球部 |
| 鈴木 | 野球部 |
| 佐藤 | サッカー部 |
| 伊藤 | サッカー部 |

## 4. OUTER JOIN (外部結合)

`OUTER JOIN`は、片方または両方のテーブルの行をすべて保持し、一致する行がない場合は`NULL`で補って結果を返します。

### 4.1. LEFT JOIN (左外部結合)

`LEFT JOIN`は、**左側（`FROM`句で指定したテーブル）の行をすべて**返します。右側のテーブルに一致する行がない場合は、その列は`NULL`になります。

#### 基本構文
```sql
SELECT 列リスト
FROM テーブル1 AS t1 -- 左側のテーブル
LEFT JOIN テーブル2 AS t2 ON t1.共通列 = t2.共通列;
```

#### 例：すべての学生と、所属している部活名を取得する
部活に所属していない学生（`高橋`）も含めて一覧表示したい場合に使用します。
```sql
WITH students (student_id, student_name, club_id) AS (
    VALUES
        (1, '田中', 1),
        (2, '鈴木', 1),
        (3, '佐藤', 2),
        (4, '高橋', NULL),
        (5, '伊藤', 2)
),
clubs (club_id, club_name) AS (
    VALUES
        (1, '野球部'),
        (2, 'サッカー部'),
        (3, 'テニス部')
)
SELECT
    s.student_name,
    c.club_name
FROM
    students AS s
LEFT JOIN
    clubs AS c ON s.club_id = c.club_id;
```

**実行結果：**
左側の`students`テーブルの行はすべて表示されます。`高橋`は`clubs`テーブルに一致する`club_id`がないため、`club_name`が`NULL`になります。

| student_name | club_name |
| :--- | :--- |
| 田中 | 野球部 |
| 鈴木 | 野球部 |
| 佐藤 | サッカー部 |
| **高橋** | `NULL` |
| 伊藤 | サッカー部 |

### 4.2. RIGHT JOIN (右外部結合)

`RIGHT JOIN`は`LEFT JOIN`の逆で、**右側（`JOIN`句で指定したテーブル）の行をすべて**返します。実務では、テーブルの記述順序を入れ替えて`LEFT JOIN`で書くことが一般的なため、使用頻度は低いです。

### 4.3. FULL OUTER JOIN (完全外部結合)

`FULL OUTER JOIN`は、**両方のテーブルのすべての行**を返します。結合条件に一致しない行は、対応するテーブルの列が`NULL`になります。

#### 例：すべての学生とすべての部活を結合する
部員が一人もいない部活（`テニス部`）も、部活に所属していない学生（`高橋`）も、両方表示したい場合に使用します。
```sql
WITH students (student_id, student_name, club_id) AS (
    VALUES
        (1, '田中', 1),
        (2, '鈴木', 1),
        (3, '佐藤', 2),
        (4, '高橋', NULL),
        (5, '伊藤', 2)
),
clubs (club_id, club_name) AS (
    VALUES
        (1, '野球部'),
        (2, 'サッカー部'),
        (3, 'テニス部')
)
SELECT
    s.student_name,
    c.club_name
FROM
    students AS s
FULL OUTER JOIN
    clubs AS c ON s.club_id = c.club_id;
```

**実行結果：**

| student_name | club_name |
| :--- | :--- |
| 田中 | 野球部 |
| 鈴木 | 野球部 |
| 佐藤 | サッカー部 |
| 伊藤 | サッカー部 |
| **高橋** | `NULL` |
| `NULL` | **テニス部** |

#### 💡コラム: MySQLでFULL OUTER JOINを再現する方法
MySQLなど一部のデータベースは`FULL OUTER JOIN`を直接サポートしていません。その場合、`LEFT JOIN`と`RIGHT JOIN`の結果を`UNION`で組み合わせることで同じ結果を得られます。

```sql
WITH students (student_id, student_name, club_id) AS (
    VALUES
        (1, '田中', 1),
        (2, '鈴木', 1),
        (3, '佐藤', 2),
        (4, '高橋', NULL),
        (5, '伊藤', 2)
),
clubs (club_id, club_name) AS (
    VALUES
        (1, '野球部'),
        (2, 'サッカー部'),
        (3, 'テニス部')
)
SELECT s.student_name, c.club_name
FROM students AS s
LEFT JOIN clubs AS c ON s.club_id = c.club_id
UNION
SELECT s.student_name, c.club_name
FROM students AS s
RIGHT JOIN clubs AS c ON s.club_id = c.club_id;
```

## 5. その他の結合

### 5.1. CROSS JOIN (交差結合)

`CROSS JOIN`は、2つのテーブルのすべての行の組み合わせ（デカルト積）を返します。結合条件は指定しません。巨大なテストデータを作成する際などに稀に使われますが、意図せず実行すると膨大な結果が返るため注意が必要です。

### 5.2. SELF JOIN (自己結合)

`SELF JOIN`は、同じテーブルを2つ（異なる別名で）扱い、自分自身と結合します。テーブル内の行同士の関係性を表現したい場合（例：従業員と上司、親子カテゴリなど）に有効です。

#### 例：従業員とその上司の名前を取得する
`employees`テーブルに、従業員ID(`employee_id`)と上司のID(`manager_id`)が同じテーブル内にあるとします。

**employees テーブル:**

| employee_id | employee_name | manager_id |
| :--- | :--- | :--- |
| 1 | Alice | `NULL` |
| 2 | Bob | 1 |
| 3 | Charlie | 1 |
| 4 | David | 2 |

**SQL:**
```sql
WITH employees (employee_id, employee_name, manager_id) AS (
    VALUES
        (1, 'Alice', NULL),
        (2, 'Bob', 1),
        (3, 'Charlie', 1),
        (4, 'David', 2)
)
SELECT
    e.employee_name AS employee, -- 従業員
    m.employee_name AS manager   -- 上司
FROM
    employees AS e
LEFT JOIN -- 上司がいない従業員(Alice)も表示するためLEFT JOINを使用
    employees AS m ON e.manager_id = m.employee_id;
```

**実行結果：**

| employee | manager |
| :--- | :--- |
| Alice | `NULL` |
| Bob | Alice |
| Charlie | Alice |
| David | Bob |


## 6. JOINの応用と注意点

### 6.1. ON句とWHERE句の決定的な違い

`ON`句と`WHERE`句はどちらも条件を指定しますが、処理されるタイミングが異なり、特に`OUTER JOIN`**では結果が大きく変わります。**

- **ON句**: **テーブルを結合する際の条件**を定義します。結合前に評価されます。
- **WHERE句**: **結合が完了した後の結果セット全体**に対してフィルタリングを行います。

#### 例：LEFT JOINでの違い
**シナリオ**: 「野球部(club_id = 1)の学生」と、「部活に所属していないすべての学生」を表示したい。

**1. ON句で条件を指定した場合（期待通りの結果）**
`LEFT JOIN`の結合条件に`c.club_id = 1`を追加します。

```sql
WITH students (student_id, student_name, club_id) AS (
    VALUES
        (1, '田中', 1),
        (2, '鈴木', 1),
        (3, '佐藤', 2),
        (4, '高橋', NULL),
        (5, '伊藤', 2)
),
clubs (club_id, club_name) AS (
    VALUES
        (1, '野球部'),
        (2, 'サッカー部'),
        (3, 'テニス部')
)
SELECT s.student_name, c.club_name
FROM students AS s
LEFT JOIN clubs AS c ON s.club_id = c.club_id
                     AND c.club_id = 1; -- ON句に条件を追加
```
**実行ロジック:**
1. 左側の`students`テーブルはすべて保持する。
2. 右側の`clubs`テーブルから`club_id = 1`の行だけを結合対象とする。
3. `students`側の行に対して条件を満たす`clubs`の行がなければ`NULL`で埋める。

**実行結果：**
`佐藤`や`伊藤`（サッカー部）、`高橋`（無所属）は`ON`句の条件を満たさないため`club_name`は`NULL`になりますが、`students`テーブルの行自体は残ります。

| student_name | club_name |
| :--- | :--- |
| 田中 | 野球部 |
| 鈴木 | 野球部 |
| **佐藤** | **`NULL`** |
| **高橋** | **`NULL`** |
| **伊藤** | **`NULL`** |

**2. WHERE句で条件を指定した場合（意図しない結果になりやすい）**
結合が完了した後に`c.club_id = 1`でフィルタリングします。

```sql
WITH students (student_id, student_name, club_id) AS (
    VALUES
        (1, '田中', 1),
        (2, '鈴木', 1),
        (3, '佐藤', 2),
        (4, '高橋', NULL),
        (5, '伊藤', 2)
),
clubs (club_id, club_name) AS (
    VALUES
        (1, '野球部'),
        (2, 'サッカー部'),
        (3, 'テニス部')
)
SELECT s.student_name, c.club_name
FROM students AS s
LEFT JOIN clubs AS c ON s.club_id = c.club_id
WHERE c.club_id = 1; -- WHERE句で絞り込み
```
**実行ロジック:**
1. まず`LEFT JOIN`が実行され、部活に紐づかない学生は`c.club_id`が`NULL`の行が作られる。
2. その後、`WHERE`句で`c.club_id = 1`の行だけを絞り込む。
3. `c.club_id`が`1`でない行や`NULL`の行はすべて除外される。

**実行結果：**
`WHERE`句によって、`c.club_id`が`1`でない行（`佐藤`, `伊藤`）や`NULL`の行（`高橋`）がすべて削除され、結果的に**`INNER JOIN`と同じ**になってしまいます。

| student_name | club_name |
| :--- | :--- |
| 田中 | 野球部 |
| 鈴木 | 野球部 |

> **ポイント**: `OUTER JOIN`で結合先のテーブルを絞り込みたい場合は、`ON`句に条件を記述する。`WHERE`句は、最終的な結果全体から行を絞り込みたい場合に使用します。

### 6.2. （参考）結合キーの簡潔な指定：USING句

結合するテーブル間で、結合キーとなる列名が**全く同じ場合**に`ON`句の代わりに`USING`句を使うと、より簡潔に記述できます。

```sql
WITH students (student_id, student_name, club_id) AS (
    VALUES
        (1, '田中', 1),
        (2, '鈴木', 1),
        (3, '佐藤', 2),
        (4, '高橋', NULL),
        (5, '伊藤', 2)
),
clubs (club_id, club_name) AS (
    VALUES
        (1, '野球部'),
        (2, 'サッカー部'),
        (3, 'テニス部')
)
-- ON句を使用した場合
SELECT s.student_name, c.club_name
FROM students AS s
INNER JOIN clubs AS c ON s.club_id = c.club_id;

-- USING句を使用した場合
-- WITH句は上記と同じなので省略
SELECT student_name, club_name
FROM students
INNER JOIN clubs USING (club_id);
```
USING(列名)`で指定した列は、結果セットの中では一つにまとめられるため、`s.club_id`のようにテーブル名を修飾する必要がなくなります。
ただし、USINGは一部RDBMSでは使えないのと、複雑な結合条件を書くことができません。（等価演算子以外での結合や、結合する列名が同名でない場合や、結合条件を複数書きたい場合）