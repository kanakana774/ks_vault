## SQL・データベース用語集

### 第1単元：データベースの基本構造と定義 (DDL)

この単元では、データがどこに、どのように格納されているかという、データベースの土台となる構造と、その定義（DDL: Data Definition Language）に関する用語を学びます。

|用語|説明|関連SQL・補足|
|:--|:--|:--|
|**データベース**|**整理され、構造化された情報の集合体** で、データを効率的に保存、管理、検索するために使用されます。|-|
|**RDBMS**|**リレーショナルデータベース管理システム** の略。データを **テーブル** という形式で管理し、テーブル間の **関係性（リレーション）を定義できる** ソフトウェアです。|PostgreSQLやMySQLなどがこれにあたります。|
|**テーブル**|データベース内でデータを格納する基本的な構造で、**行と列**で構成されます。|Excelのスプレッドシートに例えられます。|
|**列 (カラム/フィールド)**|テーブルにおいて、特定の種類のデータを格納する縦の項目（例：ユーザー名、商品の価格）。|-|
|**行 (レコード/タプル)**|1つのエンティティ（実体、例：1人のお客様）に関するすべての情報を格納する横のまとまり。|-|
|**スキーマ**|データベース内にある、テーブルやビューなどのオブジェクトを論理的にまとめる領域です。|PostgreSQLではデータベース内部に複数のスキーマを持つことができます。|
|**CREATE DATABASE**|新しいデータベースを作成するコマンド。|実行には**スーパーユーザー権限**または CREATEDB ロールが必要です。|
|**CREATE TABLE**|データベース内に新しいテーブルを作成するコマンド。テーブル名、列名、**データ型**、および**制約**を定義します。|-|
|**DROP TABLE**|既存のテーブルをデータベースから完全に削除するコマンド。|**CASCADE** オプションは、参照している他のオブジェクトも一緒に削除するため、**注意して使用してください**。|
|**ALTER TABLE**|既存のテーブルの構造を変更するコマンド。|`ADD COLUMN`（列の追加）や `DROP COLUMN`（列の削除）に使われます。|
|**スネークケース**|列名を `user_id` のように単語間を**アンダースコア（_）で繋ぐ**命名規則。SQLでは一般的に推奨されます。|-|
|**予約語**|SELECT, FROM, WHEREなど、SQLで特別な意味を持つキーワード。テーブル名や列名として使用することは非推奨です。|-|
|**データ型**|各列にどのような種類のデータ（数値、文字列、日付など）を格納するかを定義するもの。|**適切なデータ型**を選択することは、データの整合性を保ち、パフォーマンスを最適化する上で非常に重要です。|
|**NUMERIC / DECIMAL**|**誤差のない正確な値**を格納する数値型。金額や在庫数など、厳密な精度が求められる場合に**必ず使用**すべきです。|-|
|**FLOAT / DOUBLE PRECISION**|**近似値**を格納する浮動小数点数型。わずかな**丸め誤差**が生じるため、**金額計算には絶対に使用しないでください**。|-|
|**VARCHAR(n) / TEXT**|長さ制限を設けたい場合は `VARCHAR(n)`、不要なら `TEXT` を使用します。|PostgreSQLでは両者のパフォーマンスの差はほとんどありません。|
|**TIMESTAMP WITH TIME ZONE (TIMESTAMPTZ)**|タイムゾーン情報を考慮し、内部的にUTC（協定世界時）へ変換して格納する日時型。|複数のタイムゾーンを扱う国際的なサービスで安全な選択です。|
|**INTERVAL**|**「期間」や「時間の間隔」**を格納するデータ型。日付/時刻型の計算に用います。|-|
|**リテラル**|SQL文の中に直接記述する値のこと。|文字列リテラルはシングルクォーテーションで囲みます。|
|**CAST / ::**|あるデータ型の値を、別のデータ型に**明示的に変換**する構文。|`CAST(値 AS 型)` はSQL標準、`値::型` はPostgreSQL固有の簡潔な記法です。|
|**暗黙的な型変換**|SQLエンジンが文脈から判断して自動的に型を変換すること。予期せぬエラーやパフォーマンス低下の原因となるため**非推奨**です。|-|

---

### 第2単元：データの操作 (CRUD) と基本演算子

この単元では、データベースに対する基本的な操作（CRUD）と、データを絞り込むための基本的な演算子を学びます。

|用語|説明|関連SQL・補足|
|:--|:--|:--|
|**CRUD**|データベースを操作するための基本的な4つの機能（**C**reate, **R**ead, **U**pdate, **D**elete）の頭文字。|-|
|**INSERT**|**C**reate（データの作成）を行うコマンド。新しい行を追加します。|-|
|**SELECT**|**R**ead（データの読み取り・検索）を行う、最も重要なコマンド。|`SELECT *` は全ての列を取得しますが、必要な列を明示的に指定することが推奨されます。|
|**UPDATE**|**U**pdate（データの更新）を行うコマンド。既存のデータを変更します。|**WHERE句の省略は、テーブルの全ての行が更新される** ため、細心の注意が必要です。|
|**DELETE**|**D**elete（データの削除）を行うコマンド。テーブルから行を削除します。|**WHERE句の省略は、テーブルの全てのデータが削除される** ため、非常に危険な操作です。|
|**TRUNCATE TABLE**|テーブル構造は残したまま、**全てのデータを高速に削除**します。トランザクションログへの記録が少なく、ロールバックはできません。|-|
|**論理削除**|テーブルからデータを物理的に削除せず、`deleted_at` などの削除フラグを立てて、データが「削除された」状態であることを示す方法。|データ復旧が容易ですが、クエリが複雑になります。|
|**WHERE句**|SELECT, UPDATE, DELETEなどの操作において、**特定の条件に合致する行だけを絞り込む** ために使用します。|論理実行順では、GROUP BYやHAVINGよりも先に評価されます。|
|**ORDER BY句**|取得した結果を指定した列の値で並び替えます。|昇順は `ASC` (デフォルト)、降順は `DESC` です。|
|**LIMIT句/OFFSET句**|取得する行数を制限したり、開始位置を指定したりします。Webアプリケーションのページネーション機能で利用されます。|-|
|**エイリアス (別名)**|列名やテーブル名に一時的に別名（短い名前や日本語名など）を付けること。`AS` キーワードは省略可能です。|複雑なクエリや結合で可読性を高めます。|
|**比較演算子**|2つの値を比較する演算子（例: `=`, `<>`, `>`)。|-|
|**論理演算子**|複数の条件を組み合わせるための演算子（`AND`, `OR`, `NOT`）。|-|
|**NULL**|**値が存在しない** 「未知」の状態を表します。空文字（''）や数値の0とは全く異なります。|判定には比較演算子（=, <>）ではなく、`IS NULL` または `IS NOT NULL` を使用します。|
|**BETWEEN**|値が指定された範囲内（開始値と終了値を含む）にあるかをチェックする演算子。|-|
|**IN / NOT IN**|値が指定されたリスト内のいずれかの値に一致するかをチェックする演算子。|-|
|**LIKE / ILIKE**|文字列の一部が特定のパターンに一致するかをチェックする演算子。**%** は0文字以上の任意の文字列に、**_** は1文字の任意の文字にマッチします。|PostgreSQLでは `ILIKE` を使用すると大文字・小文字を区別せず検索できます。|

---

### 第3単元：データベース設計の原理（正規化と制約）

この単元では、RDBMSの設計思想の根幹である**正規化**のルールと、データの正確性を守る**制約**（PRIMARY KEY, FOREIGN KEY）について深く掘り下げます。

|用語|説明|関連SQL・補足|
|:--|:--|:--|
|**正規化**|データのムダをなくし（**冗長性の排除**）、安全にデータを管理するために、**テーブルを情報の種類ごとに分割** する設計手法。|-|
|**冗長性 (Redundancy)**|同じ情報（例：顧客名やメールアドレス）が、複数の行に何度も繰り返して記録されている状態。正規化の目的はこれを排除することです。|-|
|**データの整合性**|データが矛盾なく、常に正しい状態に保たれていること。|-|
|**挿入異常**|関連する情報がないと新しいデータを挿入できない問題。|-|
|**更新異常**|データ更新時に一部だけが更新され、データの不整合が発生する問題。|山田太郎さんがメールアドレスを変更した際、全注文記録を修正する必要があるケースなど。|
|**削除異常**|関連するデータを削除したときに、意図しない別のデータも一緒に削除されてしまう問題。|-|
|**第一正規形 (1NF)**|**繰り返しグループを排除**し、すべての列が単一の値を持つようにするルール。|-|
|**第二正規形 (2NF)**|**複合主キーの一部にのみ依存する属性**を別のテーブルに分離するルール。|-|
|**第三正規形 (3NF)**|**主キー以外の列に依存する属性**（推移的関数従属）を別のテーブルに分離するルール。|-|
|**主キー (PRIMARY KEY)**|テーブルの**各行を一意に識別** するための、最も重要な列。**NOT NULL** と **UNIQUE** の両方の特性を自動的に持ちます。|テーブルごとに **1つだけ** 設定できます。|
|**複合主キー**|複数の列の組み合わせで構成される主キー。その**組み合わせた値**が一意かつNULLでないことを保証します。|注文明細テーブル {注文ID, 商品ID} のように使われます。|
|**サロゲートキー**|**主キーの自動採番** 機能（SERIAL, BIGSERIAL, IDENTITYなど）によって生成される、業務上の意味を持たない一意なID。レコードを一意に識別するためだけに用いられます。|-|
|**自動採番**|主キーに、新しい行が追加されるたびに自動的に一意の値を生成する機能。RDBMSごとに `SERIAL` (PostgreSQL) や `AUTO_INCREMENT` (MySQL) のように違いがあります。|内部では **シーケンス** オブジェクトが使われます。|
|**シーケンス**|PostgreSQLにおいて、一意の連続した整数を生成するための独立したデータベースオブジェクト。|`nextval()` 関数で次の新しい値を取得できます。|
|**外部キー (FOREIGN KEY)**|他のテーブルの主キーを参照する列。テーブル間の関連性（親子関係）を定義し、**参照整合性**を維持します。|-|
|**外部キー制約**|子テーブルのIDが、**必ず親テーブルに存在するIDを参照**するように強制するルール。不正なデータ登録を自動的に防ぎます。|-|
|**CASCADE (参照動作)**|外部キー制約の設定オプション。親テーブルの行が削除/更新された場合、関連する子テーブルの行も**自動的に削除/更新**されます。|`ON DELETE CASCADE` などの構文で指定します。|
|**マスターテーブル (マスタ)**|業務の**「主役」**となる基本的な情報（顧客、商品など）を管理するテーブル。**参照される側**です。|物語の「登場人物（名詞）」に例えられます。|
|**トランザクションテーブル (トラン)**|日々の業務活動による**「出来事」や「履歴」**（売上、注文など）を記録するテーブル。**マスタを参照する側**です。|物語の「出来事（動詞）」に例えられます。|
|**UNIQUE**|その列の全ての値が**一意である**ことを保証する制約。主キーと異なり、NULLは複数存在できます。|-|
|**DEFAULT**|値を指定しなかった場合に、自動的に設定されるデフォルト値を定義します。|-|
|**CHECK**|その列に挿入される値が、指定された条件を満たしていることを強制する制約。|-|

---

### 第4単元：応用データ取得（集計、結合、サブクエリ、CTE）

この単元では、複数のテーブルを連携させたり、複雑なロジックでデータを処理したりするための応用的なSQL構文を学びます。

|用語|説明|関連SQL・補足|
|:--|:--|:--|
|**JOIN (結合)**|分割・整理された**複数のテーブルを、共通のID（キー）で横につなぎ合わせる**操作。|SQLにおいて最も重要かつ強力な機能の一つです。|
|**INNER JOIN**|**両方のテーブルで結合条件に一致するデータのみ**を結果として返す結合方法。|最も基本で頻繁に使用されます。|
|**LEFT JOIN**|**左側のテーブルのデータをすべて保持**し、右側のテーブルに一致するデータがない場合はNULLで補って返す結合方法。|-|
|**FULL OUTER JOIN**|**両方のテーブルのデータをすべて保持**し、一致しない部分をNULLで補う結合方法。|MySQLなど一部のRDBMSではサポートされていません。|
|**CROSS JOIN**|2つのテーブルのすべての行の組み合わせ（**デカルト積**）を返す結合。|意図せず実行すると膨大な結果が返るため注意が必要です。|
|**SELF JOIN (自己結合)**|同じテーブルを異なる別名で扱い、自分自身と結合する操作。|従業員と上司の関係性など、行同士の関係性を表現したい場合に有効です。|
|**ON句とWHERE句の違い**|**ON句** はテーブルを**結合する際の条件**（結合前）。**WHERE句** は**結合が完了した後の結果セット全体**に対するフィルタリング（結合後）。|OUTER JOINでは結果が大きく変わるため、使い分けが重要です。|
|**USING句**|結合キーとなる列名が**全く同じ場合**に、ON句の代わりに使うことができる簡潔な記法。|-|
|**集計関数**|複数の行の値をまとめて計算し、1つの結果を返す関数（`SUM`, `AVG`, `COUNT`, `MAX`, `MIN` など）。|COUNT(*)を除くほとんどの関数は、計算対象から**NULL値を自動的に除外**します。|
|**GROUP BY句**|指定した列の値が同じ行を一つのグループにまとめ、そのグループごとに集計関数を適用します。|SELECT句の非集計列は、**必ずGROUP BY句にも含める**必要があります。|
|**HAVING句**|GROUP BY句で集計された**結果に対して**条件を指定し、さらに絞り込みを行う場合に利用。HAVING句では集計関数を条件として利用できます。|**WHERE句**はグループ化前の**行の絞り込み**、**HAVING句**はグループ化後の**グループの絞り込み**を行います。|
|**論理実行順**|SQLクエリが内部で処理される概念的な順序。`FROM` → `WHERE` → `GROUP BY` → `HAVING` → `SELECT` → `ORDER BY` の順に処理されます。|-|
|**COALESCE**|引数リストの中から、**最初に見つかったNULLでない値**を返す関数。NULL値のデフォルト値設定によく使われます。|-|
|**CASE式**|SQLクエリ内で条件に応じて処理を分岐させる構文。プログラミング言語の `if-then-else` に似ています。|**クロス集計**（行を列に変換する集計）や独自の並び替え (ORDER BY句内) に強力です。|
|**クロス集計**|**「行」のデータを「列」に変換**して集計するテクニック。月ごとのカテゴリ別売上比較などで利用されます。|CASE式や集計関数と組み合わせて実装されます。|
|**集合演算子**|2つ以上のSELECT文の結果を、行を追加する形で**縦方向**に結合するための演算子。|各SELECT文の**列の数とデータ型が一致している**必要があります。|
|**UNION / UNION ALL**|縦方向に結合。**UNION** は重複行を排除し、**UNION ALL** は重複をそのまま全て表示します（高速）。|-|
|**EXCEPT / MINUS**|最初のSELECT文の結果から、2番目のSELECT文の結果に存在する行を取り除く演算子。PostgreSQLでは `EXCEPT` を使用します。|-|
|**サブクエリ**|**SQLクエリの中に記述される別のSQLクエリ**（入れ子構造）。|SELECT, FROM, WHERE句など様々な場所で活躍します。|
|**非相関サブクエリ**|内側のクエリが外側から独立しており、**一度だけ**実行されるサブクエリ。|結果（単一値やリスト）をWHERE句の絞り込み条件として利用します。|
|**相関サブクエリ**|内側のクエリが、外側のクエリが処理している**現在の行の値に依存**して、**外側の行ごとに毎回実行**されるサブクエリ。|EXISTS句や、グループ内の最大値との比較（パターン2）などで利用されます。|
|**派生テーブル**|FROM句でサブクエリの結果を一つのテーブルと見なし、そのテーブルに対して外側のクエリを実行する際の、**一時的なテーブル**のこと。|-|
|**EXISTS / NOT EXISTS**|相関サブクエリで、関連するデータが**「1行でも存在する」かどうか**をチェックするための構文。|INよりも効率的になることが多いです。|
|**スカラーサブクエリ**|SELECT句で利用され、**必ず単一の値**を返すサブクエリ。新しい列としてサマリー情報を併記するために使われます。|-|
|**CTE (共通テーブル式)**|`WITH`句で定義する名前付きの**一時的な結果セット**。複雑なクエリを論理的なステップに分割し、**可読性を高めます**。|定義したクエリ内でのみ複数回参照可能です。|
|**再帰CTE**|CTEが自分自身を繰り返し参照することで、組織図などの**階層構造のデータ**を展開するための応用機能。|**無限ループ**を防ぐため、必ず停止条件が必要です。|
|**ビュー (VIEW)**|1つまたは複数のテーブルに対するSELECT文を保存し、**仮想的なテーブル**として扱えるようにしたもの。**実体としてのデータは持ちません**。|複雑なクエリの単純化や、セキュリティ向上に役立ちます。|

---

### 第5単元：高度なデータ分析（ウィンドウ関数）

この単元では、データ分析の精度を向上させる**ウィンドウ関数**の概念と、その種類、複雑なフレーム設定について学びます。

|用語|説明|関連SQL・補足|
|:--|:--|:--|
|**ウィンドウ関数**|特定の行のセット（**ウィンドウ**）に対して計算を実行し、その結果を**元の行数を維持したまま各行に返す**機能。|GROUP BYと異なり、行数を減らしません。|
|**OVER()句**|ウィンドウ関数であることを示し、括弧内でウィンドウの定義を行う構文。|-|
|**PARTITION BY句**|データを論理的なグループ（**パーティション**）に分割。このパーティション内で関数が独立して計算されます。|省略された場合、結果セット全体が1つのパーティションとして扱われます。|
|**ウィンドウフレーム**|ORDER BY句と組み合わせ、現在の行を中心とした**計算範囲**（フレーム）を細かく定義する要素。|`ROWS` (行数ベース)、`RANGE` (値ベース)、`GROUPS` (順位グループベース) があります。|
|**ROWS**|ウィンドウフレームを**物理的な行数**（例：2行前）で定義する基準。移動平均などで頻繁に使用されます。|-|
|**RANGE**|ORDER BY列の**値の範囲**でフレームを定義する基準。値が同じ行は全てフレームに含まれます。|-|
|**GROUPS**|ORDER BY列の**同順位グループ単位**でフレームを定義する基準。|-|
|**ランキング関数**|順位付けを行うウィンドウ関数。`ROW_NUMBER()` (連番), `RANK()` (ギャップあり), `DENSE_RANK()` (ギャップなし) があります。|-|
|**ROW_NUMBER()**|重複を考慮せず、ユニークな連番を付与するランキング関数。|-|
|**LAG() / LEAD()**|`LAG()` は指定された数だけ**前の行**の値を、`LEAD()` は**後の行**の値を返す関数。|前日比、翌日比などの計算に多用されます。|
|**FIRST_VALUE() / LAST_VALUE()**|ウィンドウフレーム内の**最初/最後の行**の値を返す関数。|LAST_VALUEでパーティション全体の最終値を取得したい場合、フレームの**明示的な指定がほぼ必須**です。|
|**累計売上 (Running Total)**|`SUM()` の集計関数と `ORDER BY` 句を組み合わせ、時系列データにおける累積値を計算する分析手法。|-|

---

### 第6単元：手続き型プログラミングとパフォーマンス制御

この単元では、データベース内でロジックを制御・自動化するための手続き型言語（PL/pgSQL）と、SQLの実行速度を改善するためのパフォーマンスチューニング技術を学びます。

|用語|説明|関連SQL・補足|
|:--|:--|:--|
|**PL/pgSQL**|PostgreSQLで利用できる**手続き型言語**。標準SQLに、変数、条件分岐、ループといったプログラミング機能を追加したもの。|複雑なロジックをデータベース内で完結させ、パフォーマンスを向上させます。|
|**ブロック構造**|PL/pgSQLのコード単位。`DECLARE` (変数宣言), `BEGIN` (処理), `END` で構成されます。|ブロックは**入れ子（ネスト）にすることができます**。|
|**スコープ**|変数が有効な範囲。変数が宣言されたBEGIN ... ENDブロックの内部に限られます。|-|
|**匿名ブロック (DO)**|関数を作成しなくても直接PL/pgSQLコードを実行できる、一度きりの処理のためのブロック。|-|
|**$$ (ドル記号クォーティング)**|PL/pgSQLのコード本体を囲む記法。コード内のシングルクォートのエスケープを不要にするために推奨されます。|-|
|**関数 (FUNCTION)**|PL/pgSQLのロジックを再利用可能な形で保存したもの。特定の処理を行い、**結果として値を返す**ことが目的。|**内部でトランザクション制御（COMMIT, ROLLBACK）はできません**。|
|**プロシージャ (PROCEDURE)**|PL/pgSQLのロジックを再利用可能な形で保存したもの。一連のデータ操作や処理を**実行する**ことが目的で、値を返しません。|**内部でトランザクション制御（COMMIT, ROLLBACK）ができます**。|
|**%TYPE / %ROWTYPE**|テーブルの列や行と同じデータ型を持つ変数を宣言するための便利な属性。**メンテナンス性の向上**に役立ちます。|-|
|**レコード型 (RECORD)**|型を事前に定義する必要がない、柔軟な複合型。SELECTの結果を一時的に格納する際に、問い合わせの列構造に応じて**動的に構造が決まります**。|-|
|**SELECT ... INTO ...**|SQLクエリの結果を直接変数に代入するための構文。クエリが**厳密に1行だけ**を返すことを期待します。|-|
|**STRICT**|`SELECT INTO` に付けるオプション。**結果が0行の場合に `no_data_found` エラーを発生させる**ため、堅牢なコードのために推奨されます。|-|
|**PERFORM**|**クエリの結果（戻り値）を必要としない場合**に、そのクエリを実行し、結果セットをすべて破棄する特殊なコマンド。|`SELECT ...` を `INTO` 句なしで実行するとエラーになるのを防ぎます。|
|**FOUND / ROW_COUNT**|直前に実行したSQL文の状態を把握するための特殊変数。`FOUND` は1行以上の処理があったか (True/False)。`ROW_COUNT` は具体的に何行が影響を受けたか（件数）。|-|
|**GET DIAGNOSTICS**|`ROW_COUNT` など、直前のコマンドに関する様々な診断情報を取得するためのコマンド。|-|
|**動的SQL / EXECUTE**|プログラムの実行中に文字列としてSQL文を組み立て、それを `EXECUTE` コマンドで実行する手法。|-|
|**SQLインジェクション**|ユーザーからの悪意のある入力を利用して、意図しないSQLを実行させてしまうセキュリティ上の脅威。|-|
|**USING句 (動的SQL)**|動的SQLに値を渡す際に、SQLインジェクションを防ぐために使用する**安全な方法**。|-|
|**RAISE**|メッセージ、警告、あるいは処理を中断させるための**エラーを意図的に発生させる**コマンド。|`RAISE EXCEPTION` は現在のトランザクションを中断・ロールバックさせます。|
|**例外処理 (EXCEPTION)**|`BEGIN ... EXCEPTION ... END` ブロックを使い、エラーを捕捉し、代替処理を行う仕組み。|捕捉されたエラーは、そのブロック内での変更**のみをロールバック**し、処理を続行できます。|
|**トリガー (Trigger)**|テーブルに対するINSERT、UPDATE、DELETE操作をきっかけに**自動的に呼び出される**特殊な関数。|`BEFORE` (操作実行前) や `AFTER` (操作完了後) のタイミングを指定できます。|
|**NEW / OLD**|トリガープロシージャ内で利用できる特殊変数。`NEW` は挿入・更新される新しい行、`OLD` は更新・削除される古い行のデータです。|-|
|**カーソル (Cursor)**|大量の結果セットを一度にメモリに読み込まず、**一行ずつ順番に処理**するための仕組み。バッチ処理に不可欠です。|-|
|**FOR ... IN ... LOOP**|**クエリ結果の行を一件ずつ処理**したい場合に、カーソルを明示せずに使えるループ構文。実務で最もよく使われます。|-|
|**インデックス (Index)**|データベースからデータを**高速に検索するための仕組み**。本の「索引」に例えられます。|-|
|**B-Tree**|PostgreSQLなど多くのデータベースで使われている、インデックスの主要な内部データ構造。階層構造を持ち、高速な探索を実現します。|-|
|**シーケンシャルスキャン (Sequential Scan)**|インデックスを使わず、テーブルの先頭から最後まで**全行を順番に読み込む**データアクセス方法（フルスキャン）。|データ量が少ない場合や、検索結果がテーブルの大部分を占める場合に選択されます。|
|**複合インデックス**|複数の列を組み合わせて作成するインデックス。**列の順序が極めて重要**です。|-|
|**左側プレフィックス**|複合インデックス (A, B, C) が、先頭から連続する列の組み合わせ (A) や (A, B) での検索に利用できる特性。|-|
|**カバリングインデックス**|クエリが必要とする**すべての列**をインデックス自体に含めることで、テーブル本体へのアクセスを不要にするインデックス。|-|
|**インデックスオンリースキャン (Index Only Scan)**|カバリングインデックスの利用により、テーブル本体を見に行かずに処理が完結する、最も高速なアクセス方法の一つ。|-|
|**関数インデックス**|列を関数で加工した結果に対して作成するインデックス。|WHERE句でインデックス列に関数を適用し、通常のインデックスが効かなくなった場合の対策として有効です。|
|**実行計画 (Execution Plan)**|データベースがSQLをどのような手順で実行するかを示した**「作戦書」**。|-|
|**EXPLAIN ANALYZE**|実際にクエリを**実行**し、その結果に基づいた実行計画と、**実際の実行時間**や処理行数を表示するコマンド。|チューニングではこれをメインで使います。|
|**actual time**|実行計画において、各処理（ノード）の**実際の実行時間**（ミリ秒）。**チューニングの最も重要な指標**です。|-|
|**ネステッドループ結合 (Nested Loop Join)**|外側のテーブルをループし、内側のテーブルを検索して結合するJOIN方式。内側の結合キーにインデックスがある場合に高速。|-|
|**ハッシュ結合 (Hash Join)**|小さい方のテーブルでハッシュテーブルを作成し、大きい方のテーブルをスキャンしながら照合するJOIN方式。結合キーにインデックスがない大規模テーブル同士の等価結合で有効。|-|
|**マージ結合 (Merge Join)**|両方のテーブルを結合キーでソートし、突き合わせるように結合するJOIN方式。|-|
|**トランザクション**|**関連する一連の処理を一つにまとめた単位**。すべて成功するか、すべて失敗するかのどちらかであることが保証されます。|-|
|**ACID特性**|信頼性の高いトランザクションが満たすべき4つの特性（原子性、一貫性、独立性、永続性）。|-|
|**BEGIN / COMMIT / ROLLBACK**|トランザクションを開始し、変更を恒久的に反映し、または変更を破棄して開始前の状態に戻すためのコマンド。|-|
|**セーブポイント**|複雑なトランザクションの途中で、特定の部分だけを取り消す（部分的なロールバックを行う）ために設定する目印。|-|
|**ダーティリード**|コミットされていない変更を他のトランザクションが読んでしまう現象。|-|
|**ノンリピータブルリード**|同一トランザクション内で同じ行を2回読んだ際に、結果が異なる現象。|-|
|**ファントムリード**|同一トランザクション内で特定の範囲を2回読んだ際に、行が増減している現象。|-|
|**MVCC**|**多版型同時実行制御** の略。更新時に古いデータを保持することで、読み取り（SELECT）と書き込み（UPDATE）が互いにブロックしないようにする仕組み。|-|
|**排他ロック (Exclusive Lock)**|ある行を**変更・削除する権利を独占**するためのロック。`UPDATE`, `DELETE`, `SELECT ... FOR UPDATE` で取得されます。|-|
|**共有ロック (Shared Lock)**|「読み取りの一貫性」を保証するためのロック。データの変更はブロックしつつ、他のトランザクションによる参照は許可します。`SELECT ... FOR SHARE` で意図的に取得します。|-|
|**デッドロック**|2つのトランザクションがお互いに相手が確保しているロックの解除を待ち続け、永久に処理が進まなくなる**相互待ち状態**。|データベースが検知し、一方を強制的にエラー（ROLLBACK）にして解消します。|