### VI. 応用編：トリガーとカーソル (Advanced Usage: Triggers and Cursors)

この単元では、データベースのデータが変更されたときに自動的に処理を実行する「トリガー」と、大量の検索結果を一行ずつ効率的に処理するための「カーソル」という、2つの強力な応用技術について学びます。

#### 1. トリガープロシージャ (Trigger Procedures)

トリガーとは、テーブルに対する`INSERT`、`UPDATE`、`DELETE`操作をきっかけに**自動的に**呼び出される特殊な関数です。データの整合性維持や監査ログの記録などに広く利用されます。

##### トリガーの構成要素
1.  **トリガープロシージャの作成**: `RETURNS trigger`型を返す特殊な関数を作成します。
2.  **トリガーの定義**: `CREATE TRIGGER`文を使い、「どのテーブル」の「どの操作」の「どのタイミング」でプロシージャを実行するかを定義します。

##### タイミング (`BEFORE`/`AFTER`/`INSTEAD OF`) とレベル (`ROW`/`STATEMENT`)
*   **タイミング**:
    *   `BEFORE`: 操作が**実行される前**に起動。入力値の検証や変更、操作自体のキャンセルに利用。
    *   `AFTER`: 操作が**完了した後**に起動。操作後のデータを使ったログ記録や他テーブルへの連携に利用。
    *   `INSTEAD OF`: **ビュー**に対する操作の際に起動。ビューへの`INSERT`などを、実テーブルへの適切な操作に変換するために使います（後述）。
*   **レベル**:
    *   `FOR EACH ROW`: 影響を受けた**行ごと**に起動。最も一般的。
    *   `FOR EACH STATEMENT`: SQL**文ごと**に1回だけ起動。

##### 特殊なトリガー変数
| 変数名 | 型 | 説明 |
| :--- | :--- | :--- |
| `NEW` | `RECORD` | `INSERT`/`UPDATE`で挿入・更新される**新しい行**のデータ。 |
| `OLD` | `RECORD` | `UPDATE`/`DELETE`で更新・削除される**古い行**のデータ。 |
| `TG_OP` | `text` | 操作の種類 (`'INSERT'`, `'UPDATE'`, `'DELETE'`)。 |
| `TG_WHEN`| `text`| トリガーのタイミング (`'BEFORE'`, `'AFTER'`, `'INSTEAD OF'`)。|
| `TG_TABLE_NAME` | `name` | テーブルの名前。 |

##### `BEFORE`トリガーの活用：データ検証と変更
`BEFORE`トリガーの戻り値は特別な意味を持ちます。
*   **`RETURN NEW;`**: `INSERT`/`UPDATE`操作を**許可**し、`NEW`レコードの内容で実際に書き込みます。`NEW`のフィールドを書き換えてから`RETURN`すれば、データを加工して保存できます。
*   **`RETURN NULL;`**: `INSERT`/`UPDATE`/`DELETE`操作を**キャンセル**します。その行に対する操作は行われません。

**具体例1：`INSERT`時に名前の前後の空白を自動で除去する**
```sql
CREATE OR REPLACE FUNCTION trim_product_name()
RETURNS trigger AS $$
BEGIN
    -- NEWレコードのnameフィールドを直接変更
    NEW.name := trim(NEW.name);
    -- 変更したNEWレコードを返す
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER products_trim_name_trigger
BEFORE INSERT ON products
FOR EACH ROW
EXECUTE FUNCTION trim_product_name();

-- 実行: '  Tablet  ' という値でINSERTしても、'Tablet'として保存される
INSERT INTO products (name, price) VALUES ('  Tablet  ', 30000);
```

**具体例2：特定の商品の削除を禁止する**
```sql
CREATE OR REPLACE FUNCTION prevent_core_product_deletion()
RETURNS trigger AS $$
BEGIN
    -- 削除しようとしている行(OLD)の名前をチェック
    IF OLD.name = 'Core System Component' THEN
        RAISE WARNING 'Deletion of core product (ID: %) is not allowed.', OLD.id;
        -- NULLを返して操作をキャンセル
        RETURN NULL;
    END IF;
    -- それ以外の商品は削除を許可
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER products_prevent_deletion_trigger
BEFORE DELETE ON products
FOR EACH ROW
EXECUTE FUNCTION prevent_core_product_deletion();
```

##### `AFTER`トリガーの活用と`WHEN`句による効率化
`AFTER`トリガーは、操作が確定した後のデータを使ってログを取るなどの処理に適しています。

**具体例：商品の価格変更履歴を自動で記録する**
```sql
-- トリガープロシージャ
CREATE OR REPLACE FUNCTION log_price_change()
RETURNS trigger AS $$
BEGIN
    INSERT INTO price_audit (product_id, old_price, new_price)
    VALUES (OLD.id, OLD.price, NEW.price);
    -- AFTERトリガーの戻り値は無視されるので、NULLを返すのが慣習
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- トリガーの定義（WHEN句なし）
CREATE TRIGGER products_price_audit_trigger
AFTER UPDATE ON products
FOR EACH ROW
EXECUTE FUNCTION log_price_change();
-- これだと価格以外の列(例:name)が更新された場合も、不要な関数呼び出しが発生する
```

**`WHEN`句による最適化**
`CREATE TRIGGER`文に`WHEN`句を追加すると、その条件が真の場合にのみトリガー関数が実行されます。これは、関数内で`IF`文を使うより効率的です。

```sql
-- 古いトリガーを削除
DROP TRIGGER products_price_audit_trigger ON products;

-- WHEN句を使った新しいトリガー
CREATE TRIGGER products_price_audit_trigger
AFTER UPDATE ON products
FOR EACH ROW
-- OLD.priceとNEW.priceが異なる場合にのみ関数を呼び出す
WHEN (OLD.price IS DISTINCT FROM NEW.price)
EXECUTE FUNCTION log_price_change();
```
この改善により、価格以外のフィールドが更新された際には、トリガー関数の呼び出し自体が発生しなくなり、無駄なオーバーヘッドを削減できます。

---
#### 2. カーソル (Cursors)

カーソルは、大量の結果セットを一度にメモリに読み込まず、**一行ずつ順番に**処理するための仕組みです。メモリ不足を防ぎ、巨大なデータをバッチ処理する際に不可欠です。

##### カーソルの基本的な使い方
`DECLARE`で宣言、`OPEN`で実行、`FETCH`で取得、`CLOSE`で解放します。しかし、多くの場合、より安全で簡潔な**カーソル`FOR`ループ**が推奨されます。

**具体例：`FOR`ループによるカーソル処理**
```sql
DO $$
DECLARE
    emp_rec employees%ROWTYPE;
    -- カーソルの宣言
    cur_employees CURSOR FOR SELECT * FROM employees ORDER BY id;
BEGIN
    -- FORループが自動的にOPEN, FETCH, CLOSEを行う
    FOR emp_rec IN cur_employees LOOP
        RAISE NOTICE 'Processing Employee: ID=%, Name=%', emp_rec.id, emp_rec.name;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

##### パラメータ付きカーソル
カーソルを宣言する際に引数を定義することで、`OPEN`時に動的な値を渡すことができ、カーソルの再利用性が高まります。

**具体例：指定した価格以上の商品を処理する**
```sql
DO $$
DECLARE
    prod_rec products%ROWTYPE;
    -- numeric型の引数を取るカーソルを宣言
    cur_expensive_products CURSOR(min_price numeric)
        FOR SELECT * FROM products WHERE price >= min_price;
BEGIN
    -- 10万円を引数としてカーソルを開く
    OPEN cur_expensive_products(100000);
    LOOP
        FETCH cur_expensive_products INTO prod_rec;
        EXIT WHEN NOT FOUND;
        RAISE NOTICE 'High-priced product: % (%)', prod_rec.name, prod_rec.price;
    END LOOP;
    CLOSE cur_expensive_products;
END;
$$;
```

##### カーソルによる更新と削除 (`WHERE CURRENT OF`)
カーソルを使って行をフェッチした後、その**まさに今指している行**を更新または削除したい場合があります。その場合、`WHERE id = ...`のように再度行を特定するよりも、`WHERE CURRENT OF`を使う方が安全かつ効率的です。

**前提条件**: カーソルは`FOR UPDATE`句を付けて宣言する必要があります。

**具体例：古いログを一括でアーカイブフラグを立てて更新する**
```sql
-- execution_logテーブルに archived カラムを追加
-- ALTER TABLE execution_log ADD COLUMN archived boolean DEFAULT false;

DO $$
DECLARE
    -- FOR UPDATE句を付けて、更新対象であることを明示
    cur_old_logs CURSOR FOR
        SELECT * FROM execution_log WHERE logged_at < '2025-01-01' AND archived = false
        FOR UPDATE;
    log_rec execution_log%ROWTYPE;
BEGIN
    OPEN cur_old_logs;
    LOOP
        FETCH cur_old_logs INTO log_rec;
        EXIT WHEN NOT FOUND;

        -- カーソルが現在指している行を更新
        UPDATE execution_log SET archived = true
        WHERE CURRENT OF cur_old_logs;

    END LOOP;
    CLOSE cur_old_logs;
END;
$$;
```
`WHERE CURRENT OF`は、対象行をロックする`FOR UPDATE`と組み合わせることで、他のトランザクションとの競合を防ぎながら、安全に一行ずつデータを処理・更新する強力な手段となります。