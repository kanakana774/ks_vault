## **PostgreSQLにおけるSQLパフォーマンスチューニング：インデックスと実行計画の基礎**

### **第1章：なぜインデックスと実行計画が重要なのか？**

SQLの基本的な操作を学んだ後、多くの開発者が直面するのが「クエリが遅い」というパフォーマンスの壁です。特にデータ量が増えるほど、この問題は顕著になります。この問題を解決し、データベースの性能を最大限に引き出すために不可欠な知識が「**インデックス**」と「**実行計画**」です。

*   **インデックス (Index)**
    データベースから高速にデータを検索するための仕組みで、本の「索引」に例えられます。適切に設計することで、検索やソートの速度を劇的に向上させます。
*   **実行計画 (Execution Plan)**
    データベースがSQLをどのような手順で実行するかを示した「作戦書」です。これを読み解くことで、クエリのどこが非効率なのか（ボトルネック）を特定し、改善の糸口を見つけることができます。

本稿では、これらの概念を基礎から解説し、実践的なパフォーマンスチューニングの第一歩を踏み出すための知識を提供します。

### **第2章：インデックスの仕組みと基本**

#### **1. インデックスとは？ ― データの高速な地図**

インデックスは、テーブルの特定の列の値を、その値を持つ行の物理的な格納場所と紐付けたデータ構造です。

もしインデックスがなければ、データベースは目的のデータを見つけるためにテーブルの先頭から一行ずつ順番に探す必要があります。これを**シーケンシャルスキャン（フルテーブルスキャン）**と呼びます。データが数百万件にもなると、この方法は非常に時間がかかります。

一方、インデックスがあれば、まず索引を引くようにインデックスを検索し、目的のデータがある場所を直接見つけ出すことができます。これにより、テーブル全体を探す無駄をなくし、検索を高速化します。

#### **2. インデックスの内部構造：B-Tree**

PostgreSQLをはじめとする多くのデータベースでは、インデックスの主要なデータ構造として**B-Tree（B木）**が使われています。B-Treeは、データが常にソートされた状態で保持される、バランスの取れた木構造をしています。


B-Treeには以下の特徴があり、これが高速な検索を実現する理由です。

*   **階層構造**: データはルートノードからリーフノードへと階層的に整理されています。
*   **ソート済み**: 各ノード内のキー（インデックス列の値）は常にソートされています。これにより、次にどのノードをたどればよいかを効率的に判断できます。
*   **高速な探索**: 目的の値をルートからたどることで、データの量（N）に対して対数時間（log N）でアクセスできます。例えば、100万件のデータがあっても、わずか数回のディスクアクセスで目的のデータにたどり着けます。

つまり、インデックスとは**「特定の値がテーブルのどこにあるかを示す、ソート済みの高速な地図帳」**のようなものです。

#### **3. インデックスの作成方法**

インデックスは `CREATE INDEX` 文で作成します。

```sql
CREATE INDEX index_name ON table_name (column_name [ASC|DESC], ...);
```

### **第3章：インデックスの種類と戦略的な使い方**

インデックスにはいくつかの種類があり、用途に応じて使い分けることが重要です。

#### **1. 単一列インデックス (Single-Column Index)**

最も基本的な、1つの列に対して作成されるインデックスです。

*   **用途**: `WHERE`句での絞り込みや`ORDER BY`句でのソートが、特定の1列に対して頻繁に行われる場合に効果的です。
*   **具体例**: `products`テーブルの`product_name`で頻繁に検索する場合。

    ```sql
    -- productsテーブルのproduct_name列にインデックスを作成
    CREATE INDEX idx_products_product_name ON products (product_name);
    ```

    このインデックスにより、`WHERE product_name = 'Laptop'` のようなクエリは、B-Treeを高速にたどって目的の行を見つけ出します。

#### **2. 複合インデックス (Composite Index)**

複数の列を組み合わせて作成するインデックスです。**列の順序が極めて重要**になります。

*   **用途**: 複数の列を`AND`条件で絞り込むクエリや、複数列でのソートに効果を発揮します。
*   **B-Treeの挙動**: キーは指定された列の順番で「辞書順」にソートされます。例えば `(category_id, price)` の順で作成すると、まず `category_id` でソートされ、同じ `category_id` の中では `price` でソートされます。
*   **重要ポイント**: 複合インデックス `(A, B, C)` は、インデックスの先頭から連続する列の組み合わせ、つまり `(A)` や `(A, B)` での検索にも利用できます（**左側プレフィックス**）。しかし、`(B)` や `(B, C)` のように先頭列 `A` を含まない検索では、B-Treeのソート順を利用できないため効果的に使われません。
*   **具体例**: `products`テーブルで、`category_id`で絞り込んだ後、`price`で範囲検索することが多い場合。

    ```sql
    -- category_idとpriceの複合インデックスを作成
    CREATE INDEX idx_products_category_price ON products (category_id, price DESC);
    ```

    このインデックスは `WHERE category_id = 1 AND price > 100` のようなクエリを高速化します。

#### **3. カバリングインデックス (Covering Index)**

クエリが必要とするすべての列をインデックス自体に含めることで、テーブル本体へのアクセスを不要にするインデックスです。

*   **用途**: テーブルへのアクセス（ディスクI/O）を完全に排除し、クエリを最大限に高速化したい場合。このインデックスだけで処理が完結するスキャンを**インデックスオンリースキャン (Index-Only Scan)**と呼びます。
*   **具体例**: `category_id` で検索し、`product_name` と `price` を取得するクエリを高速化したい場合。PostgreSQLでは `INCLUDE` 句を使います。

    ```sql
    -- category_idをキーとし、priceとproduct_nameをインデックスに含める
    CREATE INDEX idx_products_category_include_price_name
    ON products (category_id) INCLUDE (price, product_name);
    ```

    `SELECT product_name, price FROM products WHERE category_id = 1;` というクエリは、このインデックスだけで完結するため、テーブル本体を読む必要がなく非常に高速です。

    **注意点**: PostgreSQLのIndex-Only Scanは、行が他のトランザクションから「可視」であると保証されている場合にのみ有効です。 定期的な`VACUUM`処理が適切に行われていないと、結局テーブル本体へのアクセスが発生することがあります。

#### **4. ユニークインデックス (Unique Index)**

列（または列の組み合わせ）の値の重複を許さない制約を課すインデックスです。

*   **用途**: データの整合性を保証（重複禁止）しつつ、その列での検索を高速化します。`PRIMARY KEY`や`UNIQUE`制約を作成すると、内部的にユニークインデックスが自動で作成されます。
*   **具体例**: `users`テーブルの`email`列が必ず一意であるように保証する場合。

    ```sql
    CREATE UNIQUE INDEX idx_users_unique_email ON users (email);
    ```

#### **5. 部分インデックス (Partial Index)**

テーブルの一部の行、つまり特定の条件を満たす行だけを対象とするインデックスです。

*   **用途**: インデックスのサイズを小さく保ち、更新コストを抑えたい場合に有効です。「論理削除フラグが立っていないもの」や「ステータスが'active'のもの」など、検索対象が限定される場合に非常に役立ちます。
*   **具体例**: `users`テーブルで、有効なユーザー (`is_active = true`) のみを対象に `email` のインデックスを作成する場合。

    ```sql
    CREATE INDEX idx_users_active_email ON users (email) WHERE is_active = true;
    ```
    このインデックスは `WHERE is_active = true AND email = '...'` のようなクエリでのみ使用されます。

### **第4章：インデックスが効かないケースとその対策**

インデックスは万能ではありません。B-Treeの構造を理解すると、なぜインデックスが使われないのかが明確になります。

#### **1. 列への加工・関数の利用**

インデックスが設定された列に `LOWER()` や `DATE()` などの関数を適用すると、インデックスは利用されません。

*   **なぜ効かないのか**: B-Treeには元の値 (`'Laptop'`) がソートされて格納されています。関数で加工された後の値 (`'laptop'`) はインデックスには存在しないため、直接検索できません。結果として、データベースは全行に関数を適用して比較するしかなくなります。
*   **効かない例**:
    ```sql
    -- LOWER()関数を使っているため、インデックスは効かない
    SELECT * FROM products WHERE LOWER(product_name) = 'laptop';
    ```
*   **対策**: **関数インデックス**を作成します。これは、関数の適用結果をあらかじめ計算してB-Treeに格納しておくインデックスです。
    ```sql
    -- LOWER(product_name)の結果に対してインデックスを作成
    CREATE INDEX idx_products_lower_product_name ON products (LOWER(product_name));
    ```

#### **2. `LIKE`検索のワイルドカード**

`LIKE`句で検索文字列の**先頭に**ワイルドカード (`%` や `_`) を使用するとインデックスは利用されません。

*   **なぜ効かないのか**: B-Treeは先頭の文字から順にソートされています。`'Mouse%'` のように前方一致であれば「'M'で始まる範囲」を効率的に探せます。しかし、`'%Mouse'` のように先頭が不明な場合、B-Treeのどこから探せばよいか見当がつかず、結局全行をスキャンするしかありません。
*   **効かない例**:
    ```sql
    -- 先頭がワイルドカードのため、インデックスは効かない
    SELECT * FROM products WHERE product_name LIKE '%book';
    ```
*   **対策**:
    1.  可能な限り前方一致 (`'note%'`) の検索に設計を見直す。
    2.  **全文検索機能** (e.g., GINインデックス) の利用を検討する。
    3.  PostgreSQLでは、前方一致検索の性能を上げるための**演算子クラス**を指定する方法もあります。
        ```sql
        CREATE INDEX idx_product_name_pattern ON products (product_name text_pattern_ops);
        ```

#### **3. その他の注意点**

*   **データ型の不一致**: `WHERE user_id = '123'` のように、数値型の列を文字列で検索すると、内部的な型変換が発生してインデックスが使われないことがあります。
*   **`OR`条件**: 異なる列に対する`OR`条件は、オプティマイザが最適なインデックス利用を判断しにくい場合があります。ただし、ビットマップスキャンによって効率的に処理されることもあります。
*   **否定形 (`NOT IN`, `<>`)**: インデックスは「存在する値」を探すのは得意ですが、「存在しないもの」を探すのは苦手なため、利用されにくい傾向があります。
*   **カーディナリティが低い列**: 性別やフラグのように値の種類が極端に少ない列では、インデックスを使っても絞り込み効果が薄いです。例えば、「性別が男性」で検索してデータの半分がヒットする場合、インデックスを使って一件ずつテーブルにアクセスするより、最初からテーブル全体をスキャンした方が速いと判断されることがあります。

### **第5章：インデックスの代償：デメリット**

インデックスは検索を高速化する一方で、無視できないコストも伴います。闇雲に増やすのは避けましょう。

1.  **書き込み性能の低下**: `INSERT`, `UPDATE`, `DELETE` が発生するたびに、テーブルだけでなく関連するすべてのインデックスも更新する必要があります。インデックスが多すぎると、この更新コストが積み重なり、書き込み処理が遅くなります。
2.  **ストレージ容量の消費**: インデックスもデータなので、ディスク容量を消費します。テーブル本体と同じか、それ以上のサイズになることもあります。
3.  **メンテナンスコスト**: データベースのオプティマイザは、クエリ実行時にどのインデックスを使うかを選択します。インデックスが多すぎると、この選択が複雑になり、最適な実行計画を立てる妨げになる可能性があります。

**教訓：インデックスは、`EXPLAIN`で効果を確認し、本当に必要なものだけを作成するべきです。**

### **第6章：実行計画の読み解き方**

実行計画は、PostgreSQLがクエリをどのように実行するかという内部的な手順を示したものです。パフォーマンスチューニングは、まずこの「作戦書」を読めるところから始まります。

#### **1. 実行計画の取得：`EXPLAIN` と `EXPLAIN ANALYZE`**

*   `EXPLAIN`: 実際にクエリを実行せず、**推定**の実行計画を表示します。安全に何度でも実行できます。コストや行数はあくまで推定値です。
*   `EXPLAIN ANALYZE`: 実際にクエリを**実行**し、その結果に基づいた実行計画と、実際の実行時間や処理行数を表示します。より正確な情報が得られるため、**チューニングではこちらをメインで使います**。ただし、更新系のクエリを実行する際は注意が必要です。

**基本構文**:
```sql
EXPLAIN ANALYZE SELECT * FROM products WHERE price > 100;
```

**出力例**:
```
Seq Scan on products  (cost=0.00..30.38 rows=122 width=35) (actual time=0.010..0.115 rows=123 loops=1)
  Filter: (price > '100'::numeric)
Planning Time: 0.088 ms
Execution Time: 0.138 ms
```

#### **2. 実行計画の基本要素の読み方**

*   **ノード**: 各行が1つの操作（ノード）を表します。実行はインデントが深い内側のノードから外側へ進みます。
*   **`cost`**: `開始コスト..総コスト` の形式で表示されます。これはディスクI/OやCPU利用を考慮した**単位のない相対的な数値**であり、時間ではありません。値が小さいほど効率的であると推定されます。
*   **`rows`**: そのノードが返す**推定**行数です。
*   **`actual time`**: `開始時間..総時間` (ミリ秒) の形式で、ノードの実際の実行時間を示します。**この値がチューニングの最も重要な指標**です。
*   **`rows` (actual)**: 実際にそのノードが返した行数です。推定値と大きく乖離している場合、統計情報が古い可能性があり、オプティマイザが非効率な計画を立てている原因になります。

### **第7章：実行計画から見るデータへのアクセス方法**

実行計画の中心となるのが、テーブルからデータをどうやって読み取るかというアクセス方法です。

#### **1. シーケンシャルスキャン (Sequential Scan)**

*   **動作**: テーブルの先頭から最後まで全行を順番に読み込みます。
*   **選択される理由**:
    *   利用できるインデックスがない。
    *   検索結果がテーブルの大部分を占めるため、インデックスを使うより効率的だと判断された。
    *   テーブルが非常に小さい。

#### **2. インデックススキャン (Index Scan)**

*   **動作**: まずインデックスを検索して目的の行の場所を特定し、次にその場所にあるテーブルの行にアクセスします。
*   **選択される理由**:
    *   利用できるインデックスがあり、検索結果がテーブルのごく一部であるため、効率的だと判断された。

#### **3. インデックスオンリースキャン (Index Only Scan)**

*   **動作**: クエリに必要な情報がすべてインデックス内に含まれている（カバリングインデックス）ため、テーブル本体にはアクセスせず、インデックスの読み取りだけで処理が完了します。
*   **特徴**: テーブルへのアクセスがなくなるため、非常に高速です。

#### **4. ビットマップスキャン (Bitmap Scan)**

*   **動作**: `Bitmap Index Scan` と `Bitmap Heap Scan` の2段階で動作します。まず、インデックスを使って条件に合う行の場所をメモリ上の地図（ビットマップ）に記録し、その後、その地図に基づいて効率的な順番でテーブルからデータをまとめて読み込みます。
*   **選択される理由**:
    *   複数のインデックスを `OR` 条件で組み合わせる場合など、一度に多くの行にアクセスする必要があるが、シーケンシャルスキャンよりは効率的な場合に選択されます。

### **第8章：実行計画から見るテーブルの結合方法**

複数のテーブルを結合する際、PostgreSQLは状況に応じて最適なアルゴリズムを選択します。

#### **1. ネステッドループ結合 (Nested Loop Join)**

*   **アルゴリズム**: 外側のテーブルの行を1つずつループし、その各行に対して内側のテーブルを検索して結合します。
*   **選択される理由**:
    *   片方のテーブルが非常に小さい場合。
    *   **内側テーブルの結合キーにインデックスがある場合**に非常に高速です。

#### **2. ハッシュ結合 (Hash Join)**

*   **アルゴリズム**: 小さい方のテーブル（ビルド側）からメモリ内にハッシュテーブルを作成し、大きい方のテーブル（プローブ側）をスキャンしながらハッシュテーブルと照合して結合します。
*   **選択される理由**:
    *   **結合キーにインデックスがない**大規模なテーブル同士の**等価結合** (`=`) で非常に効率的です。
    *   メモリを多く消費する点がデメリットです。

#### **3. マージ結合 (Merge Join)**

*   **アルゴリズム**: 両方のテーブルを結合キーでソートし、その後、2つのソート済みリストを突き合わせるように結合します。
*   **選択される理由**:
    *   両方のテーブルがすでにソート済みの場合（例：インデックススキャンの結果など）に非常に高速です。
    *   ソートされていない場合は、事前のソート処理にコストがかかります。

### **第9章：実践的パフォーマンスチューニングのワークフロー**

遅いクエリを改善するための基本的な手順は以下の通りです。

1.  **遅いクエリの特定**
    アプリケーションのログや`pg_stat_statements`などの監視ツールを使って、実行時間が長い、あるいは実行頻度が高い非効率なクエリを見つけます。
2.  **`EXPLAIN ANALYZE` による現状把握**
    特定したクエリの実行計画と実際の性能（`actual time`）を取得します。これが全ての分析の出発点です。
3.  **ボトルネックの分析**
    実行計画を読み解き、問題点を探します。
    *   **意図しないシーケンシャルスキャン**が発生していないか？
    *   **`actual time`が極端に長いノード**はどこか？
    *   推定行数と実行行数が大きく乖離していないか？
    *   非効率なJOIN方式が選択されていないか？
4.  **改善策の立案と実施**
    分析結果に基づいて対策を講じます。
    *   **インデックスの追加・修正**: `WHERE`句や`JOIN`句、`ORDER BY`句で使われる列に適切なインデックスを作成する。カバリングインデックスや部分インデックスも検討する。
    *   **クエリの書き換え**: インデックスが効く形（関数を使わない、`LIKE`の前方一致など）に書き換える。不要なJOINやサブクエリを整理する。
    *   **統計情報の更新**: `ANALYZE table_name;` を実行して統計情報を最新化し、オプティマイザがより現実に即した計画を立てられるようにする。
5.  **効果測定**
    対策後、**再度 `EXPLAIN ANALYZE` を実行**し、実行時間が短縮されたか、実行計画が意図通りに改善されたかを確認します。

このサイクルを繰り返すことで、データベースのパフォーマンスを継続的に改善していくことができます。