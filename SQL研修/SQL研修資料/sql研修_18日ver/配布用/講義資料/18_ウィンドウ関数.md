## PostgreSQL ウィンドウ関数 詳細解説

### 1. 導入：ウィンドウ関数とは？

**ウィンドウ関数**は、特定の行のセット（**ウィンドウ**）に対して計算を実行し、その結果を**各行に返す**機能です。

**`GROUP BY`句との決定的な違い**
- **`GROUP BY`**: 集計によって行数を**減らし**ます（グループごとに1行にまとめる）。
- **ウィンドウ関数**: 元の行数を**維持**したまま、集計結果やランキングなどを各行の文脈情報として付加します。

これにより、ランキング、移動平均、累計、前後の行との比較など、より複雑なデータ分析やレポート作成が可能になります。

---

### 2. 基本構文と構成要素

ウィンドウ関数の基本構文は以下の通りです。

```sql
関数名() OVER ([PARTITION BY 列リスト] [ORDER BY 列リスト] [ウィンドウフレーム])
```

| 構成要素              | 役割                                                                |
| :---------------- | :---------------------------------------------------------------- |
| **関数名()**         | 実行したいウィンドウ関数（例: `ROW_NUMBER()`, `SUM()`, `LAG()`など）。              |
| **OVER()句**       | ウィンドウ関数であることを示し、括弧内でウィンドウの定義を行います。                                |
| **PARTITION BY句** | **(オプション)** データを論理的なグループ（パーティション）に分割します。このパーティション内で関数が独立して計算されます。 |
| **ORDER BY句**     | **(オプション)** 各パーティション内での行の順序を定義します。ランキングや累計計算で非常に重要です。             |
| **ウィンドウフレーム**     | **(オプション)** `ORDER BY`句と組み合わせ、現在の行を中心とした計算範囲（フレーム）を定義します。         |

---

### 3. `PARTITION BY` と `ORDER BY` の挙動

`OVER()`句内の `PARTITION BY` や `ORDER BY` を省略した場合、ウィンドウ関数の挙動は以下のように変化します。

#### 3.1. `PARTITION BY` を省略した場合

`PARTITION BY`句が省略された場合、**クエリ結果セット全体が1つの大きなパーティションとして扱われます。**

**例: テーブル全体のランキング**
`employees` テーブルの全従業員を対象に、給与の高い順にランキングを付けます。

**事前データ:**

| employee_id | employee_name | salary |
| :--- | :--- | :--- |
| 1 | Alice | 5000 |
| 2 | Bob | 6000 |
| 3 | Charlie | 4500 |
| 4 | David | 7000 |

**SQL:**
```sql
SELECT
    employee_name,
    salary,
    ROW_NUMBER() OVER (ORDER BY salary DESC) AS global_rank
FROM
    employees;
```
**実行結果:**

| employee_name | salary | global_rank |
| :--- | :--- | :--- |
| David | 7000 | 1 |
| Bob | 6000 | 2 |
| Alice | 5000 | 3 |
| Charlie | 4500 | 4 |

**解説:**
`PARTITION BY`がないため、全従業員が1つのグループとして扱われ、給与の高い順に連番が割り当てられています。

#### 3.2. `ORDER BY` を省略した場合

`ORDER BY`句が省略された場合、**ウィンドウフレームはパーティション内の全ての行** (`RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`) となります。

**注意点:** `ROW_NUMBER()`や`LAG()`など、順序に依存する関数は非決定的な結果を返す可能性があります。集計関数の場合は、パーティション全体の集計値が各行に表示されます。

**例: 部門ごとの給与合計を各行に表示**
`employees` テーブルで、部門ごとの合計給与を各従業員の行に表示します。

**事前データ:**

| employee_id | employee_name | department | salary |
| :--- | :--- | :--- | :--- |
| 1 | Alice | HR | 5000 |
| 2 | Bob | Sales | 6000 |
| 3 | Charlie | HR | 4500 |
| 4 | David | Sales | 7000 |

**SQL:**
```sql
SELECT
    employee_name,
    department,
    salary,
    SUM(salary) OVER (PARTITION BY department) AS total_department_salary
FROM
    employees;
```
**実行結果:**

| employee_name | department                         | salary      | total_department_salary            |
| :------------ | :--------------------------------- | :---------- | :--------------------------------- |
| Alice         | <font color="#ffc000">HR</font>    | 5000        | <font color="#ffc000">9500</font>  |
| Charlie       | <font color="#ffc000">HR</font>    | 4500        | <font color="#ffc000">9500</font>  |
| Bob           | <font color="#92d050">Sales        | </font>6000 | <font color="#92d050">13000</font> |
| David         | <font color="#92d050">Sales</font> | 7000        | <font color="#92d050">13000</font> |

**解説:**
`ORDER BY`がないため、`PARTITION BY department`で分割された各部門の**全ての行**が計算範囲となり、部門全体の合計給与が計算されています。

---

### 4. ウィンドウフレーム (Window Frame) の詳細

`ORDER BY`句と組み合わせて使用し、各行の計算に含める行の**範囲**をより細かく定義します。

#### 4.1. フレームを構成する要素

**構文:** `{ ROWS | RANGE | GROUPS } BETWEEN <開始点> AND <終了点>`

- **種類**:
    - **`ROWS` (行数ベース)**: 物理的な「行数」でフレームを定義します。
    - **`RANGE` (値ベース)**: `ORDER BY`句で指定された列の「値の範囲」でフレームを定義します。
    - **`GROUPS` (順位グループベース)**: `ORDER BY`句で指定された値の「同順位グループ単位」でフレームを定義します。
- **開始 / 終了点**:
    - `UNBOUNDED PRECEDING`: パーティションの先頭
    - `<N> PRECEDING`: 現在行のN行前
    - `CURRENT ROW`: 現在の行
    - `<N> FOLLOWING`: 現在行のN行後
    - `UNBOUNDED FOLLOWING`: パーティションの末尾

#### 4.2. デフォルトのウィンドウフレーム

- **`ORDER BY` 句がない場合**:
    - `RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING` (パーティション全体)
- **`ORDER BY` 句がある場合**:
    - `RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW` (パーティションの先頭から現在の行まで)

####  4.3. `ROWS`, `RANGE`, `GROUPS` の具体的な比較例

`amount`が同値の行を含むデータで、各フレームタイプの挙動の違いを確認します。

##### ウィンドウ関数ごとに異なる`ORDER BY`を指定する意味

ご提示のSQLのように、1つの`SELECT`句の中で、ウィンドウ関数ごとに異なる`ORDER BY`句を指定することは全く問題ありません。これはウィンドウ関数の非常に強力な特徴です。

- **各ウィンドウ関数は独立している**: `OVER()`句は、それぞれの関数が計算を行うための「独立した計算ルール」を定義します。そのため、ある関数は時系列（`sale_date`）で、別の関数は金額（`amount`）で並べ替えて計算する、といったことが可能です。

- **なぜ`ORDER BY`を変えるのか**: 分析の目的に合わせて最適な「順序」が異なるためです。
    - **`(A) ROWS`の例 (`ORDER BY sale_date, id`)**: 「3日間の移動平均」を計算したい場合、**時間的な前後関係**が最も重要です。そのため、日付順（`sale_date`）で並べるのが自然です。
    - **`(B) RANGE`と`(C) GROUPS`の例 (`ORDER BY amount`)**: こちらは「金額の大小」に基づいた分析をしています。「自分と同じかそれ以下の金額の平均」や「自分より1つ前の金額グループとの比較」を行いたいので、`amount`順で並べる必要があります。

このように、**計算の基準となる「軸（順序）」を関数ごとに柔軟に定義できる**点が、ウィンドウ関数の便利なところです。なお、`SELECT`文の末尾にある`ORDER BY amount, id`は、あくまで最終的な**表示順**を制御するものであり、ウィンドウ関数の計算順序には影響しません。

##### 実行可能なサンプルSQL (`WITH`句を使用)

以下に、コピー＆ペーストしてすぐに実行できる`WITH`句付きのSQLを示します。

```sql
WITH sales_data AS (
    SELECT 1 AS id, '2023-01-01'::date AS sale_date, 100 AS amount UNION ALL
    SELECT 2 AS id, '2023-01-02'::date AS sale_date, 120 AS amount UNION ALL
    SELECT 3 AS id, '2023-01-02'::date AS sale_date, 120 AS amount UNION ALL
    SELECT 4 AS id, '2023-01-03'::date AS sale_date, 110 AS amount UNION ALL
    SELECT 5 AS id, '2023-01-04'::date AS sale_date, 150 AS amount UNION ALL
    SELECT 6 AS id, '2023-01-04'::date AS sale_date, 130 AS amount UNION ALL
    SELECT 7 AS id, '2023-01-05'::date AS sale_date, 140 AS amount
)
SELECT
 id,
 sale_date,
 amount,
 -- (A) ROWS: 物理的な行数でフレームを定義 (現在の行と過去2行)
 -- OVER句のORDER BYはsale_date, idで固定し、物理的な行順を明確にする
 AVG(amount) OVER (
     ORDER BY sale_date, id
     ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
 ) AS avg_rows_3_preceding,

 -- (B) RANGE: ORDER BY amountの値の範囲でフレームを定義 (先頭からCURRENT ROWのamount値まで)
 -- 同一amount値の行はすべてフレームに含まれることに注目
 AVG(amount) OVER (
     ORDER BY amount
     RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
 ) AS avg_range_by_amount_cumulative,

 -- (C) GROUPS: ORDER BY amountの同順位グループ単位でフレームを定義 (現在のグループとその前の1グループ)
 -- ORDER BY amountで、amountの同順位グループを1単位としてフレームに含めることに注目
 AVG(amount) OVER (
     ORDER BY amount
     GROUPS BETWEEN 1 PRECEDING AND CURRENT ROW
 ) AS avg_groups_1_preceding_by_amount

FROM
 sales_data
ORDER BY
 amount, id; -- 結果の表示順はamount, idでソートして、フレームの挙動を確認しやすくする
```

##### 実行結果 (ORDER BY amount, id 順)

| id  | sale_date  | amount | avg\_rows\_3\_preceding | avg\_range\_by\_amount\_cumulative | avg\_groups\_1\_preceding\_by\_amount |
| :-- | :--------- | :----- | :---------------------- | :--------------------------------- | :------------------------------------ |
| 1   | 2023-01-01 | 100    | 100.00                  | 100.0                              | 100.00                                |
| 4   | 2023-01-03 | 110    | 116.67                  | 105.0                              | 105.00                                |
| 2   | 2023-01-02 | 120    | 110.00                  | 112.5                              | 116.67                                |
| 3   | 2023-01-02 | 120    | 113.33                  | 112.5                              | 116.67                                |
| 6   | 2023-01-04 | 130    | 130.00                  | 116.0                              | 123.33                                |
| 7   | 2023-01-05 | 140    | 140.00                  | 120.0                              | 135.00                                |
| 5   | 2023-01-04 | 150    | 126.67                  | 124.28                             | 145.00                                |

##### 各フレームの計算プロセスの詳細解説

- **(A) `avg_rows_3_preceding` (ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)**
    - この計算は **`ORDER BY sale_date, id` という時系列順**に基づいています。
    - **フレーム**: 現在の行と、その物理的に前の2行（合計3行）です。
    - **例 (id=3, amount=120)**:
        - `sale_date, id`順で並べると、この行の前には (id=1), (id=2) が来ます。
        - フレーム対象の`amount`: (100 (id=1), 120 (id=2), 120 (id=3))
        - 平均: (100 + 120 + 120) / 3 = **113.33**
    - **特徴**: 物理的な行数で範囲を厳密に区切るため、移動平均などで直感的に理解しやすいです。

- **(B) `avg_range_by_amount_cumulative` (RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)**
    - この計算は **`ORDER BY amount` という金額順**に基づいています。
    - **フレーム**: `amount`が無限以前から**現在の行の`amount`値と同じかそれよりも小さい**値を持つ全ての行です。
    - **例 (id=2とid=3, amount=120)**:
        - `amount`が120以下の行が全てフレームに含まれます (id=1, 4, 2, 3)。
        - フレーム対象の`amount`: (100 (id=1), 110 (id=4), 120 (id=2), 120 (id=3))
        - 平均: (100 + 110 + 120 + 120) / 4 = **112.5**
    - **特徴**: `ORDER BY`句で指定した値が同じ行はフレームに自動的に含まれます。同順位の値をまとめて扱いたい場合に強力です。

- **(C) `avg_groups_1_preceding_by_amount` (GROUPS BETWEEN 1 PRECEDING AND CURRENT ROW)**
    - この計算も **`ORDER BY amount` という金額順**に基づいています。
    - **フレーム**: `ORDER BY`列の**同順位グループ単位**で定義されます。現在の行が属する同順位グループと、その1つ前の同順位グループです。
    - まず、`amount`による順位グループを考えます:
        - G1: {amount=100}
        - G2: {amount=110}
        - G3: {amount=120}
        - ...
    - **例 (id=2とid=3, amount=120)**:
        - 現在のグループはG3({amount=120})、その前のグループはG2({amount=110})です。
        - フレーム対象の`amount`: (110 (id=4), 120 (id=2), 120 (id=3))
        - 平均: (110 + 120 + 120) / 3 = **116.67**
    - **特徴**: 同順位のグループを1単位として扱うため、ランキングと組み合わせて特定の順位範囲の集計を行いたい場合に便利です。

#### 4.4. `ROWS`, `RANGE`, `GROUPS` の使い分け

| フレームの種類    | 集計範囲の基準              | 主な用途と特徴                                                                  |
| :--------- | :------------------- | :----------------------------------------------------------------------- |
| **ROWS**   | 物理的な行数               | - 直近N件など、**厳密な行数**で範囲を区切りたい場合に最適。<br>- 移動平均、移動合計で頻繁に使用。                  |
| **RANGE**  | `ORDER BY`の値の範囲      | - 日付や数値の**連続する値の範囲**で区切りたい場合に強力。<br>- `ORDER BY`列の値が同じ行は**全てフレームに含まれる**。 |
| **GROUPS** | `ORDER BY`の同順位グループ単位 | - `ORDER BY`列の**同順位グループ**を1単位として範囲を区切りたい場合に便利。<br>- ランキングと組み合わせた集計に有効。   |

---

### 5. ウィンドウ関数の種類


#### 5.1. ランキング関数 (Ranking Functions)

| 関数名              | 説明                                              |
| :--------------- | :---------------------------------------------- |
| **ROW_NUMBER()** | 重複を考慮せず、ユニークな連番を付与します。                          |
| **RANK()**       | 同じ値には同じ順位を付与し、次の順位は同順位の数を飛ばします (1位, 1位, 3位...)。 |
| **DENSE_RANK()** | 同じ値には同じ順位を付与し、次の順位は飛ばさずに連番にします (1位, 1位, 2位...)。 |
| **NTILE(N)**     | 行をN個のほぼ等しいグループに分割し、グループ番号を割り当てます。               |

##### 全ランキング関数の比較例

`scores`テーブルの`score`列を基準に、すべてのランキング関数を一度に適用して違いを確認します。

**実行可能なサンプルSQL:**
```sql
WITH scores AS (
    SELECT 1 AS student_id, 90 AS score UNION ALL
    SELECT 2 AS student_id, 85 AS score UNION ALL
    SELECT 3 AS student_id, 90 AS score UNION ALL
    SELECT 4 AS student_id, 70 AS score UNION ALL
    SELECT 5 AS student_id, 85 AS score
)
SELECT
  student_id,
  score,
  ROW_NUMBER() OVER (ORDER BY score DESC) AS row_num,
  RANK()       OVER (ORDER BY score DESC) AS rank_score,
  DENSE_RANK() OVER (ORDER BY score DESC) AS dense_rank_score,
  NTILE(3)     OVER (ORDER BY score DESC) AS score_tier
FROM
  scores
ORDER BY
  score DESC, student_id;
```

**実行結果:**

| student\_id | score | row\_num | rank\_score | dense\_rank\_score | score\_tier |
| :--- | :-- | :--- | :--- | :--- | :--- |
| 1 | 90 | 1 | 1 | 1 | 1 |
| 3 | 90 | 2 | 1 | 1 | 1 |
| 2 | 85 | 3 | 3 | 2 | 2 |
| 5 | 85 | 4 | 3 | 2 | 2 |
| 4 | 70 | 5 | 5 | 3 | 3 |

**結果の解説:**
- **`row_num`**: `score`が同じでも、ユニークな連番 (1, 2, 3, 4, 5) が振られています。
- **`rank_score`**: 90点が2人いるため、どちらも1位です。次の85点の順位は、同順位の2人を考慮して3位になっています (2位が飛ぶ)。
- **`dense_rank_score`**: 90点が1位の後、85点は順位を詰められて2位になっています。
- **`score_tier`**: 5人の学生を3つのグループに分割しています。5 ÷ 3 = 1 余り 2 なので、最初の2グループが2人ずつ、最後のグループが1人になります。

---

#### 5.2. 値取得関数 (Value-based Functions)

| 関数名                               | 説明                                        |
| :-------------------------------- | :---------------------------------------- |
| **LAG(column, offset, default)**  | `offset`で指定された数だけ**前の行**の`column`の値を返します。 |
| **LEAD(column, offset, default)** | `offset`で指定された数だけ**後の行**の`column`の値を返します。 |
| **FIRST_VALUE(column)**           | ウィンドウフレーム内の**最初の行**の`column`の値を返します。      |
| **LAST_VALUE(column)**            | ウィンドウフレーム内の**最後の行**の`column`の値を返します。      |
| **NTH_VALUE(column, N)**          | ウィンドウフレーム内の**N番目**の行の`column`の値を返します。     |


##### 全値取得関数の比較例

`daily_sales`テーブルを使い、各行から見て他の行の値をどのように取得できるかを確認します。

**実行可能なサンプルSQL:**
```sql
WITH daily_sales AS (
    SELECT '2023-01-01'::date AS sale_date, 100 AS amount UNION ALL
    SELECT '2023-01-02'::date AS sale_date, 120 AS amount UNION ALL
    SELECT '2023-01-03'::date AS sale_date, 110 AS amount UNION ALL
    SELECT '2023-01-04'::date AS sale_date, 150 AS amount UNION ALL
    SELECT '2023-01-05'::date AS sale_date, 130 AS amount
)
SELECT
  sale_date,
  amount,
  -- 1行前の値を取得 (存在しない場合は0)
  LAG(amount, 1, 0) OVER (ORDER BY sale_date) AS previous_day_amount,
  -- 1行後の値を取得 (存在しない場合は0)
  LEAD(amount, 1, 0) OVER (ORDER BY sale_date) AS next_day_amount,
  -- パーティション全体の最初の値を取得
  FIRST_VALUE(amount) OVER (ORDER BY sale_date),
  -- パーティション全体の最後の値を取得 (※フレーム指定が重要)
  LAST_VALUE(amount) OVER (
    ORDER BY sale_date
    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
  ) AS last_overall_amount,
  -- パーティション全体の2番目の値を取得 (※フレーム指定が重要)
  NTH_VALUE(amount, 2) OVER (
    ORDER BY sale_date
    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
  ) AS second_overall_amount
FROM
  daily_sales
ORDER BY
  sale_date;
```

**実行結果:**

| sale\_date | amount | previous\_day\_amount | next\_day\_amount | first\_value | last\_overall\_amount | second\_overall\_amount |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 2023-01-01 | 100 | 0 | 120 | 100 | 130 | 120 |
| 2023-01-02 | 120 | 100 | 110 | 100 | 130 | 120 |
| 2023-01-03 | 110 | 120 | 150 | 100 | 130 | 120 |
| 2023-01-04 | 150 | 110 | 130 | 100 | 130 | 120 |
| 2023-01-05 | 130 | 150 | 0 | 100 | 130 | 120 |

**結果の解説:**
- **`previous_day_amount`**: `LAG`関数により、1行前の`amount`を取得します。初日には前の行がないため、デフォルト値の`0`が入ります。
- **`next_day_amount`**: `LEAD`関数により、1行後の`amount`を取得します。最終日には後の行がないため、デフォルト値の`0`が入ります。
- **`first_value`**: `ORDER BY sale_date`で並べた際の最初の値`100`が全ての行で返されます。
- **`last_overall_amount`**: `LAST_VALUE`関数でパーティション全体（この場合は全データ）の最後の値を取得するために、`ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`でフレームを明示的に指定しています。これにより、最終日の値`130`が全ての行で返されます。
- **`second_overall_amount`**: `NTH_VALUE`関数も同様にフレームを指定することで、パーティション全体の2番目の値`120`を全ての行で取得しています。

**💡 重要ポイント**
`LAST_VALUE`や`NTH_VALUE`は、デフォルトのフレーム（`RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`）では「パーティションの先頭から現在の行まで」しか見ないため、期待通りの結果を得るには上記のように**フレームを明示的に指定する**ことが非常に重要です。

#### 5.3. 集計関数 (Aggregate Window Functions)

`SUM()`, `AVG()`, `COUNT()`, `MIN()`, `MAX()`などの集計関数を`OVER()`句と共に使用することで、グループ内の集計値を各行に表示できます。

---

#### **💡 実務で頻出のシナリオ①: 累計売上 (Running Total)**
BIツールやレポート作成で非常によく使われるのが、時系列データにおける累計値の計算です。

**例: 顧客ごとの注文の累計購入額**
```sql
SELECT
  customer_id, order_date, amount,
  SUM(amount) OVER (PARTITION BY customer_id ORDER BY order_date) AS cumulative_amount
FROM orders;
```
**実行結果:**

| customer\_id | order\_date | amount | cumulative\_amount |
| :--- | :--- | :--- | :--- |
| 1 | 2023-01-01 | 100 | 100 |
| 1 | 2023-01-05 | 150 | 250 |
| 1 | 2023-01-10 | 200 | 450 |
| 2 | 2023-01-01 | 50 | 50 |
| 2 | 2023-01-07 | 70 | 120 |

#### **💡 実務で頻出のシナリオ②: 移動平均 (Moving Average)**
時系列データにおいて、特定期間内の平均値を計算し、トレンドを滑らかにする分析手法です。

**例: 日次売上の3日間移動平均**
```sql
SELECT
  sale_date, amount,
  AVG(amount) OVER (
    ORDER BY sale_date
    ROWS BETWEEN 2 PRECEDING AND CURRENT ROW -- 現在の行と過去2行
  ) AS three_day_moving_avg
FROM daily_sales;
```
**実行結果:**

| sale\_date | amount | three\_day\_moving\_avg |
| :--- | :--- | :--- |
| 2023-01-01 | 100 | 100.0 |
| 2023-01-02 | 120 | 110.0 |
| 2023-01-03 | 110 | 110.0 |
| 2023-01-04 | 150 | 126.67 |

---

### 6. 補足情報


### 6.1. PostgreSQL ウィンドウ関数 詳細分類表

この表は、ウィンドウ関数を使用する際に「どの句（`PARTITION BY`, `ORDER BY`, フレーム）がどのように影響を与えるか」を理解するためのガイドです。

| 関数分類 | 関数名 | `PARTITION BY` | `ORDER BY` | ウィンドウフレーム | 主な用途 / 備考 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **ランキング関数** | `ROW_NUMBER()`<br>`RANK()`<br>`DENSE_RANK()`<br>`NTILE()` | **任意**<br>指定した列でグループ化し、その中で順位付けを行う。 | **必須**<br>順位付けの基準となる順序を定義します。これがないと順位が決まりません。 | **影響を受けない**<br>フレームを指定しても計算結果は変わりません。 | - `ROW_NUMBER()`: 重複なしの連番。<br>- `RANK()`: ギャップあり順位。<br>- `DENSE_RANK()`: ギャップなし順位。<br>- `NTILE(n)`: n分割のグループ分け。 |
| **値取得関数** | `LAG()`<br>`LEAD()` | **任意**<br>グループごとに前後の行を判断します。 | **必須（実質的）**<br>「前後の行」を定義するために必須です。省略すると非決定的な結果になります。 | **影響を受けない**<br>フレームではなく、`ORDER BY`で定義された行順のみを参照します。 | - `LAG(col, offset, default)`: N行前の値。<br>- `LEAD(col, offset, default)`: N行後の値。<br>- 前日比、翌日比の計算で多用されます。 |
| | `FIRST_VALUE()`<br>`LAST_VALUE()`<br>`NTH_VALUE()` | **任意**<br>グループごとにフレーム内の値を判断します。 | **必須**<br>フレーム内の「最初/最後/N番目」を決める順序を定義します。 | **影響を強く受けます**<br>計算対象の範囲そのものを定義します。<br>**デフォルト:** `RANGE ... CURRENT ROW`<br>**注意:** `LAST_VALUE`や`NTH_VALUE`でパーティション全体の値を扱いたい場合は、`ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING` のように**明示的なフレーム指定がほぼ必須**です。 | - `FIRST_VALUE`: フレーム内の最初の値。<br>- `LAST_VALUE`: フレーム内の最後の値。<br>- `NTH_VALUE(col, n)`: フレーム内のn番目の値。 |
| **集計関数** | `SUM()`<br>`AVG()`<br>`COUNT()`<br>`MAX()`<br>`MIN()` | **任意**<br>グループごとに集計を行います。 | **任意**<br>**省略した場合:** パーティション全体が集計対象になります。<br>**指定した場合:** 累計や移動集計になります（デフォルトフレームの挙動が変わるため）。 | **影響を強く受けます**<br>集計範囲を定義します。<br>**`ORDER BY`なしの場合:** デフォルトはパーティション全体 (`RANGE ... UNBOUNDED FOLLOWING`)。<br>**`ORDER BY`ありの場合:** デフォルトは累計範囲 (`RANGE ... CURRENT ROW`)。<br>移動平均などでは`ROWS`句で明示的に指定します。 | - `ORDER BY`なし: グループ全体の合計/平均など。<br>- `ORDER BY`あり: 累計合計/平均など。<br>- `ROWS`句使用: 移動合計/平均など。 |