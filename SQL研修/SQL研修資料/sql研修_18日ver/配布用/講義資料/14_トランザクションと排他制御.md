## PostgreSQL トランザクション実践入門

この資料は、PostgreSQLにおけるトランザクションの基本から、複数のトランザクションが同時に実行される際の挙動（同時実行制御）までを、具体的なシナリオを交えて解説します。

### 第1章: トランザクションの基本

#### 1-1. トランザクションとは？

トランザクションとは、**関連する一連の処理を一つにまとめた、処理の単位**です。この単位内の処理は、「すべて成功する」か「すべて失敗する」かのどちらかであることが保証されます（**原子性: Atomicity**）。これにより、データベースのデータが中途半半端な状態になることを防ぎます。

**例：銀行の口座振込**  
Aさんの口座からBさんの口座へ1万円を送金する場合、以下の2つの処理が必要です。

1. Aさんの口座残高を1万円減らす (`UPDATE`)
2. Bさんの口座残高を1万円増やす (`UPDATE`)

トランザクションは、これら2つの処理を一つの固まりとして扱い、途中でシステム障害などが起きてもデータの不整合が発生しないように保護します。

#### 1-2. トランザクションのACID特性

信頼性の高いトランザクションは、以下の4つの特性（ACID）を満たします。

| 特性 | 英語 | 説明 |
| :--- | :--- | :--- |
| **原子性** | Atomicity | 処理が「すべて成功」か「すべて失敗」のどちらかになる。 |
| **一貫性** | Consistency | 処理の前後でデータベースのルール（制約など）が守られる。 |
| **独立性** | Isolation | 複数のトランザクションが互いに干渉せず、独立して実行されるように見える。 |
| **永続性** | Durability | 成功したトランザクションの結果は、障害が発生しても失われない。 |

#### 1-3. 基本的なSQLコマンド

*   **`BEGIN`**: トランザクションを開始します。
*   **`COMMIT`**: すべての変更をデータベースに恒久的に反映し、トランザクションを終了します。
*   **`ROLLBACK`**: すべての変更を破棄し、トランザクション開始前の状態に戻して終了します。

```sql
-- トランザクションの開始
BEGIN;

-- 処理...
UPDATE accounts SET balance = balance - 100.00 WHERE name = 'Alice';
UPDATE accounts SET balance = balance + 100.00 WHERE name = 'Bob';

-- 変更を確定
COMMIT;
```

#### 1-4.セーブポイントによる部分的なロールバック

複雑なトランザクションの途中で、特定の部分だけを取り消したい場合があります。これを実現するのが**セーブポイント**です。

- **`SAVEPOINT savepoint_name`**: トランザクション内に「セーブポイント」という名前付きの目印を設定します。
- **`ROLLBACK TO SAVEPOINT savepoint_name`**: 指定したセーブポイント以降の処理を取り消し、セーブポイントを設定した時点の状態に戻します。
- **`RELEASE SAVEPOINT savepoint_name`**: セーブポイントを削除します。

```sql
BEGIN;

UPDATE inventory SET quantity = quantity - 1 WHERE product_id = 101;
SAVEPOINT after_inventory_update; -- セーブポイントを設定

-- このINSERTでエラーが発生したと仮定
INSERT INTO order_history (customer_id, product_id) VALUES (1, 101); 

-- エラー発生時、在庫更新後まで処理を戻す
ROLLBACK TO SAVEPOINT after_inventory_update;

-- 代替処理を実行
INSERT INTO order_history (customer_id, product_id) VALUES (1, 202);

COMMIT;
```

#### 1-5.トランザクションのネスト（入れ子）について

**PostgreSQLでは、トランザクションを入れ子にすること（ネストトランザクション）はできません。**

`BEGIN`コマンドでトランザクションを開始した後に、そのトランザクションが終了（`COMMIT`または`ROLLBACK`）する前に、再び`BEGIN`コマンドを実行しても新しいトランザクションは開始されません。代わりに、以下のような警告メッセージが表示されます。

```
WARNING:  there is already a transaction in progress
```

この場合、2回目以降の`BEGIN`は無視され、最初の`BEGIN`から始まる一つのトランザクションが継続します。実質的にセーブポイントのように振る舞いますが、この挙動は混乱を招く可能性があるため、意図的にトランザクションを入れ子にしようとすることは避けるべきです。トランザクションの途中に部分的な区切りを設けたい場合は、前述のセーブポイントを使用してください。

### 第2章: トランザクション分離レベル

複数のトランザクションを同時に実行した際に、互いにどの程度影響を許容するかを設定するのが**トランザクション分離レベル**です。これによりACIDの「独立性（Isolation）」の度合いを調整します。

#### 2-1. 主な分離レベルと発生しうる問題

| 分離レベル | ダーティリード | ノンリピータブルリード | ファントムリード |
| :--- | :--- | :--- | :--- |
| Read Uncommitted | 発生する | 発生する | 発生する |
| **Read Committed (デフォルト)** | 防ぐ | **発生しうる** | **発生しうる** |
| Repeatable Read | 防ぐ | 防ぐ | **発生しうる** |
| Serializable | 防ぐ | 防ぐ | 防ぐ |

*   **ダーティリード**: コミットされていない変更を他のトランザクションが読んでしまう現象。
*   **ノンリピータブルリード**: 同一トランザクション内で同じ行を2回読んだ際に、結果が異なる現象（他トランザクションによる更新が原因）。
*   **ファントムリード**: 同一トランザクション内で特定の範囲を2回読んだ際に、行が増減している現象（他トランザクションによる挿入が原因）。

#### 2-2. なぜ `Read Committed` がデフォルトなのか？

`Read Committed` は、コミット済みのデータしか読み取らないためダーティリードを防ぎつつ、厳格すぎないため高い同時実行性能を維持できます。多くのWebアプリケーションでは、同一トランザクション内で全く同じSQLを2回実行するケースは稀なため、ノンリピータブルリードが問題になることは少ないです。この**性能とデータ一貫性のバランスの良さ**から、PostgreSQLのデフォルトとなっており、実務でも最も広く使われています。
**以降の章は、この `Read Committed` レベルを前提として解説します。**

### 第3章: 同時実行制御とロックの挙動

PostgreSQLは**MVCC**（多版型同時実行制御）という仕組みと**ロック**を組み合わせて、高い同時実行性とデータ整合性を両立しています。

*   **MVCC**: 更新時に古いデータをすぐ消さず、トランザクションごとに適切なバージョンのデータを見せる仕組み。これにより、**読み取り（`SELECT`）と書き込み（`UPDATE`）が互いにブロックしません**。
*   **ロック**: 同じデータを同時に変更しようとする競合を防ぐ仕組み。ロックは**行単位**で取得され、**トランザクション終了（`COMMIT`/`ROLLBACK`）まで**保持されます。

#### **排他ロック (Exclusive Lock)**

*   **目的**: ある行を**変更・削除する権利を独占**します。
*   **取得方法**:
    *   `UPDATE`, `DELETE`文を実行すると、対象行に**自動で**取得されます。
    *   `SELECT ... FOR UPDATE`文で、読み取りと同時に**意図的に**取得することもできます。

#### **共有ロック (Shared Lock)**

*   **目的**: 「**今からこの行を参照するので、私の処理が終わるまで誰にも変更させないでほしい**」という、読み取りの一貫性を保証するために使います。
*   **取得方法**:
    *   `SELECT ... FOR SHARE`文で**意図的に**取得します。**この構文を明示的に書かない限り、共有ロックは取得されません。**
*   **共有ロックの存在意義**:
    `FOR UPDATE`（排他ロック）は変更だけでなく他の参照（`FOR SHARE`）もブロックしてしまい、同時実行性を下げる場合があります。共有ロックは、**データの変更（`UPDATE`等）は防ぎたいが、他のトランザクションによる参照（`SELECT`や`FOR SHARE`）は許可したい**、という場合に最適です。例えば、親子関係にある複数のテーブルを参照して整合性をチェックする際、チェック中に親や子のデータが変更・削除されるのを防ぐために使われます。

#### 3-1. 【時系列シナリオ1】排他ロック (`FOR UPDATE`) による在庫更新

**状況**: 在庫1個の商品を、2つのトランザクション(T1, T2)がほぼ同時に購入しようとする。

| 時刻 | トランザクション1 (T1) | トランザクション2 (T2) | データベースの状態（商品A） |
| :--- | :--- | :--- | :--- |
| 1 | `BEGIN;` | | 在庫: 1 |
| 2 | `SELECT * FROM products WHERE id=A FOR UPDATE;` <br>→ **商品Aの行に排他ロックを獲得。** | | 在庫: 1, T1がロック中 |
| 3 | | `BEGIN;` | 在庫: 1, T1がロック中 |
| 4 | | `SELECT * FROM products WHERE id=A FOR UPDATE;` <br>→ T1が排他ロック中のため、**待機状態になる。** | 在庫: 1, T1がロック中, T2は待機 |
| 5 | `UPDATE products SET stock = 0 WHERE id=A;` | (待機中) | 在庫: 0 (T1内), T1がロック中, T2は待機 |
| 6 | `COMMIT;` <br>→ 変更が確定し、**ロックが解放される。** | (待機中) | 在庫: 0（確定） |
| 7 | | (待機が解除され処理再開) <br> `SELECT`の結果、在庫0を取得。 | 在庫: 0 |
| 8 | | 在庫がないため購入処理を中止し`ROLLBACK;` | 在庫: 0 |

**解説**: 先に `FOR UPDATE` で排他ロックを取得したT1が処理を完了するまでT2は待たされるため、在庫の二重引き当てが防がれます。

#### 3-2. 【時系列シナリオ2】排他ロック中でも `SELECT` は可能（MVCCの挙動）

**状況**: T1が商品の価格を更新中、T2がその商品の価格を参照しようとする。

| 時刻 | トランザクション1 (T1: 価格更新) | トランザクション2 (T2: 価格参照) | 解説 |
| :--- | :--- | :--- | :--- |
| 1 | `BEGIN;` | | T1がトランザクション開始。 |
| 2 | `UPDATE products SET price = 120 WHERE id=A;` <br>→ **商品Aの行に排他ロックを獲得。** | | T1内で価格は120になったが、まだ未コミット。 |
| 3 | | `BEGIN;` | T2がトランザクション開始。 |
| 4 | (他の処理を継続中...) | `SELECT price FROM products WHERE id=A;` | **T2は待たされない！** T1の変更は未コミットなので、**T2は変更前のコミット済みデータ（価格100）を参照する。** |
| 5 | | → **結果として「100」が返る。** | これがMVCCの力。読み取りはブロックされない。 |
| 6 | `COMMIT;` <br>→ 変更が確定し、**ロックが解放される。** | | |
| 7 | | `SELECT price FROM products WHERE id=A;` <br>→ 再度SELECTを実行。 | T1のコミット後なので、最新のデータが参照できる。 |
| 8 | | → **結果として「120」が返る。** | |

**解説**: 排他ロックがブロックするのは**他のトランザクションによる変更やロック取得**であり、ロックなしの単純な`SELECT`はブロックしません。

#### 3-3. 【時系列シナリオ3】共有ロック (`FOR SHARE`) による一貫性読み取り

**状況**: T1が部署の全従業員の給与を計算中（計算中に給与が変わってほしくない）、T2がその部署の一人の従業員の給与を昇給させようとする。

| 時刻 | トランザクション1 (T1: 給与集計) | トランザクション2 (T2: 給与更新) | 解説 |
| :--- | :--- | :--- | :--- |
| 1 | `BEGIN;` | | |
| 2 | `SELECT * FROM employees WHERE dept_id=10 FOR SHARE;` <br>→ **部署10の全従業員行に共有ロックを獲得。** | | T1は集計対象のデータを保護。 |
| 3 | | `BEGIN;` | |
| 4 | (取得したデータで給与合計を計算中...) | | 他のトランザクションはこれらの行を`FOR SHARE`で読むことは可能。 |
| 5 | | `UPDATE employees SET salary = 5500 WHERE id=101;` | T1が共有ロック中の行を変更（排他ロックを要求）しようとしたため、**待機状態になる。** |
| 6 | (計算が完了し処理を終える) | (待機中) | |
| 7 | `COMMIT;` <br>→ **共有ロックが全て解放される。** | (待機中) | |
| 8 | | (待機が解除され、UPDATE処理が実行される) | T1の処理が終わったので、更新処理が再開される。 |

**解説**: `FOR SHARE`は、**データの変更はブロックしつつ、他のトランザクションによる参照は許可する**という、整合性と同時実行性を両立した制御を可能にします。

#### 3-4. 【時系列シナリオ4】デッドロックの発生

排他制御において注意すべき状態が**デッドロック**です。これは、2つのトランザクションがお互いに相手が確保しているロックの解除を待ち続け、永久に処理が進まなくなる状態です。

**状況**: T1は商品A→Bの順、T2は商品B→Aの順で在庫を更新しようとする。

| 時刻 | トランザクション1 (T1) | トランザクション2 (T2) |
| :--- | :--- | :--- |
| 1 | `BEGIN;` | |
| 2 | `UPDATE products SET stock=stock-1 WHERE id=A;`<br>→ **商品Aを排他ロック。** | |
| 3 | | `BEGIN;` |
| 4 | | `UPDATE products SET stock=stock-1 WHERE id=B;`<br>→ **商品Bを排他ロック。** |
| 5 | `UPDATE products SET stock=stock-1 WHERE id=B;`<br>→ T2がロック中のため**待機状態に。** | |
| 6 | | `UPDATE products SET stock=stock-1 WHERE id=A;`<br>→ T1がロック中のため**待機状態に。** |

**結果**: T1はT2のロック解除を待ち、T2はT1のロック解除を待つという**相互待ち状態（デッドロック）**に陥ります。この状態を検知したPostgreSQLは、どちらかのトランザクションを強制的にエラーにし、`ROLLBACK`させることでデッドロックを解消します。

**対策**: アプリケーション側で、複数のリソースを更新する際は常に同じ順序（例: IDの昇順）でロックを取得するようにルールを統一することで、デッドロックの発生確率を大幅に下げることができます。