## **PostgreSQL集計関数とグループ化マスターガイド**

### **1. 集計とグループ化の目的**

PostgreSQLに格納された大量のデータからビジネスの意思決定に役立つ洞察を得るためには、データを要約し、傾向を把握することが不可欠です。そのために「集計」と「グループ化」という強力な機能が用意されています。

*   **集計**: 複数のデータ行から合計値や平均値といった単一の要約値を計算します。
*   **グループ化**: データを特定の基準（例：カテゴリ別、部署別）でグループに分割し、そのグループごとに集計を行います。

### **2. 基本的な集計関数**

集計関数は、複数の行の値をまとめて計算し、1つの結果を返します。`SELECT`句や`HAVING`句で使用されます。

#### **COUNT()：行数を数える**

指定した条件に合致する行の数を数えます。

*   `COUNT(*)`: **テーブルの全行数**を返します。NULL値も含まれます。
*   `COUNT(column_name)`: 指定した列で **NULLではない値**の数を返します。
*   `COUNT(DISTINCT column_name)`: 指定した列で **重複を除いたNULLではない値**の数を返します。

**使用例 (`products` テーブル)**
```sql
-- テーブルの総商品数を取得
SELECT COUNT(*) AS total_products FROM products;

-- 価格が設定されている（NULLではない）商品数を取得
SELECT COUNT(price) AS products_with_price FROM products;

-- 商品カテゴリの種類の数を取得
SELECT COUNT(DISTINCT category) AS unique_categories FROM products;
```

> **💡コラム: `COUNT(1)` と `COUNT(*)` の違いは？**
> 結論から言うと、現代のPostgreSQLにおいて、**機能的・パフォーマンス的な違いはほとんどありません**。どちらもテーブルの全行数をカウントします。`COUNT(*)` の方がSQL標準で意図が分かりやすいため、一般的に使用が推奨されます。

---

#### **SUM()：合計値を計算する**

数値列の合計値を算出します。計算の過程でNULL値は無視されます。

**使用例**
```sql
-- 全商品の在庫数の合計を算出
SELECT SUM(stock_quantity) AS total_stock FROM products;
```

---

#### **AVG()：平均値を計算する**

数値列の平均値を算出します。分母・分子の計算においてNULL値は除外されます。

**使用例**
```sql
-- 全商品の平均価格を算出
SELECT AVG(price) AS average_price FROM products;
```

---

#### **MIN() / MAX()：最小値・最大値を求める**

指定した列の最小値または最大値を求めます。数値だけでなく、文字列や日付型にも使用できます。

**使用例**
```sql
-- 最も高価な商品の価格を取得
SELECT MAX(price) AS max_price FROM products;

-- アルファベット順で最も先頭に来る商品名を取得
SELECT MIN(product_name) AS first_product_name FROM products;
```

---

#### **集計関数におけるNULLの扱い**

`COUNT(*)`を除くほとんどの集計関数 (`SUM`, `AVG`, `MIN`, `MAX`, `COUNT(列名)`) は、**計算の対象からNULL値を自動的に除外します**。

特に`AVG`関数では注意が必要です。例えば `(100 + 200 + NULL) / 3` ではなく `(100 + 200) / 2` のように計算されます。もしNULLを0として扱いたい場合は、`AVG(COALESCE(列名, 0))` のように関数を組み合わせる必要があります。

### **3. PostgreSQLで便利な応用集計関数**

基本的なものに加え、PostgreSQLにはより高度な集計を可能にする便利な関数があります。

#### **STRING_AGG()：文字列を連結する**

グループ化された複数の行の文字列を、指定した区切り文字で連結して一つの文字列にします。

**使用例 (カテゴリごとに商品名をカンマ区切りでリスト化)**
```sql
SELECT
  category,
  STRING_AGG(product_name, ', ') AS product_list
FROM products
GROUP BY category;
```

---

#### **ARRAY_AGG()：値を配列にする**

グループ化された複数の行の値を、一つの配列（Array型）にまとめて返します。

**使用例 (カテゴリごとに商品IDを配列で取得)**
```sql
SELECT
  category,
  ARRAY_AGG(product_id ORDER BY product_name) AS product_ids
FROM products
GROUP BY category;
```
*`ORDER BY`を内部で指定することで、配列内の順序を制御できます。*

---

#### **BOOL_AND() / BOOL_OR()：真偽値（Boolean）を集計する**

Boolean型の列を集計するための関数です。

*   `BOOL_AND(expression)`: グループ内の全ての値が`true`であれば`true`を返します（論理積）。
*   `BOOL_OR(expression)`: グループ内に一つでも`true`があれば`true`を返します（論理和）。

**使用例 (カテゴリ内の全ての商品が公開中（is_public=true）か判定)**
```sql
SELECT
  category,
  BOOL_AND(is_public) AS all_products_public
FROM products
GROUP BY category;
```

### **4. データのグループ化と絞り込み**

#### **GROUP BY句：データをグループに分割**

指定した列の値が同じ行を一つのグループにまとめ、そのグループごとに集計関数を適用します。

**重要なルール**: `SELECT`句に集計関数を使わない列を記述する場合、その列は**必ず`GROUP BY`句にも含める必要があります**。

**使用例 (カテゴリごとの商品数と平均価格を算出)**
```sql
SELECT
  category,
  COUNT(*) AS product_count,
  AVG(price) AS average_price
FROM products
GROUP BY category;
```

> **💡コラム: PostgreSQLにおける厳格なGROUP BYルール**
> PostgreSQLはSQL標準に準拠しており、`SELECT`句に指定された非集計列は必ず`GROUP BY`句に含める必要があります。これは、グループごとにどの行の値を返すべきか一意に定まらないためです。この厳格なルールにより、意図しない値が返されることを防ぎ、クエリの信頼性を高めています。

---

#### **HAVING句：グループ化後の結果を絞り込む**

`GROUP BY`句で集計された**結果に対して**条件を指定し、さらに絞り込みを行う場合に使用します。`HAVING`句では集計関数を条件として利用できます。

**使用例 (商品数が10個以上あるカテゴリのみを抽出)**
```sql
SELECT
  category,
  COUNT(*) AS product_count
FROM products
GROUP BY category
HAVING COUNT(*) >= 10;
```

### **5. SQLの評価順序とWHERE句・HAVING句の違い**

SQLクエリは記述する順番と、内部で評価される順番が異なります。この違いを理解することが`WHERE`と`HAVING`を正しく使い分ける鍵となります。

#### **SQLの評価順序（概念）**

1.  **`FROM` / `JOIN`**: 対象テーブルを決定
2.  **`WHERE`**: **行の絞り込み (グループ化の前)**
3.  **`GROUP BY`**: グループ化
4.  **`HAVING`**: **グループの絞り込み (グループ化の後)**
5.  **`SELECT`**: 列の選択、式の評価
6.  **`ORDER BY`**: 結果の並び替え
7.  **`LIMIT` / `OFFSET`**: 表示行の制限

| 特徴 | WHERE句 | HAVING句 |
| :--- | :--- | :--- |
| **評価タイミング** | `GROUP BY`の前（個々の行が対象） | `GROUP BY`の後（グループが対象） |
| **使用できる要素** | 元テーブルの列 | `GROUP BY`で指定した列、**集計関数** |
| **目的** | 集計対象となる行を事前にフィルタリング | 集計結果を元にグループをフィルタリング |

**実践例**
在庫が10より多い商品を対象に、カテゴリごとの平均価格を算出し、その平均価格が500を超えるカテゴリのみを抽出する場合。

```sql
SELECT
  category,
  AVG(price) AS average_price
FROM products
WHERE stock_quantity > 10 -- (1) まず個々の行を絞り込む
GROUP BY category
HAVING AVG(price) > 500;  -- (2) 次に集計結果でグループを絞り込む
```