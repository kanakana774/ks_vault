※下記に該当しないパターンもありますが、まずはよく使われるパターンを覚える方向性でいいかと思います。また、このパターン以外の書き方は可読性やパフォーマンス的にもあまり良くないため、目にする機会もあまりないかと思います。

---
### パターン1：「存在チェック」を「絞り込み条件」に使う (`WHERE` + `EXISTS`)

このパターンは、「～したことがある」「～に紐づくデータがある」といった、**関連データの有無**で行を絞り込みたいときに使います。

**【シナリオ】**
「一度でも退会したことがあるユーザーを、現在の会員リストから除外したい」（＝退会したことがないユーザーだけを取得する）

---

#### 思考の流れ

**Step 1: 要件を「データの言葉」に翻訳する**
*   **最終的に欲しいもの**: 現在の会員 (`users`) のリスト。
*   **絞り込み条件**: その会員が、「退会テーブル (`withdrawals`)」に**レコードが存在しない**こと。
*   **キーワード**: 「存在しない」「レコードがない」。ここから「存在チェック」だと判断する。

**Step 2: パターンを特定する**
*   役割は**存在チェック**である。
*   その結果を使って行を**絞り込み**たい。
*   この組み合わせから、**パターン1 (`WHERE` + `NOT EXISTS`)** を使うと決定する。

**Step 3: クエリを「外側」から組み立てる**
1.  **【主役を決める】** 主役は `users` テーブル。
    ```sql
    SELECT u.id, u.name FROM users u WHERE ...
    ```

2.  **【各行に対する条件を考える】** 外側の行 `u` に対して、「`u` と同じIDが `withdrawals` テーブルに存在するか？」を確認するサブクエリを作る。
    ```sql
    (SELECT 1 FROM withdrawals w WHERE u.id = w.user_id)
    ```

3.  **【外と内を関連付ける】** 上記の通り、`u.id = w.user_id` で関連付けは完了。

**Step 4: SQLを完成させる**
`WHERE`句に `NOT EXISTS` と組み合わせてサブクエリを配置する。

**事前データ:**
`users`テーブル

| id | name |
| :--- | :--- |
| 1 | Alice |
| 2 | Bob |
| 3 | Charlie |

`withdrawals`テーブル

| withdrawal_id | user_id |
| :--- | :--- |
| 101 | 2 |

```sql
WITH users AS (
  SELECT 1 AS id, 'Alice' AS name UNION ALL
  SELECT 2, 'Bob' UNION ALL
  SELECT 3, 'Charlie'
),
withdrawals AS (
  SELECT 101 AS withdrawal_id, 2 AS user_id
)
SELECT
    u.id,
    u.name
FROM
    users u
WHERE
    NOT EXISTS (
        -- このユーザーID(u.id)が、退会テーブルに存在しないかチェック
        SELECT 1
        FROM withdrawals w
        WHERE u.id = w.user_id
    );
```

**実行結果:**

| id | name |
| :--- | :--- |
| 1 | Alice |
| 3 | Charlie |

---

### パターン2：「取得した値との比較」を「絞り込み条件」に使う (`WHERE` + 比較演算子)

このパターンは、「**自分が属するグループの**平均/最大値より大きい」など、外側の行に**関連する**集計値と比較して絞り込みたいときに使います。

**【シナリオ】**
「商品が所属するカテゴリの**平均価格よりも高い**価格が設定されている商品をリストアップしたい」

---

#### 思考の流れ

**Step 1: 要件を「データの言葉」に翻訳する**
*   **最終的に欲しいもの**: 商品 (`products`) のリスト。
*   **絞り込み条件**: その商品の価格が、**「その商品が属するカテゴリの平均価格」**よりも高いこと。
*   **キーワード**: 「カテゴリごとの平均」「グループ内の比較」。

**Step 2: パターンを特定する**
*   役割は**「値の取得と比較」**である。
*   その結果を使って行を**「絞り込み」**たい。
*   これは**相関サブクエリ**のパターン2 (`WHERE` + `比較演算子`) を使うと決定する。

**Step 3: クエリを「外側」から組み立てる**
1.  **【主役を決める】** 主役は `products` テーブル (`p1`)。
    ```sql
    SELECT p1.product_name, p1.price, p1.category_id FROM products p1 WHERE ...
    ```
2.  **【各行に対する条件を考える】** 外側の行 `p1` に対して、「`p1`と同じカテゴリの商品群の平均価格」を計算するサブクエリを作る。
    ```sql
    (SELECT AVG(p2.price) FROM products p2 WHERE ...)
    ```
3.  **【外と内を関連付ける】** `p1.category_id = p2.category_id` で関連付ける。

**Step 4: SQLを完成させる**
`WHERE`句で、外側の価格 `p1.price` と相関サブクエリの結果を比較する。

**事前データ (products):**

| product_name | price | category_id |
| :--- | ---: | ---: |
| Laptop | 1200.00 | 1 |
| Mouse | 100.00 | 1 |
| Keyboard | 200.00 | 1 |
| Headset | 150.00 | 2 |
| Webcam | 90.00 | 2 |

```sql
WITH products AS (
  SELECT 'Laptop' AS product_name, 1200.00 AS price, 1 AS category_id UNION ALL
  SELECT 'Mouse', 100.00, 1 UNION ALL
  SELECT 'Keyboard', 200.00, 1 UNION ALL
  SELECT 'Headset', 150.00, 2 UNION ALL
  SELECT 'Webcam', 90.00, 2
)
SELECT
    p1.product_name,
    p1.price,
    p1.category_id
FROM
    products p1
WHERE
    p1.price > (
        -- p1の行のカテゴリIDと一致する商品の平均価格を計算
        SELECT AVG(p2.price)
        FROM products p2
        WHERE p1.category_id = p2.category_id
    );
```

**実行結果:**

| product_name | price | category_id |
| :--- | ---: | ---: |
| Laptop | 1200.00 | 1 |
| Headset | 150.00 | 2 |

---

### パターン3：「取得した値」を「新しい列」として使う (`SELECT` + スカラーサブクエリ)

このパターンは、「各レコードにサマリー情報を付け加えたい」など、**関連する情報を1つの値として取得し、新しい列として表示**したいときに使います。

**【シナリオ】**
「顧客リストに、それぞれの顧客の**直近の購入日**を併記して表示したい」

---

#### 思考の流れ

**Step 1: 要件を「データの言葉」に翻訳する**
*   **最終的に欲しいもの**: 顧客 (`customers`) のリスト。
*   **追加したい情報**: 各顧客に対して、「その顧客の最新の注文日」を**新しい列として表示**したい。
*   **キーワード**: 「～を併記して」「～を列として追加」。

**Step 2: パターンを特定する**
*   役割は**「値の取得」**である。
*   その結果を**「新しい列として表示」**したい。
*   この組み合わせから、**パターン3 (`SELECT` + スカラーサブクエリ)** を使うと決定する。

**Step 3: クエリを「外側」から組み立てる**
1.  **【主役を決める】** 主役は `customers` テーブル。`SELECT`句にサブクエリ用の場所を確保する。
    ```sql
    SELECT c.name, (...) AS latest_order_date FROM customers c
    ```
2.  **【各行に対する条件を考える】** 外側の行 `c` に対して、「`c` の注文の中で最新の日付」を計算するサブクエリを作る。
    ```sql
    (SELECT MAX(o.order_date) FROM orders o WHERE ...)
    ```
3.  **【外と内を関連付ける】** `c.id = o.customer_id` で関連付ける。

**Step 4: SQLを完成させる**
`SELECT`句に、完成した相関サブクエリを配置する。

**事前データ:**
`customers`テーブル

| id | name |
| :--- | :--- |
| 1 | Alice |
| 2 | Bob |
| 3 | Charlie |

`orders`テーブル

| order_id | customer_id | order_date |
| :--- | :--- | :--- |
| 101 | 1 | 2023-01-10 |
| 102 | 3 | 2023-02-05 |
| 103 | 1 | 2023-03-15 |

```sql
WITH customers AS (
  SELECT 1 AS id, 'Alice' AS name UNION ALL
  SELECT 2, 'Bob' UNION ALL
  SELECT 3, 'Charlie'
),
orders AS (
  SELECT 101 AS order_id, 1 AS customer_id, DATE '2023-01-10' AS order_date UNION ALL
  SELECT 102, 3, DATE '2023-02-05' UNION ALL
  SELECT 103, 1, DATE '2023-03-15'
)
SELECT
    c.name,
    (
        -- この顧客(c.id)の最新の注文日を取得
        SELECT MAX(o.order_date)
        FROM orders o
        WHERE c.id = o.customer_id
    ) AS latest_order_date
FROM
    customers c;
```

**実行結果:**

| name | latest_order_date |
| :--- | :--- |
| Alice | 2023-03-15 |
| Bob | NULL |
| Charlie | 2023-02-05 |