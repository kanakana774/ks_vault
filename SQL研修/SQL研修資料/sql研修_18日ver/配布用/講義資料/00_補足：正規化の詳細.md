### 前提：非正規化された巨大テーブル

まず、正規化されていない元の巨大なテーブルを想定します。ここでは、販売記録を保持する `sales_record` というテーブルを仮定します。

**`sales_record` (非正規化テーブル)**

| 注文 ID | 注文日     | 顧客 ID | 顧客名   | メールアドレス | 顧客登録日 | 商品 ID | カテゴリ | 商品名   | 単価  | 数量 | 在庫数 | メモ       | 商品 ID | カテゴリ | 商品名     | 単価 | 数量 | 在庫数 | メモ     |
| ------- | ---------- | ------- | -------- | -------------- | ---------- | ------- | -------- | -------- | ----- | ---- | ------ | ---------- | ------- | -------- | ---------- | ---- | ---- | ------ | -------- |
| O001    | 2023-01-15 | C001    | 山田太郎 | yamada@ex.com  | 2022-03-01 | P001    | 家電     | テレビ   | 50000 | 1    | 10     | 大画面     | P002    | 雑貨     | マグカップ | 1000 | 2    | 50     | かわいい |
| O002    | 2023-01-16 | C002    | 佐藤花子 | sato@ex.com    | 2022-04-10 | P001    | 家電     | テレビ   | 50000 | 1    | 10     | 大画面     |
| O003    | 2023-01-17 | C001    | 山田太郎 | yamada@ex.com  | 2022-03-01 | P003    | 書籍     | SQL 入門 | 3000  | 1    | 20     | 初心者向け |

**問題点:**

- **繰り返しグループ (1NF 違反):** 注文 ID `O001` の行を見ると、同じ注文に関する情報（注文日、顧客情報）が繰り返されています。また、もし「商品 ID」と「数量」が繰り返しフィールドとして 1 つのセルに複数入っていた場合も 1NF 違反です。
- **部分関数従属 (2NF 違反):** 主キーを `{注文ID, 商品ID}` とした場合、
- `注文日`, `顧客ID`, `顧客名`, `メールアドレス`, `顧客登録日` は `注文ID` にのみ依存しています。
- `カテゴリ`, `商品名`, `単価`, `在庫数`, `メモ` は `商品ID` にのみ依存しています。
- **推移的関数従属 (3NF 違反):** `顧客名`, `メールアドレス`, `顧客登録日` は `顧客ID` に依存しており、`顧客ID` は `注文ID` に依存しています。つまり、主キー `{注文ID, 商品ID}` を介さずに、主キー以外の列 (`顧客ID`) に依存しています。同様に `カテゴリ` も `商品名` に依存しており、それが `商品ID` に依存している場合など。

---

### 1. 第一正規形 (1NF) への変換

**目的:**

- すべての列が単一の値を持つ（多値属性の排除）。
- 繰り返しグループを排除し、各行が一意のエンティティ（レコード）を表すようにする。
- 各列が原子的な値を持つようにする。

例えば `商品ID` のセルに `P001, P002` のように複数の値が入っていたり、`数量` のセルに `1, 2` のように複数の値が入っているような「繰り返しグループ」が存在していたとすれば、それを分解して複数行にするのが 1NF の主な作業です。

現在の例では、この段階でのテーブルの見た目の変化はありませんが、論理的には「注文と商品の組み合わせ」を行の単位として明確にします。

**`sales_record_1NF` (第一正規形)**

| 注文 ID | 注文日     | 顧客 ID | 顧客名   | メールアドレス | 顧客登録日 | 商品 ID | カテゴリ | 商品名     | 単価  | 数量 | 在庫数 | メモ       |
| ------- | ---------- | ------- | -------- | -------------- | ---------- | ------- | -------- | ---------- | ----- | ---- | ------ | ---------- |
| O001    | 2023-01-15 | C001    | 山田太郎 | yamada@ex.com  | 2022-03-01 | P001    | 家電     | テレビ     | 50000 | 1    | 10     | 大画面     |
| O001    | 2023-01-15 | C001    | 山田太郎 | yamada@ex.com  | 2022-03-01 | P002    | 雑貨     | マグカップ | 1000  | 2    | 50     | かわいい   |
| O002    | 2023-01-16 | C002    | 佐藤花子 | sato@ex.com    | 2022-04-10 | P001    | 家電     | テレビ     | 50000 | 1    | 10     | 大画面     |
| O003    | 2023-01-17 | C001    | 山田太郎 | yamada@ex.com  | 2022-03-01 | P003    | 書籍     | SQL 入門   | 3000  | 1    | 20     | 初心者向け |

---

### 2. 第二正規形 (2NF) への変換

**目的:** 主キーの一部にのみ依存する属性（部分関数従属）を別のテーブルに分離する。
主キーを `{注文ID, 商品ID}` と仮定します。

**手順:**

1.  **`注文ID` にのみ依存する属性を分離:**
    - `注文日`
    - `顧客ID`, `顧客名`, `メールアドレス`, `顧客登録日` (これらはさらに `顧客ID` に依存するが、ここでは `注文ID` に依存するグループとしてまとめて分離)
2.  **`商品ID` にのみ依存する属性を分離:**
    - `カテゴリ`, `商品名`, `単価`, `在庫数`, `メモ`
3.  **残りの属性 (`{注文ID, 商品ID}` に依存する属性) を保持:**
    - `数量`

**結果として生成されるテーブル:**

#### ① `orders_base` (仮称) - 注文に関する情報

| 注文 ID | 注文日     | 顧客 ID | 顧客名   | メールアドレス | 顧客登録日 |
| ------- | ---------- | ------- | -------- | -------------- | ---------- |
| O001    | 2023-01-15 | C001    | 山田太郎 | yamada@ex.com  | 2022-03-01 |
| O002    | 2023-01-16 | C002    | 佐藤花子 | sato@ex.com    | 2022-04-10 |
| O003    | 2023-01-17 | C001    | 山田太郎 | yamada@ex.com  | 2022-03-01 |

#### ② `products_mst` - 商品マスタ

| 商品 ID | カテゴリ | 商品名     | 単価  | 在庫数 | メモ       |
| ------- | -------- | ---------- | ----- | ------ | ---------- |
| P001    | 家電     | テレビ     | 50000 | 10     | 大画面     |
| P002    | 雑貨     | マグカップ | 1000  | 50     | かわいい   |
| P003    | 書籍     | SQL 入門   | 3000  | 20     | 初心者向け |

#### ③ `order_details_trn` - 注文明細トランザクション

| 注文 ID | 商品 ID | 数量 |
| ------- | ------- | ---- |
| O001    | P001    | 1    |
| O001    | P002    | 2    |
| O002    | P001    | 1    |
| O003    | P003    | 1    |

---

### 3. 第三正規形 (3NF) への変換

**目的:** 主キー以外の列に依存する属性（推移的関数従属）を別のテーブルに分離する。

ここでは、2NF で作成された `orders_base` テーブルに着目します。
主キーは `注文ID` です。`顧客名`, `メールアドレス`, `顧客登録日` は `顧客ID` に依存しており、`顧客ID` は `注文ID` に依存しています (`注文ID` -> `顧客ID` -> `顧客名` など)。これが推移的関数従属です。

**手順:**

1.  `orders_base` から `顧客ID` 以外の顧客に関する情報 (`顧客名`, `メールアドレス`, `顧客登録日`) を分離し、`顧客ID` を主キーとする新しいテーブル (`customers_mst`) を作成します。
2.  `orders_base` には `顧客ID` を残し、`customers_mst` への外部キーとします。

**結果として生成されるテーブル (最終形の一部):**

#### ① `customers_mst` - 顧客マスタ

| 顧客 ID | 顧客名   | メールアドレス | 顧客登録日 |
| ------- | -------- | -------------- | ---------- |
| C001    | 山田太郎 | yamada@ex.com  | 2022-03-01 |
| C002    | 佐藤花子 | sato@ex.com    | 2022-04-10 |

#### ② `orders_trn` - 注文トランザクション

| 注文 ID | 注文日     | 顧客 ID |
| ------- | ---------- | ------- |
| O001    | 2023-01-15 | C001    |
| O002    | 2023-01-16 | C002    |
| O003    | 2023-01-17 | C001    |

- `orders_trn` の `顧客ID` は `customers_mst` の `顧客ID` を参照する外部キーとなります。

#### ③ `products_mst` - 商品マスタ (変更なし)

| 商品 ID | カテゴリ | 商品名     | 単価  | 在庫数 | メモ       |
| ------- | -------- | ---------- | ----- | ------ | ---------- |
| P001    | 家電     | テレビ     | 50000 | 10     | 大画面     |
| P002    | 雑貨     | マグカップ | 1000  | 50     | かわいい   |
| P003    | 書籍     | SQL 入門   | 3000  | 20     | 初心者向け |

#### ④ `order_details_trn` - 注文明細トランザクション (変更なし)

| 注文 ID | 商品 ID | 数量 |
| ------- | ------- | ---- |
| O001    | P001    | 1    |
| O001    | P002    | 2    |
| O002    | P001    | 1    |
| O003    | P003    | 1    |

- `order_details_trn` の `注文ID` は `orders_trn` の `注文ID` を参照する外部キーとなります。
- `order_details_trn` の `商品ID` は `products_mst` の `商品ID` を参照する外部キーとなります。

---

### 最終的なテーブル構造

上記の手順を経て、質問で提示された正規化されたテーブル構造が得られます。`deleted_at` カラムは「論理削除」のためのもので、正規化のプロセスとは直接関係ありませんが、実用的なデータベース設計によく導入されます。

1.  **`customers_mst`**

    - 主キー: `customer_id`
    - 属性: `customer_name`, `email`, `created_date`, `deleted_at`

2.  **`products_mst`**

    - 主キー: `product_id`
    - 属性: `category`, `product_name`, `price`, `stock_quantity`, `memo`, `deleted_at`

3.  **`orders_trn`**

    - 主キー: `order_id`
    - 属性: `customer_id` (FOREIGN KEY to `customers_mst`), `order_date`, `deleted_at`

4.  **`order_details_trn`**
    - 主キー: `{order_id, product_id}`
    - 属性: `order_id` (FOREIGN KEY to `orders_trn`), `product_id` (FOREIGN KEY to `products_mst`), `quantity`, `deleted_at`

### RDBMS の正規化でテーブルを分けていく利点

一つの巨大なテーブルで持たずに、正規化によってテーブルを分けていくことには、RDBMS の設計における多くの重要な利点があります。

1.  **データの冗長性の排除 (Redundancy Elimination):**

    - 同じデータが複数の場所に重複して保存されることを防ぎます。
    - 例: 顧客名やメールアドレスが、その顧客が行った注文の数だけ繰り返して保存されることを防ぎます。
    - **利点:** データベースのストレージ容量を節約し、データの整合性を維持しやすくなります。

2.  **データの整合性の向上 (Data Integrity):**

    - 冗長性が排除されることで、データの更新時に不整合が発生するリスクが大幅に減少します。
    - 例: 顧客のメールアドレスが変更された場合、`customers_mst` テーブルの 1 箇所を更新するだけで済みます。もし巨大テーブルであれば、その顧客のすべての注文レコードを更新する必要があり、漏れや誤りが発生しやすくなります。
    - **利点:** データの信頼性と正確性が高まります。

3.  **データ更新時の異常の回避 (Avoidance of Update Anomalies):**

    - **挿入異常 (Insertion Anomaly):** 関連する情報がないと新しいデータを挿入できない。
      - 例: 顧客がまだ何も注文していなくても、`customers_mst` に顧客情報を追加できます。巨大テーブルの場合、注文がないと顧客情報を追加できない可能性があります。
    - **更新異常 (Update Anomaly):** データの更新時に一部だけが更新されてしまう。
      - 例: 上述のメールアドレスの変更。
    - **削除異常 (Deletion Anomaly):** 関連するデータを削除したときに、意図しない別のデータも削除されてしまう。
      - 例: ある顧客の注文をすべて削除すると、その顧客の情報自体も消えてしまう。
    - **利点:** データの変更が安全かつ効率的に行えます。

4.  **データベースの柔軟性と拡張性 (Flexibility and Scalability):**

    - 新しい種類のデータを追加したり、既存のデータ構造を変更したりする際に、影響範囲が小さくなります。
    - 例: 顧客に新しい属性（例: 住所）を追加したい場合、`customers_mst` に列を追加するだけで、他のテーブルには影響しません。
    - **利点:** システムの変更や拡張が容易になり、運用コストが削減されます。

5.  **クエリの効率化 (Improved Query Performance):**

    - 必要な情報が適切にグループ化されているため、クエリが特定のテーブルに集中し、不要なデータの読み込みを減らせます。
    - インデックスを効果的に使用できるようになります。
    - 結合操作はコストがかかりますが、適切に正規化されたテーブルでは、必要なデータ量が減るため、多くの場合、パフォーマンスが向上します。
    - **利点:** データベースの応答速度が向上します。

6.  **理解の容易さ (Ease of Understanding):**
    - 各テーブルが特定のエンティティ（顧客、商品、注文など）を表すため、データベースの構造が直感的で理解しやすくなります。
    - **利点:** 開発者やデータベース管理者にとって、設計の把握、保守、デバッグが容易になります。

### まとめ

正規化は、一見するとテーブルが増えて複雑になるように見えるかもしれません。しかし、長期的な視点で見ると、データの整合性、保守性、拡張性、パフォーマンスといった面で、RDBMS の真価を発揮するための非常に重要なプロセスです。提示されたテーブル設計は、これらの利点を最大限に引き出すための良い例と言えるでしょう。
