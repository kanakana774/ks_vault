
## **サブクエリ (Subqueries)**

サブクエリとは、**SQLクエリの中に記述される別のSQLクエリ**のことです。入れ子（ネスト）になったクエリと考えると分かりやすいでしょう。

サブクエリは、外側のクエリ（主クエリ）に値を渡すために使われ、`SELECT`, `FROM`, `WHERE`句など、様々な場所で活躍します。

サブクエリを理解する上で最も重要なのは、「**非相関サブクエリ**」と「**相関サブクエリ**」の違いを明確に掴むことです。

| 種類 | 実行タイミング | 特徴 |
| :--- | :--- | :--- |
| **非相関サブクエリ** | **一度だけ**実行される | 内側のクエリが外側から独立しており、先に単独で実行可能。 |
| **相関サブクエリ** | 外側の行ごとに**毎回**実行される | 内側のクエリが外側のクエリの「現在の行」の値を参照する。 |

---

### **1. 非相関サブクエリ (Non-correlated Subquery)**

内側のサブクエリが外側のクエリとは独立して**一度だけ**実行されます。その実行結果（単一値、値のリスト、またはテーブル）が、外側のクエリ全体で利用されます。

#### **パターンA: `WHERE`句での利用（絞り込み条件として）**

サブクエリが返した「単一の値」や「値のリスト」を使い、外側のクエリが取得する行を絞り込みます。

**【例1: 単一値との比較】平均価格より高い商品のリストを取得**

**事前データ (products):**

| product_id | product_name | price |
| :--- | :--- | ---: |
| 1 | Laptop | 1200.00 |
| 2 | Mouse | 25.50 |
| 3 | Keyboard | 75.00 |
| 4 | Monitor | 300.00 |

```sql
WITH products AS (
  SELECT 1 AS product_id, 'Laptop' AS product_name, 1200.00 AS price UNION ALL
  SELECT 2, 'Mouse', 25.50 UNION ALL
  SELECT 3, 'Keyboard', 75.00 UNION ALL
  SELECT 4, 'Monitor', 300.00
)
SELECT product_name, price
FROM products
WHERE price > (SELECT AVG(price) FROM products); -- AVG(price)は約400.12
```

**実行結果:**

| product_name |   price |
| :----------- | ------: |
| Laptop       | 1200.00 |

**【例2: 値のリストとの比較 (`IN`句)】'Electronics'カテゴリに属する商品を取得**

**事前データ (products, categories):**
`products`

| product_id | product_name | category_id |
| :--- | :--- | ---: |
| 1 | Laptop | 101 |
| 2 | T-Shirt | 102 |
| 3 | Mouse | 101 |

`categories`

| category_id | category_name |
| :--- | :--- |
| 101 | Electronics |
| 102 | Apparel |

```sql
WITH products AS (
  SELECT 1 AS product_id, 'Laptop' AS product_name, 101 AS category_id UNION ALL
  SELECT 2, 'T-Shirt', 102 UNION ALL
  SELECT 3, 'Mouse', 101
),
categories AS (
  SELECT 101 AS category_id, 'Electronics' AS category_name UNION ALL
  SELECT 102, 'Apparel'
)
SELECT product_name
FROM products
WHERE category_id IN (
  SELECT category_id FROM categories WHERE category_name = 'Electronics'
); -- サブクエリは (101) というリストを返す
```

**実行結果:**

| product_name |
| :--- |
| Laptop |
| Mouse |

#### **パターンB: `FROM`句での利用（一時的なテーブルとして）**

サブクエリの結果を一つのテーブル（**派生テーブル**）と見なし、そのテーブルに対して外側のクエリを実行します。

**【例】価格が300以上の商品群の、さらにその中での平均価格を計算**

**事前データ (products):**

| product_id | product_name | price |
| :--- | :--- | ---: |
| 1 | Laptop | 1200.00 |
| 2 | Mouse | 25.50 |
| 3 | Monitor | 300.00 |

```sql
WITH products AS (
  SELECT 1 AS product_id, 'Laptop' AS product_name, 1200.00 AS price UNION ALL
  SELECT 2, 'Mouse', 25.50 UNION ALL
  SELECT 3, 'Monitor', 300.00
)
SELECT AVG(high_price_product_price) AS avg_high_price_product_price
FROM (
   SELECT price AS high_price_product_price
   FROM products
   WHERE price >= 300
) AS high_value_products; -- サブクエリの結果は (1200.00), (300.00)
```

**実行結果:**

| avg_high_price_product_price |
| ---: |
| 750.00 |

---

### **2. 相関サブクエリ (Correlated Subquery)**

内側のサブクエリが、外側のクエリが処理している**現在の行の値**に依存して実行されるサブクエリです。

---

### **相関サブクエリの思考パターン**

#### **思考パターン1: 「存在チェック」を「絞り込み条件」に使う (`WHERE` + `EXISTS`)**

**【例】少なくとも1つの注文がある顧客を取得**

**事前データ (customers, orders):**
`customers`

| customer_id | customer_name |
| :--- | :--- |
| 1 | Alice |
| 2 | Bob |
| 3 | Charlie |

`orders`

| order_id | customer_id |
| :--- | :--- |
| 101 | 1 |
| 102 | 3 |

```sql
WITH customers AS (
  SELECT 1 AS customer_id, 'Alice' AS customer_name UNION ALL
  SELECT 2, 'Bob' UNION ALL
  SELECT 3, 'Charlie'
),
orders AS (
  SELECT 101 AS order_id, 1 AS customer_id UNION ALL
  SELECT 102, 3
)
SELECT customer_name
FROM customers AS c
WHERE EXISTS (
   SELECT 1
   FROM orders AS o
   WHERE o.customer_id = c.customer_id
);
```

**実行結果:**

| customer_name |
| :--- |
| Alice |
| Charlie |

#### **思考パターン2: 「取得した値との比較」を「絞り込み条件」に使う (`WHERE` + 比較演算子)**

**【例】各カテゴリで最も価格が高い商品を取得**

**事前データ (products):**

| product_name | price | category_id |
| :--- | ---: | ---: |
| Laptop | 1200.00 | 1 |
| Mouse | 25.50 | 1 |
| Headset | 150.00 | 2 |
| Webcam | 90.00 | 2 |

```sql
WITH products AS (
  SELECT 'Laptop' AS product_name, 1200.00 AS price, 1 AS category_id UNION ALL
  SELECT 'Mouse', 25.50, 1 UNION ALL
  SELECT 'Headset', 150.00, 2 UNION ALL
  SELECT 'Webcam', 90.00, 2
)
SELECT
   p1.product_name,
   p1.price,
   p1.category_id
FROM
   products AS p1
WHERE
   p1.price = (
      SELECT MAX(p2.price)
      FROM products AS p2
      WHERE p2.category_id = p1.category_id
   );
```

**実行結果:**

| product_name | price | category_id |
| :--- | ---: | ---: |
| Laptop | 1200.00 | 1 |
| Headset | 150.00 | 2 |

#### **思考パターン3: 「取得した値」を「新しい列」として使う (`SELECT` + スカラーサブクエリ)**

**【例】各商品に、その商品が属するカテゴリの平均価格を併記する**

**事前データ (products):**

| product_name | price | category_id |
| :--- | ---: | ---: |
| Laptop | 1200.00 | 1 |
| Mouse | 100.00 | 1 |
| Headset | 150.00 | 2 |

```sql
WITH products AS (
  SELECT 'Laptop' AS product_name, 1200.00 AS price, 1 AS category_id UNION ALL
  SELECT 'Mouse', 100.00, 1 UNION ALL
  SELECT 'Headset', 150.00, 2
)
SELECT
   p.product_name,
   p.price,
   (
      SELECT AVG(price)
      FROM products
      WHERE category_id = p.category_id
   ) AS avg_category_price
FROM
   products AS p;
```

**実行結果:**

| product_name | price | avg_category_price |
| :--- | ---: | ---: |
| Laptop | 1200.00 | 650.00 |
| Mouse | 100.00 | 650.00 |
| Headset | 150.00 | 150.00 |

---

## **IN と EXISTS の使い分け**

`IN`と`EXISTS`はどちらも行を絞り込むために使えますが、その動作原理と得意な場面が全く異なります。

**【お題】注文履歴のある顧客を抽出する**

このお題を`IN`と`EXISTS`の両方で書いて、その違いを見ていきましょう。

**事前データ (customers, orders):**
`customers`

| customer_id | customer_name |
| :--- | :--- |
| 1 | Alice |
| 2 | Bob |
| 3 | Charlie |

`orders`

| order_id | customer_id |
| :--- | :--- |
| 101 | 1 |
| 102 | 3 |
| 103 | 1 |

### **`IN`を使った書き方 (非相関サブクエリ)**

`IN`は、サブクエリが返す**値のリスト**に、外側の列の値が含まれているかをチェックします。

**思考プロセス:**
1.  **先に**、注文があった顧客IDのリストを**すべて**作る `(1, 3, 1)` -> 重複排除され `(1, 3)` となる。
2.  `customers`テーブルの各行について、`customer_id`がそのリスト `(1, 3)` に含まれているかチェックする。

```sql
WITH customers AS (
  SELECT 1 AS customer_id, 'Alice' AS customer_name UNION ALL
  SELECT 2, 'Bob' UNION ALL
  SELECT 3, 'Charlie'
),
orders AS (
  SELECT 101 AS order_id, 1 AS customer_id UNION ALL
  SELECT 102, 3 UNION ALL
  SELECT 103, 1
)
SELECT customer_name
FROM customers
WHERE customer_id IN (
  -- このサブクエリは最初に一度だけ実行される
  SELECT customer_id FROM orders
);
```
**実行結果:**

| customer_name |
| :--- |
| Alice |
| Charlie |

### **`EXISTS`を使った書き方 (相関サブクエリ)**

`EXISTS`は、サブクエリが**1行でも返せば**`TRUE`となる「存在チェック」を行います。

**思考プロセス:**
1.  `customers`テーブルの`Alice`の行をチェックする。
2.  サブクエリが `WHERE o.customer_id = 1` (AliceのID) として実行される。注文が見つかるので、サブクエリは行を返し`EXISTS`は`TRUE`になる。`Alice`は結果に含まれる。
3.  `customers`テーブルの`Bob`の行をチェックする。
4.  サブクエリが `WHERE o.customer_id = 2` (BobのID) として実行される。注文が見つからないので、サブクエリは0行を返し`EXISTS`は`FALSE`になる。`Bob`は結果に含まれない。
5.  (Charlieも同様にチェック)

```sql
WITH customers AS (
  SELECT 1 AS customer_id, 'Alice' AS customer_name UNION ALL
  SELECT 2, 'Bob' UNION ALL
  SELECT 3, 'Charlie'
),
orders AS (
  SELECT 101 AS order_id, 1 AS customer_id UNION ALL
  SELECT 102, 3 UNION ALL
  SELECT 103, 1
)
SELECT customer_name
FROM customers AS c
WHERE EXISTS (
   -- 外側の行 c のcustomer_idごとに毎回実行される
   SELECT 1
   FROM orders AS o
   WHERE o.customer_id = c.customer_id
);
```
**実行結果:**

| customer_name |
| :--- |
| Alice |
| Charlie |

### **比較まとめ**

| | **IN** | **EXISTS** |
| :--- | :--- | :--- |
| **サブクエリの役割** | **値のリスト**を返す | **存在有無**をチェックする |
| **実行方式** | 非相関（先に一度だけ実行） | 相関（外側の行ごとに実行） |
| **得意なケース** | `WHERE user_id IN (1, 2, 3)` のような**小さい固定リスト**を渡す場合 | 関連テーブルに**マッチする行があるか**を確認する場合（今回のお題はこちらが本筋） |
| **パフォーマンス** | サブクエリの結果セットが大きいとメモリを消費し、遅くなることがある | マッチする行を1つ見つけ次第、内部の検索を打ち切るため、効率的なことが多い |

---

## **サブクエリの代替としての JOIN**

多くの相関サブクエリや`IN`句を使用する非相関サブクエリは、`JOIN`句で書き換え可能です。一般的に、`JOIN`の方がSQLオプティマイザ（実行計画を最適化する機能）が効率的な処理方法を見つけやすく、パフォーマンスが優れていることが多いとされています。

ここでは、相関サブクエリの思考パターン2で扱った「各カテゴリで最も価格が高い商品を取得する」というお題を、`JOIN`を使って書き換えてみましょう。

---

**【シナリオ】各カテゴリで最も価格が高い商品を取得する**

**事前データ (products):**

| product_name | price | category_id |
| :--- | ---: | ---: |
| Laptop | 1200.00 | 1 |
| Mouse | 100.00 | 1 |
| Keyboard | 200.00 | 1 |
| Headset | 150.00 | 2 |
| Webcam | 90.00 | 2 |

---

#### **書き方1: 相関サブクエリを使用する例**

外側の行ごとに、サブクエリが「その行のカテゴリにおける最大価格」を計算して比較します。

```sql
WITH products AS (
  SELECT 'Laptop' AS product_name, 1200.00 AS price, 1 AS category_id UNION ALL
  SELECT 'Mouse', 100.00, 1 UNION ALL
  SELECT 'Keyboard', 200.00, 1 UNION ALL
  SELECT 'Headset', 150.00, 2 UNION ALL
  SELECT 'Webcam', 90.00, 2
)
-- 相関サブクエリの元の例
SELECT
   p1.product_name,
   p1.price,
   p1.category_id
FROM
   products AS p1
WHERE
   p1.price = (
      SELECT MAX(p2.price)
      FROM products AS p2
      WHERE p2.category_id = p1.category_id
   );
```

---

#### **書き方2: `JOIN` と `FROM`句サブクエリ（派生テーブル）で書き換える例**

**思考プロセス:**
1.  **先に**、カテゴリごとの最大価格をまとめた一時的なテーブル（派生テーブル `max_prices`）を`FROM`句サブクエリで作る。
2.  元の`products`テーブルと、この`max_prices`テーブルを`JOIN`する。
3.  結合条件として、「カテゴリIDが一致」し、かつ「商品の価格がそのカテゴリの最大価格と一致」するものを絞り込む。

```sql
WITH products AS (
  SELECT 'Laptop' AS product_name, 1200.00 AS price, 1 AS category_id UNION ALL
  SELECT 'Mouse', 100.00, 1 UNION ALL
  SELECT 'Keyboard', 200.00, 1 UNION ALL
  SELECT 'Headset', 150.00, 2 UNION ALL
  SELECT 'Webcam', 90.00, 2
)
-- JOIN と GROUP BY で書き換え
SELECT
   p.product_name,
   p.price,
   p.category_id
FROM
   products AS p
INNER JOIN (
   -- 1. 先にカテゴリごとの最大価格テーブルを作る
   SELECT category_id, MAX(price) AS max_price_in_category
   FROM products
   GROUP BY category_id
) AS max_prices
-- 2. カテゴリIDと価格の両方で結合する
ON p.category_id = max_prices.category_id
   AND p.price = max_prices.max_price_in_category;
```

---

**実行結果 (両方のクエリで同じ):**

| product_name | price | category_id |
| :--- | ---: | ---: |
| Laptop | 1200.00 | 1 |
| Headset | 150.00 | 2 |

このように、`JOIN`を使ったクエリは、先に集計を済ませてから結合するため、行ごとのサブクエリ実行がなくなります。多くの場合、こちらの書き換えの方が効率的です。相関サブクエリでパフォーマンスに課題を感じた場合は、まず`JOIN`での書き換えを検討するのが良いでしょう。


---


## **RDBMS 間の違いに注意！**

ここまで見てきた JOIN、集合演算、サブクエリの構文や挙動は、多くの RDBMS で共通していますが、細かな部分で違いがあります。

| 機能/概念                      | PostgreSQL                                            | MySQL                                                 | Oracle                                                | SQL Server                                            |
| :----------------------------- | :---------------------------------------------------- | :---------------------------------------------------- | :---------------------------------------------------- | :---------------------------------------------------- |
| FULL OUTER JOIN                | サポートあり                                          | サポートなし（代替で対応）                            | サポートあり                                          | サポートあり                                          |
| EXCEPT / MINUS                 | EXCEPT                                                | サポートなし（代替で対応）                            | MINUS                                                 | EXCEPT                                                |
| LIMIT/OFFSET                   | LIMIT OFFSET                                          | LIMIT OFFSET                                          | ROWNUM / OFFSET FETCH                                 | TOP / OFFSET FETCH                                    |
| サブクエリの最適化             | 進んでいる                                            | 進んでいる                                            | 進んでいる                                            | 進んでいる                                            |
| 相関サブクエリのパフォーマンス | 状況によるが、JOIN やウィンドウ関数への書き換えを推奨 | 状況によるが、JOIN やウィンドウ関数への書き換えを推奨 | 状況によるが、JOIN やウィンドウ関数への書き換えを推奨 | 状況によるが、JOIN やウィンドウ関数への書き換えを推奨 |

特に FULL OUTER JOIN や EXCEPT/MINUS は、RDBMS によってサポート状況や名称が異なるため、使用する際には注意が必要です。
