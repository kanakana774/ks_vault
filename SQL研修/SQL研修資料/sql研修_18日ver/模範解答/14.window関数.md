SQL Window 関数研修問題

```SQL
テーブル定義 (DDL)
-- 顧客
CREATE TABLE Customers (
customer_id INT PRIMARY KEY,
name VARCHAR(100),
email VARCHAR(100),
phone VARCHAR(20),
city VARCHAR(50),
join_date DATE,
membership_id INT -- 後で FOREIGN KEY が追加されます
);
-- 会員ランク
CREATE TABLE Memberships (
membership_id INT PRIMARY KEY,
rank_name VARCHAR(50),
discount_rate DECIMAL(5,2)
);
-- Customers テーブルに FOREIGN KEY を追加
ALTER TABLE Customers
ADD FOREIGN KEY (membership_id) REFERENCES Memberships(membership_id);
-- 商品
CREATE TABLE Products (
product_id INT PRIMARY KEY,
product_name VARCHAR(100),
category_id INT,
price DECIMAL(10,2)
);
-- 商品カテゴリ
CREATE TABLE Categories (
category_id INT PRIMARY KEY,
category_name VARCHAR(50)
);
-- 在庫
CREATE TABLE Inventory (
product_id INT,
warehouse_id INT,
stock_quantity INT,
PRIMARY KEY (product_id, warehouse_id),
FOREIGN KEY (product_id) REFERENCES Products(product_id)
);
-- 倉庫
CREATE TABLE Warehouses (
warehouse_id INT PRIMARY KEY,
warehouse_name VARCHAR(50),
location VARCHAR(50)
);
-- 注文
CREATE TABLE Orders (
order_id INT PRIMARY KEY,
customer_id INT,
order_date DATE,
status VARCHAR(20),
FOREIGN KEY (customer_id) REFERENCES Customers(customer_id)
);
-- 注文明細
CREATE TABLE OrderItems (
order_item_id INT PRIMARY KEY,
order_id INT,
product_id INT,
quantity INT,
FOREIGN KEY (order_id) REFERENCES Orders(order_id),
FOREIGN KEY (product_id) REFERENCES Products(product_id)
);
-- 支払い
CREATE TABLE Payments (
payment_id INT PRIMARY KEY,
order_id INT,
payment_date DATE,
amount DECIMAL(10,2),
method VARCHAR(20),
FOREIGN KEY (order_id) REFERENCES Orders(order_id)
);
-- 配送
CREATE TABLE Shipments (
shipment_id INT PRIMARY KEY,
order_id INT,
shipped_date DATE,
delivery_date DATE,
status VARCHAR(20),
FOREIGN KEY (order_id) REFERENCES Orders(order_id)
);
-- 商品レビュー
CREATE TABLE Reviews (
review_id INT PRIMARY KEY,
product_id INT,
customer_id INT,
rating INT,
comment TEXT,
review_date DATE,
FOREIGN KEY (product_id) REFERENCES Products(product_id),
FOREIGN KEY (customer_id) REFERENCES Customers(customer_id)
);
-- スタッフ
CREATE TABLE Staff (
staff_id INT PRIMARY KEY,
name VARCHAR(100),
position VARCHAR(50),
hire_date DATE,
warehouse_id INT,
FOREIGN KEY (warehouse_id) REFERENCES Warehouses(warehouse_id)
);
```

サンプルデータ (DML)

```SQL
-- Memberships
INSERT INTO Memberships (membership_id, rank_name, discount_rate) VALUES
(1, 'Bronze', 0.05),
(2, 'Silver', 0.10),
(3, 'Gold', 0.15),
(4, 'Platinum', 0.20);

-- Customers
INSERT INTO Customers (customer_id, name, email, phone, city, join_date, membership_id) VALUES
(101, '佐藤 太郎', 'sato.t@example.com', '090-1111-2222', '東京', '2023-01-15', 1),
(102, '鈴木 花子', 'suzuki.h@example.com', '080-3333-4444', '大阪', '2023-02-20', 2),
(103, '田中 次郎', 'tanaka.j@example.com', '070-5555-6666', '東京', '2023-03-10', 1),
(104, '高橋 美咲', 'takahashi.m@example.com', '090-7777-8888', '福岡', '2023-04-01', 3),
(105, '渡辺 健太', 'watanabe.k@example.com', '080-9999-0000', '大阪', '2023-05-05', 2);

-- Categories
INSERT INTO Categories (category_id, category_name) VALUES
(1, '家電'),
(2, '書籍'),
(3, '食品'),
(4, '日用品');

-- Products
INSERT INTO Products (product_id, product_name, category_id, price) VALUES
(1, 'ワイヤレスイヤホン', 1, 12800.00),
(2, 'プログラミング入門', 2, 2980.00),
(3, '有機野菜セット', 3, 3500.00),
(4, '多機能シャープペン', 4, 800.00),
(5, 'スマートウォッチ', 1, 25000.00),
(6, 'SQL実践ガイド', 2, 4500.00),
(7, '高級チョコレート', 3, 1500.00),
(8, 'アロマディフューザー', 4, 3200.00),
(9, 'タブレットPC', 1, 55000.00),
(10, 'データサイエンス入門', 2, 3800.00),
(11, '国産牛肉', 3, 7000.00),
(12, 'エコバッグ', 4, 1200.00),
(13, 'カナル型イヤホン', 1, 12800.00);

-- Warehouses
INSERT INTO Warehouses (warehouse_id, warehouse_name, location) VALUES
(1, '東京倉庫', '東京都 江東区'),
(2, '大阪倉庫', '大阪府 堺市'),
(3, '福岡倉庫', '福岡県 福岡市');

-- Inventory
INSERT INTO Inventory (product_id, warehouse_id, stock_quantity) VALUES
(1, 1, 50), (1, 2, 30),
(2, 1, 100), (2, 3, 20),
(3, 2, 40),
(4, 1, 200), (4, 3, 150),
(5, 1, 20),
(6, 1, 70), (6, 2, 50),
(7, 2, 80),
(8, 1, 120),
(9, 3, 15),
(10, 1, 60),
(11, 2, 25),
(12, 1, 180), (12, 3, 100);

-- Orders
INSERT INTO Orders (order_id, customer_id, order_date, status) VALUES
(1001, 101, '2023-01-20', 'Completed'),
(1002, 102, '2023-02-25', 'Completed'),
(1003, 101, '2023-03-01', 'Completed'),
(1004, 103, '2023-03-15', 'Pending'),
(1005, 102, '2023-04-10', 'Completed'),
(1006, 104, '2023-04-05', 'Completed'),
(1007, 101, '2023-05-12', 'Shipped'),
(1008, 105, '2023-05-20', 'Completed'),
(1009, 103, '2023-06-01', 'Completed'),
(1010, 102, '2023-06-15', 'Pending');

-- OrderItems
INSERT INTO OrderItems (order_item_id, order_id, product_id, quantity) VALUES
(1, 1001, 1, 1),
(2, 1001, 2, 1),
(3, 1002, 3, 2),
(4, 1002, 4, 3),
(5, 1003, 1, 1),
(6, 1003, 6, 1),
(7, 1004, 5, 1),
(8, 1005, 7, 1),
(9, 1005, 8, 2),
(10, 1006, 9, 1),
(11, 1007, 10, 1),
(12, 1007, 1, 1),
(13, 1008, 11, 1),
(14, 1009, 2, 1),
(15, 1009, 12, 5),
(16, 1010, 3, 1);

-- Payments
INSERT INTO Payments (payment_id, order_id, payment_date, amount, method) VALUES
(1, 1001, '2023-01-20', 15780.00, 'Credit Card'),
(2, 1002, '2023-02-25', 9400.00, 'Bank Transfer'),
(3, 1003, '2023-03-01', 17300.00, 'Credit Card'),
(4, 1004, '2023-03-15', 25000.00, 'Credit Card'),
(5, 1005, '2023-04-10', 7900.00, 'E-wallet'),
(6, 1006, '2023-04-05', 55000.00, 'Credit Card'),
(7, 1007, '2023-05-12', 16600.00, 'Credit Card'),
(8, 1008, '2023-05-20', 7000.00, 'Bank Transfer'),
(9, 1009, '2023-06-01', 8980.00, 'Credit Card'),
(10, 1010, '2023-06-15', 3500.00, 'E-wallet');

-- Shipments
INSERT INTO Shipments (shipment_id, order_id, shipped_date, delivery_date, status) VALUES
(1, 1001, '2023-01-21', '2023-01-23', 'Delivered'),
(2, 1002, '2023-02-26', '2023-03-01', 'Delivered'),
(3, 1003, '2023-03-02', '2023-03-04', 'Delivered'),
(4, 1004, NULL, NULL, 'Pending'),
(5, 1005, '2023-04-11', '2023-04-13', 'Delivered'),
(6, 1006, '2023-04-06', '2023-04-09', 'Delivered'),
(7, 1007, '2023-05-13', NULL, 'In Transit'),
(8, 1008, '2023-05-21', '2023-05-23', 'Delivered'),
(9, 1009, '2023-06-02', '2023-06-04', 'Delivered'),
(10, 1010, NULL, NULL, 'Pending');

-- Reviews
INSERT INTO Reviews (review_id, product_id, customer_id, rating, comment, review_date) VALUES
(1, 1, 101, 5, '音質が素晴らしいです！', '2023-01-25'),
(2, 2, 101, 4, '初心者にも分かりやすい内容でした。', '2023-02-01'),
(3, 3, 102, 5, '新鮮で美味しい野菜でした。', '2023-03-05'),
(4, 6, 101, 5, 'SQLの理解が深まりました。', '2023-03-10'),
(5, 5, 103, 3, '機能は良いがバッテリー持ちがもう少し。', '2023-03-20'),
(6, 9, 104, 5, '高性能で満足しています。', '2023-04-10'),
(7, 1, 102, 4, 'デザインも良く満足です。', '2023-04-15');

-- Staff
INSERT INTO Staff (staff_id, name, position, hire_date, warehouse_id) VALUES
(1, '山本 賢一', 'Manager', '2022-04-01', 1),
(2, '中村 恵子', 'Clerk', '2022-07-10', 1),
(3, '小林 大輔', 'Clerk', '2023-01-05', 1),
(4, '加藤 玲奈', 'Manager', '2022-05-15', 2),
(5, '吉田 拓也', 'Clerk', '2023-02-01', 2),
(6, '佐々木 翼', 'Manager', '2022-06-01', 3),
(7, '林 結衣', 'Clerk', '2023-03-15', 3);

```

## 問題 1: 各顧客の最初の注文日と最新の注文日

### 重要度: ★★★

### 問題目的: FIRST_VALUE と LAST_VALUE を使用した、特定グループ内での最初と最後の値の取得方法を理解する。

### 問題: 各顧客について、最初の注文日と最新の注文日を特定し、それぞれの注文と共に表示してください。

### 答え:

```SQL
SELECT
    o.customer_id,
    o.order_id,
    o.order_date,
    FIRST_VALUE(o.order_date) OVER (PARTITION BY o.customer_id ORDER BY o.order_date ASC) AS first_order_date,
    LAST_VALUE(o.order_date) OVER (PARTITION BY o.customer_id ORDER BY o.order_date ASC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS latest_order_date
FROM
    Orders o
ORDER BY
    o.customer_id, o.order_date;
```

バリエーション: MIN と MAX の集計関数を OVER 句と組み合わせて使用することもできますが、FIRST_VALUE と LAST_VALUE はより明示的にウィンドウ関数であることを示します。

```SQL
SELECT
    o.customer_id,
    o.order_id,
    o.order_date,
    MIN(o.order_date) OVER (PARTITION BY o.customer_id) AS first_order_date_min_max,
    MAX(o.order_date) OVER (PARTITION BY o.customer_id) AS latest_order_date_min_max
FROM
    Orders o
ORDER BY
    o.customer_id, o.order_date;
```

### 解説:

- PARTITION BY o.customer_id: 結果セットを customer_id ごとに分割し、各顧客内で独立したウィンドウを形成します。
- ORDER BY o.order_date ASC: 各顧客のウィンドウ内で、order_date を昇順に並べ替えます。これは FIRST_VALUE と LAST_VALUE がどの行を「最初」または「最後」と見なすかを決定するために重要です。
- FIRST_VALUE(o.order_date): ウィンドウフレーム（デフォルトでは ORDER BY 句で指定された順序で最初の行）における order_date の値を返します。
- LAST_VALUE(o.order_date) OVER (...) ROWS BETWEEN UNBOUNDEDPRECEDING AND UNBOUNDED FOLLOWING: LAST_VALUE はデフォルトのウィンドウフレームでは CURRENT ROW までしか見ないため、ウィンドウ全体を参照するように ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING（現在の行から見て、前のすべての行から後のすべての行まで）と明示的にフレームを指定する必要があります。これにより、各顧客のウィンドウ全体における最新の order_date が取得されます。
- MIN(o.order_date) OVER (PARTITION BY o.customer_id): MIN や MAX をウィンドウ関数として使用する場合、ORDER BY 句は必須ではありません。PARTITION BY で定義された各グループの最小値または最大値を返します。これは FIRST_VALUE や LAST_VALUE と異なる挙動を示すため、注意が必要です。

## 問題 2: 各顧客の注文ごとの累計注文額

### 重要度: ★★★★

### 問題目的: SUM 関数と ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW を使用した、累計計算の基本を理解する。

### 問題: 各顧客について、注文日順に累計注文額（OrderItems テーブルの quantity_Products.price の合計）を計算してください。

### 答え:

```SQL
SELECT
    o.customer_id,
    o.order_id,
    o.order_date,
    SUM(oi.quantity * p.price) AS order_total,
    SUM(SUM(oi.quantity * p.price)) OVER (
        PARTITION BY o.customer_id ORDER BY o.order_date ASC, o.order_id ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS cumulative_order_total
FROM
    Orders o
JOIN
    OrderItems oi ON o.order_id = oi.order_id
JOIN
    Products p ON oi.product_id = p.product_id
GROUP BY
    o.customer_id, o.order_id, o.order_date
ORDER BY
    o.customer_id, o.order_date, o.order_id;
```

バリエーション: UNBOUNDED PRECEDING のみを使用した場合（ROWS BETWEEN 句なし）も同様の結果になりますが、ROWS BETWEEN を明示することで挙動をより明確にできます。

```SQL
SELECT
    o.customer_id,
    o.order_id,
    o.order_date,
    SUM(oi.quantity * p.price) AS order_total,
    SUM(SUM(oi.quantity * p.price)) OVER (
        PARTITION BY o.customer_id
        ORDER BY o.order_date ASC, o.order_id ASC
    ) AS cumulative_order_total_implicit_frame -- ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW が暗黙的に適用される
FROM
    Orders o
JOIN
    OrderItems oi ON o.order_id = oi.order_id
JOIN
    Products p ON oi.product_id = p.product_id
GROUP BY
    o.customer_id, o.order_id, o.order_date
ORDER BY
    o.customer_id, o.order_date, o.order_id;
```

### 考え方

① まずそれぞれの注文の商品ごとの合計金額を出す

```SQL
SELECT
	O.CUSTOMER_ID,
	O.ORDER_DATE,
	OI.ORDER_ITEM_ID,
	P.PRICE * OI.QUANTITY AS ORDER_TOTAL
FROM
	ORDERS O
	JOIN ORDERITEMS OI ON O.ORDER_ID = OI.ORDER_ID
	JOIN PRODUCTS P ON P.PRODUCT_ID = OI.PRODUCT_ID
ORDER BY
	O.CUSTOMER_ID,
	O.ORDER_DATE
```

② 注文ごとにまとめる

```SQL
SELECT
	O.CUSTOMER_ID,
	O.ORDER_DATE,
	SUM(P.PRICE * OI.QUANTITY) AS ORDER_TOTAL
FROM
	ORDERS O
	JOIN ORDERITEMS OI ON O.ORDER_ID = OI.ORDER_ID
	JOIN PRODUCTS P ON P.PRODUCT_ID = OI.PRODUCT_ID
GROUP BY
	O.CUSTOMER_ID,
	O.ORDER_DATE
ORDER BY
	O.CUSTOMER_ID,
	O.ORDER_DATE
```

③ すべての行の合計値を横に出す

```SQL
SELECT
	O.CUSTOMER_ID,
	O.ORDER_DATE,
	SUM(P.PRICE * OI.QUANTITY) AS ORDER_TOTAL,
	sum(SUM(P.PRICE * OI.QUANTITY)) over()
FROM
	ORDERS O
	JOIN ORDERITEMS OI ON O.ORDER_ID = OI.ORDER_ID
	JOIN PRODUCTS P ON P.PRODUCT_ID = OI.PRODUCT_ID
GROUP BY
	O.CUSTOMER_ID,
	O.ORDER_DATE
ORDER BY
	O.CUSTOMER_ID,
	O.ORDER_DATE
```

④ 顧客ごとに分ける

```SQL
SELECT
	O.CUSTOMER_ID,
	O.ORDER_DATE,
	SUM(P.PRICE * OI.QUANTITY) AS ORDER_TOTAL,
	SUM(SUM(P.PRICE * OI.QUANTITY)) OVER (
		PARTITION BY
			O.CUSTOMER_ID
	)
FROM
	ORDERS O
	JOIN ORDERITEMS OI ON O.ORDER_ID = OI.ORDER_ID
	JOIN PRODUCTS P ON P.PRODUCT_ID = OI.PRODUCT_ID
GROUP BY
	O.CUSTOMER_ID,
	O.ORDER_DATE
ORDER BY
	O.CUSTOMER_ID,
	O.ORDER_DATE
```

⑤ 累計に書き換える（order by つけるとデフォで RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW）

```SQL
SELECT
	O.CUSTOMER_ID,
	O.ORDER_DATE,
	SUM(P.PRICE * OI.QUANTITY) AS ORDER_TOTAL,
	SUM(SUM(P.PRICE * OI.QUANTITY)) OVER (
		PARTITION BY
			O.CUSTOMER_ID
		ORDER BY
			O.ORDER_DATE
	) AS cumulative_order_total
FROM
	ORDERS O
	JOIN ORDERITEMS OI ON O.ORDER_ID = OI.ORDER_ID
	JOIN PRODUCTS P ON P.PRODUCT_ID = OI.PRODUCT_ID
GROUP BY
	O.CUSTOMER_ID,
	O.ORDER_DATE
ORDER BY
	O.CUSTOMER_ID,
	O.ORDER_DATE
```

### 解説:

- サブクエリまたは GROUP BY 句での集計: まず、各注文の合計金額を SUM(oi.quantity \* p.price)で計算し、customer_id, order_id, order_date でグループ化します。
- PARTITION BY o.customer_id: 累計計算を顧客ごとに独立して行います。
- ORDER BY o.order_date ASC, o.order_id ASC: 各顧客のウィンドウ内で、注文を日付順（同じ日付の場合は order_id 順）に並べ替えます。この順序で累計が計算されます。
- ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW: ウィンドウフレームを定義します。これは、「現在の行から見て、その前のすべての行から現在の行まで」を対象とするという意味です。これにより、各行でその時点までの累計値が計算されます。ORDER BY 句のみを指定した場合、このフレームは暗黙的に適用されることが一般的ですが、明示することでコードの意図がより明確になります。

## 問題 3: 各商品カテゴリ内の商品価格ランキング

### 重要度: ★★★★★

### 問題目的: ROW_NUMBER, RANK, DENSE_RANK の違いと使用方法を理解する。特にランキング作成における必須知識。

### 問題: 各商品カテゴリ内で、価格の高い順に商品のランキングを付けてください。

1. 同価格の商品には異なる順位を割り当てる（連続した番号）。
2. 同価格の商品には同じ順位を割り当て、次の順位は同価格の商品の数だけスキップす
   る。
3. 同価格の商品には同じ順位を割り当て、次の順位はスキップしない（連続した順位）。

### 答え:

```SQL
SELECT
    p.product_name,
    c.category_name,
    p.price,
    ROW_NUMBER() OVER (PARTITION BY c.category_id ORDER BY p.price DESC) AS row_num,
    RANK() OVER (PARTITION BY c.category_id ORDER BY p.price DESC) AS rank_num,
    DENSE_RANK() OVER (PARTITION BY c.category_id ORDER BY p.price DESC) AS dense_rank_num
FROM
    Products p
JOIN
    Categories c ON p.category_id = c.category_id
ORDER BY
    c.category_name, p.price DESC;
```

バリエーション: 特定のカテゴリの上位 N 件を取得する場合など、WHERE 句やサブクエリでランキング結果を絞り込むことができます。例えば、各カテゴリで価格の高い上位 2 つの商品を取得する場合。

```SQL
WITH RankedProducts AS (
    SELECT
        p.product_name,
        c.category_name,
        p.price,
        RANK() OVER (PARTITION BY c.category_id ORDER BY p.price DESC) AS rank_num
    FROM
        Products p
    JOIN
        Categories c ON p.category_id = c.category_id
)
SELECT
    product_name,
    category_name,
    price,
    rank_num
FROM
    RankedProducts
WHERE
    rank_num <= 2
ORDER BY
    category_name, price DESC;
```

補足：評価順が where⇒window 関数の順なので、window 関数の行事結果をもとに where で絞りたい場合は、サブクエリで予めテーブル出力しておく必要がある。

### 解説:

- PARTITION BY c.category_id: カテゴリごとに独立したランキングを作成します。これにより、各カテゴリ内で商品の価格を比較し、順位を付けます。
- ORDER BY p.price DESC: 各カテゴリ内で、price が高い順に並べ替えます。
- ROW_NUMBER(): 各ウィンドウ内で、順序付けされた行に連続した一意の番号を割り当てます。同順位の行があったとしても、異なる番号が振られます。
- RANK(): 各ウィンドウ内で、順序付けされた行に順位を割り当てます。同順位の行には同じ番号が振られ、次の順位は同順位の行の数だけスキップされます。例えば、1 位が 2 つあった場合、次は 3 位になります。
- DENSE_RANK(): 各ウィンドウ内で、順序付けされた行に順位を割り当てます。同順位の行には同じ番号が振られますが、次の順位はスキップされず、連続した番号になります。例えば、1 位が 2 つあった場合、次は 2 位になります。
- これらの関数は、トップ N 分析や、グループ内での相対的な位置を特定する際によく使用されます。

## 問題 4: 各顧客の注文ごとの移動平均注文額

### 重要度: ★★★★

### 問題目的: AVG 関数と ROWS BETWEEN を使用した移動平均の計算方法を理解する。顧客の購買傾向分析に応用できる。

### 問題: 各顧客について、注文日順に、現在行とその過去 2 回分の注文（合計 3 回分）の合計金額の移動平均を計算してください。

### 答え:

```SQL
SELECT
	C.CUSTOMER_ID,
	P.PAYMENT_DATE,
	P.AMOUNT,
	AVG(P.AMOUNT) OVER (
		PARTITION BY
			C.CUSTOMER_ID
		ORDER BY
			P.PAYMENT_DATE ROWS BETWEEN 2 PRECEDING
			AND CURRENT ROW
	)
FROM
	PAYMENTS P
	JOIN ORDERS O ON P.ORDER_ID = O.ORDER_ID
	JOIN CUSTOMERS C ON C.CUSTOMER_ID = O.CUSTOMER_ID
```

バリエーション：量\*値段で計算オーダーごとの注文を計算

```SQL
WITH
	CUSTOMERORDERTOTALS AS (
		SELECT
			O.CUSTOMER_ID,
			O.ORDER_ID,
			O.ORDER_DATE,
			SUM(OI.QUANTITY * P.PRICE) AS ORDER_TOTAL
		FROM
			ORDERS O
			JOIN ORDERITEMS OI ON O.ORDER_ID = OI.ORDER_ID
			JOIN PRODUCTS P ON OI.PRODUCT_ID = P.PRODUCT_ID
		GROUP BY
			O.CUSTOMER_ID,
			O.ORDER_ID,
			O.ORDER_DATE
	)
SELECT
	COT.CUSTOMER_ID,
	COT.ORDER_ID,
	COT.ORDER_DATE,
	COT.ORDER_TOTAL,
	AVG(COT.ORDER_TOTAL) OVER (
		PARTITION BY
			COT.CUSTOMER_ID
		ORDER BY
			COT.ORDER_DATE ASC,
			COT.ORDER_ID ASC ROWS BETWEEN 2 PRECEDING
			AND CURRENT ROW
	) AS MOVING_AVG_ORDER_TOTAL
FROM
	CUSTOMERORDERTOTALS COT
ORDER BY
	COT.CUSTOMER_ID,
	COT.ORDER_DATE,
	COT.ORDER_ID;
```

バリエーション: RANGE BETWEEN を使用すると、値の範囲でウィンドウを定義できます。例えば、各顧客について、現在行の注文日から過去 30 日間の注文合計額の移動平均を計算する場合。（RDBMS によって日付計算の構文が異なるため、ここでは PostgreSQL の例として示
します。）

```SQL
-- PostgreSQL の場合の例 (RDBMS によって構文が異なります)
WITH CustomerOrderTotals AS (
    SELECT
        o.customer_id,
        o.order_id,
        o.order_date,
        SUM(oi.quantity \* p.price) AS order_total
    FROM
        Orders o
    JOIN
        OrderItems oi ON o.order_id = oi.order_id
    JOIN
        Products p ON oi.product_id = p.product_id
    GROUP BY
        o.customer_id, o.order_id, o.order_date
)
SELECT
    cot.customer_id,
    cot.order_id,
    cot.order_date,
    cot.order_total,
    AVG(cot.order_total) OVER (
        PARTITION BY cot.customer_id ORDER BY cot.order_date ASC RANGE BETWEEN INTERVAL '30 day' PRECEDING AND CURRENT ROW -- 現在の注文日から過去 30 日間の平均
    ) AS moving_avg_order_total_range
FROM
    CustomerOrderTotals cot
ORDER BY
    cot.customer_id, cot.order_date, cot.order_id;
```

### 解説:

- WITH CustomerOrderTotals AS (...): まず、CTE で各注文の合計金額を前もって計算します。これにより、メインクエリで集計された注文額を Window 関数で利用できるようになります。
- PARTITION BY cot.customer_id: 顧客ごとに独立した移動平均を計算します。
- ORDER BY cot.order_date ASC, cot.order_id ASC: 各顧客のウィンドウ内で、注文を日付順（同じ日付の場合は order_id 順）に並べ替えます。この順序で移動平均が計算されます。
- ROWS BETWEEN 2 PRECEDING AND CURRENT ROW: ウィンドウフレームを定義します。これは、「現在の行から見て、その前の 2 行と現在の行」の計 3 行を対象とすることを意味します。この 3 行の order_total の平均が AVG()関数によって計算されます。顧客の購買傾向を平滑化して見たり、短期的な変動を把握したりするのに役立ちます。

## 問題 5: 各注文の前の注文からの経過日数

### 重要度: ★★★★

### 問題目的: LAG 関数を使用した、前行のデータを参照する方法を理解する。時系列データ分析で頻出。

### 問題: 各顧客について、注文日順に、それぞれの注文がその顧客の前の注文から何日後にあったかを計算してください。最初の注文には NULL を返してください。

### 答え:

```SQL
SELECT
    o.customer_id,
    o.order_id,
    o.order_date,
    LAG(o.order_date, 1, NULL) OVER (
        PARTITION BY o.customer_id
        ORDER BY o.order_date ASC
    ) AS previous_order_date,
    -- JULIANDAY(o.order_date) - JULIANDAY(LAG(o.order_date, 1, NULL)OVER (PARTITION BY o.customer_id ORDER BY o.order_date ASC)) AS days_since_previous_order -- SQLite の場合
    -- DATEDIFF(o.order_date, LAG(o.order_date, 1, NULL) OVER(PARTITION BY o.customer_id ORDER BY o.order_date ASC)) AS days_since_previous_order -- SQL Server の場合
    o.order_date - LAG(o.order_date, 1, NULL) OVER (
        PARTITION BY o.customer_id ORDER BY o.order_date ASC
    ) AS days_since_previous_order -- PostgreSQL の場合
FROM
    Orders o
ORDER BY
    o.customer_id, o.order_date;
```

バリエーション: LEAD 関数を使用すると、次行のデータを参照できます。例えば、次の注文までの日数を計算するのに使えます。また、日数の計算方法は RDBMS によって異なるため、使用する RDBMS に合わせて調整が必要です。以下は次の注文までの日数を計算する例です。

```SQL
SELECT
    o.customer_id,
    o.order_id,
    o.order_date,
    LEAD(o.order_date, 1, NULL) OVER (
        PARTITION BY o.customer_id
        ORDER BY o.order_date ASC
    ) AS next_order_date,
    -- JULIANDAY(LEAD(o.order_date, 1, NULL) OVER (PARTITION BY o.customer_id ORDER BY o.order_date ASC)) -JULIANDAY(o.order_date) AS days_until_next_order -- SQLite の場合
    -- DATEDIFF(LEAD(o.order_date, 1, NULL) OVER (PARTITION BY o.customer_id ORDER BY o.order_date ASC), o.order_date) AS days_until_next_order -- SQL Server の場合
    LEAD(o.order_date, 1, NULL) OVER (
        PARTITION BY o.customer_id ORDER BY o.order_date ASC
    ) - o.order_date AS days_until_next_order -- PostgreSQL の場合
FROM
    Orders o
ORDER BY
    o.customer_id, o.order_date;
```

### 解説:

- LAG(column, offset, default): 現在の行から指定された offset（オフセット）だけ前の行の column の値を返します。offset のデフォルトは 1 です。default は、前の行が存在しない場合に返す値（通常は NULL）です。
- PARTITION BY o.customer_id: 顧客ごとに独立して前の注文を検索します。
- ORDER BY o.order_date ASC: 各顧客の注文を日付順に並べ替えます。LAG 関数はこの順序に基づいて前の行を特定します。
- LEAD(column, offset, default): LAG とは逆に、現在の行から指定された offset だけ後の行の column の値を返します。
- 日付の差分計算: JULIANDAY() (SQLite), DATEDIFF() (SQL Server), 単純な日付の減算 (PostgreSQL) など、RDBMS によって日付の差分を計算する方法が異なります。実務では使用する RDBMS のドキュメントを確認してください。

## 問題 6: 各注文が全顧客の平均注文額と比較してどれくらい乖離しているか

### 重要度: ★★★★

### 問題目的: ウィンドウ関数と集約関数の組み合わせ、および全体平均との比較を行う方法を理解する。

### 問題: 各注文について、その注文の合計金額（OrderItems.quantity \* Products.price の合計）と、全注文の平均合計金額との差分を計算してください。

### 答え:

```SQL
SELECT
	OT.ORDER_ID,
	OT.ORDER_TOTAL,
	AVG(OT.ORDER_TOTAL) OVER () AS OVERALL_AVG_ORDER_TOTAL,
	OT.ORDER_TOTAL - AVG(OT.ORDER_TOTAL) OVER () AS DIFFERENCE_FROM_AVG
FROM
	(
		SELECT
			O.ORDER_ID,
			SUM(OI.QUANTITY * P.PRICE) AS ORDER_TOTAL
		FROM
			ORDERS O
			JOIN ORDERITEMS OI ON O.ORDER_ID = OI.ORDER_ID
			JOIN PRODUCTS P ON OI.PRODUCT_ID = P.PRODUCT_ID
		GROUP BY
			O.ORDER_ID
	) OT
ORDER BY
	OT.ORDER_ID;
```

バリエーション：CTE 使えれば、、、

```SQL
WITH OrderTotals AS (
    SELECT
        o.order_id,
        SUM(oi.quantity * p.price) AS order_total
    FROM
        Orders o
    JOIN
        OrderItems oi ON o.order_id = oi.order_id
    JOIN
        Products p ON oi.product_id = p.product_id
    GROUP BY
        o.order_id
)
SELECT
    ot.order_id,
    ot.order_total,
    AVG(ot.order_total) OVER () AS overall_avg_order_total,
    ot.order_total - AVG(ot.order_total) OVER ()  AS　difference_from_avg
FROM
    OrderTotals ot
ORDER BY
    ot.order_id;

```

バリエーション: overall_avg_order_total は、サブクエリで事前に計算して結合することも可能ですが、OVER ()を使用することで、より簡潔に記述できます。

```SQL
WITH OrderTotals AS (
    SELECT
        o.order_id,
        SUM(oi.quantity * p.price) AS order_total
    FROM
        Orders o
    JOIN
        OrderItems oi ON o.order_id = oi.order_id
    JOIN
        Products p ON oi.product_id = p.product_id
    GROUP BY
        o.order_id
),
OverallAverage AS (
    SELECT
        AVG(order_total) AS avg_total
    FROM
        OrderTotals
)
SELECT
    ot.order_id,
    ot.order_total,
    oa.avg_total AS overall_avg_order_total,
    ot.order_total - oa.avg_total AS difference_from_avg
FROM
    OrderTotals ot, OverallAverage oa
ORDER BY
    ot.order_id;
```

### 解説:

- WITH OrderTotals AS (...): まず、CTE (Common Table Expression) を使って、各注文の合計金額を前処理で計算しておきます。これにより、メインクエリが読みやすくなります。
- AVG(ot.order_total) OVER (): ここがこの問題の重要なポイントです。OVER ()のように PARTITION BY 句を省略すると、結果セット全体を一つのウィンドウと見なします。つまり、OrderTotals CTE から返されるすべての注文の合計金額の平均が計算され、それが各行に適用されます。これにより、各注文の合計金額を全体の平均と比較できます。
- サブクエリでの計算との比較: OVER ()を使わずに、別のサブクエリで全体の平均を計算し、それを結合することも可能です。しかし、OVER ()を使用する方がコードがより簡潔になり、特に同じウィンドウ関数を複数回使用する場合に効率的です。どちらを使うかは、可読性やパフォーマンス要件によって判断すると良いでしょう。

## 問題 7: 顧客を累計注文額で 4 つのグループに分割する

### 重要度: ★★★

### 問題目的: NTILE()関数を使用して、データセットを等しい（またはほぼ等しい）サイズのグループに分割する方法を理解する。顧客セグメンテーションに応用できる。

### 問題: 各顧客の累計注文額を算出し、その累計注文額が高い順に、全顧客を 4 つのグループ（NTILE）に分割してください。それぞれの顧客がどのグループに属するかを表示してください。

### 答え:

```SQL
WITH CustomerLifetimeValue AS (
    SELECT
        c.customer_id,
        c.name,
        SUM(oi.quantity * p.price) AS lifetime_order_value
    FROM
        Customers c
    JOIN
        Orders o ON c.customer_id = o.customer_id
    JOIN
        OrderItems oi ON o.order_id = oi.order_id
    JOIN
        Products p ON oi.product_id = p.product_id
    GROUP BY
        c.customer_id, c.name
)
SELECT
    clv.customer_id,
    clv.name,
    clv.lifetime_order_value,
    NTILE(4) OVER (ORDER BY clv.lifetime_order_value DESC) AS customer_group
FROM
    CustomerLifetimeValue clv
ORDER BY
    customer_group, clv.lifetime_order_value DESC;
```

### 解説:

- WITH CustomerLifetimeValue AS (...): まず、CTE で各顧客の累計注文額（Lifetime_Order_Value, LTV）を計算します。これは、顧客の価値を測る重要な指標です。
- NTILE(N): ウィンドウフレーム内の行を N 個のほぼ等しいサイズのグループに分割し、各グループに行番号を割り当てます。この問題では NTILE(4)なので、顧客を 4 つのグループに分けます。
- ORDER BY clv.lifetime_order_value DESC: NTILE()は、この順序に基づいてグループを割り当てます。累計注文額が高い順にグループ分けするため、降順にソートします。これにより、グループ 1 が最も累計注文額が高い顧客の集まりとなります。
- NTILE()は、顧客のセグメンテーションや、データセットを四分位数などの特定数のグループに分割する際に非常に役立ちます。

## 問題 8: 各商品カテゴリ内での価格パーセンタイルランク

### 重要度: ★★★★

### 問題目的: PERCENT_RANK()関数を使用して、各行がウィンドウ内の他の行と比較してどのパーセンタイルに位置するかを理解する。商品の価格競争力分析に応用できる。

### 問題: 各商品カテゴリ内で、商品の価格がそのカテゴリ内の他の商品と比較してどの程度のパーセンタイルに位置するかを計算してください。（PERCENT_RANK を使用）

### 答え:

```SQL
SELECT
    p.product_name,
    c.category_name,
    p.price,
    PERCENT_RANK() OVER (
        PARTITION BY c.category_id ORDER BY p.price ASC
    ) AS price_percent_rank
FROM
    Products p
JOIN
    Categories c ON p.category_id = c.category_id
ORDER BY
    c.category_name, p.price ASC;
```

バリエーション: 価格の高い順でパーセンタイルランクを見る場合は ORDER BY p.price DESC とします。

```SQL
SELECT
    p.product_name,
    c.category_name,
    p.price,
    PERCENT_RANK() OVER (PARTITION BY c.category_id ORDER BY p.price DESC) AS price_percent_rank_desc
FROM
    Products p
JOIN
    Categories c ON p.category_id = c.category_id
ORDER BY
    c.category_name, p.price DESC;
```

### 解説:

- PERCENT_RANK(): ウィンドウ内の行のパーセンタイルランクを計算します。値は 0 から 1 の範囲で、0 は最低値、1 は最高値を意味します。（厳密には (rank - 1) / (rows in window - 1) で計算されます。）
- PARTITION BY c.category_id: 商品カテゴリごとに独立してパーセンタイルランクを計算します。これにより、同じカテゴリ内の商品同士で価格を比較できます。
- ORDER BY p.price ASC: 価格が低いほどパーセンタイルランクが低く（0 に近く）、価格が高いほどパーセンタイルランクが高く（1 に近く）なるように計算します。もし高い価格のものが高いランクであることを示したい場合は DESC を使用します。
- この関数は、特定のカテゴリ内で自社製品の価格がどれくらいの競争力があるか、あるいはどの層に位置しているかなどを分析する際に有用です。

# Window 関数 頻出パターン一覧（本研修でカバー済み）

## ランキング関数

### 関連関数: ROW_NUMBER(), RANK(), DENSE_RANK(), NTILE(N)

### 分析の課題:

- グループ内での順位付け: 特定の指標（売上、評価、パフォーマンスなど）に基づいて、各グループ（カテゴリ、顧客、従業員など）内でデータの順位を把握したい。
- トップ N 分析: 各グループで上位 N 件のデータ（例: 各カテゴリで売上トップ 3 の商品）を抽出したい。
- 均等なグループ分割: 全体のデータセットを均等なサイズのグループに分割し、顧客セグメンテーション（例: 優良顧客、一般顧客）やパフォーマンス階層（例: 上位 25%、中位 50%）を作成したい。

### 具体的な使われ方:

- ROW_NUMBER(): 厳密な順位（同値でもユニークな番号）が必要な場合。例えば、各顧客の購入履歴を時系列で 1, 2, 3...と番号付けし、最初の購入を特定する。
- RANK(): 同順位の項目は同じ順位とし、次の順位をスキップする場合。例えば、各商品カテゴリ内で価格の高い順に順位を付け、同価格の商品がある場合は同じ順位とし、次に続く順位は飛ばす。
- DENSE_RANK(): 同順位の項目は同じ順位とし、次の順位をスキップしない場合。例えば、上記と同様に価格ランキングを付けるが、順位を連続させたい（1 位、1 位、2 位、3 位...）。
- NTILE(N): 全体を N 個のグループに分ける場合。例えば、顧客の累計購入金額で上位 25%を「プラチナ」、次の 25%を「ゴールド」といった顧客セグメントを定義する。

## 値分析関数

### 関連関数: FIRST_VALUE(), LAST_VALUE(), LAG(), LEAD()

### 分析の課題:

- グループ内の最初/最後のイベント: 各グループ（顧客、商品など）で、最初または最後に発生したイベントやその時点での値を知りたい。
- 時系列データの前後の比較: 時間の経過とともに変化するデータ（売上、株価、在庫数など）において、前後の期間との差分、比率、または間隔を計算したい。

### 具体的な使われ方:

- FIRST_VALUE(): 各顧客の最初の注文日や、特定商品の初回販売価格などを取得する。
- LAST_VALUE(): 各顧客の最新の注文日や、特定商品の最終販売価格などを取得する。
- LAG(): 顧客の各注文について、前回の注文からの経過日数を計算し、購入頻度を分析する。月次売上データで前月比の成長率を算出する。
- LEAD(): 顧客の各注文について、次回の注文までの日数を計算する。

## 集約関数としての Window 関数（移動集約・全体集約）

### 関連関数: SUM() OVER (...), AVG() OVER (...), COUNT() OVER (...), MIN() OVER (...),MAX() OVER (...)

### 分析の課題:

- 累計値の把握: 時系列データにおける累計の進捗状況（例: 年間累計売上高、キャンペーン期間中の累計参加者数）を各時点で見たい。
- トレンドの平滑化: 一時的な変動（ノイズ）の影響を受けやすい時系列データ（例: 日次売上）に対して、移動平均を計算して長期的なトレンドを把握したい。
- グループ全体の統計量との比較: 個々のデータポイント（例: 各注文の合計金額）を、それらが属するグループや全体の平均、最大値、最小値などと比較して、相対的な位置を評価したい。

### 具体的な使われ方:

- SUM() OVER (ORDER BY ...): 月ごとの売上データを週ごとに集計し、年間の累計売上高を算出する。
- AVG() OVER (ORDER BY ... ROWS BETWEEN ...): 日次売上データに対して過去 7 日間の移動平均を計算し、週間のトレンドを把握する。
- AVG() OVER (): 各注文の合計金額を、全注文の平均合計金額と比較し、特定の注文が平均よりどれだけ高いか/低いかを分析する。
- MIN() / MAX() OVER (PARTITION BY ...): 各商品の販売履歴において、過去の最大
  価格や最小価格を比較する。

## 分布分析関数

### 関連関数: PERCENT_RANK()

### 分析の課題:

- 相対的な位置の評価: 各データポイントが、全体またはグループ内の他のデータと比較して、どの程度の割合の位置に存在するか（パーセンタイル）を評価したい。

### 具体的な使われ方:

- PERCENT_RANK(): 特定の商品の価格が、同じ商品カテゴリ内の他の全商品の価格と比較して、上位何パーセントに位置するかを評価し、価格競争力を分析する。顧客の平均購入額が、全顧客の中で上位何パーセントに位置するかを知りたい。
