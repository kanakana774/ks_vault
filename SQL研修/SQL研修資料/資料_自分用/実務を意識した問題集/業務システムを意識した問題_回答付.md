# 社内備品管理システム
## 1. テーブル構造と問題用データ

### テーブル定義 (DDL)

```sql
-- 部署マスタ
CREATE TABLE departments (
    department_id INTEGER PRIMARY KEY,
    department_name VARCHAR(50) NOT NULL
);

-- 社員マスタ
CREATE TABLE employees (
    employee_id INTEGER PRIMARY KEY,
    employee_name VARCHAR(50) NOT NULL,
    department_id INTEGER NOT NULL REFERENCES departments(department_id)
);

-- 備品カテゴリマスタ
CREATE TABLE item_categories (
    category_id INTEGER PRIMARY KEY,
    category_name VARCHAR(50) NOT NULL
);

-- 備品マスタ
CREATE TABLE items (
    item_id INTEGER PRIMARY KEY,
    asset_tag VARCHAR(20) NOT NULL UNIQUE, -- 管理番号 (例: PC-001)
    item_name VARCHAR(100) NOT NULL,
    category_id INTEGER NOT NULL REFERENCES item_categories(category_id),
    purchase_date DATE NOT NULL,
    purchase_price INTEGER NOT NULL,
    status_id SMALLINT NOT NULL -- 1:在庫, 2:使用中, 9:廃棄済
);

-- 貸出履歴テーブル
CREATE TABLE rental_history (
    history_id INTEGER PRIMARY KEY,
    item_id INTEGER NOT NULL REFERENCES items(item_id),
    employee_id INTEGER NOT NULL REFERENCES employees(employee_id),
    rental_start_date DATE NOT NULL,
    return_date DATE -- 返却日 (NULLの場合は現在も貸出中)
);
```

### 問題用データ (DML)

```sql
-- データ挿入
INSERT INTO departments VALUES (1, '営業部'), (2, '開発部'), (3, '総務部');
INSERT INTO employees VALUES (101, '田中 太郎', 1), (102, '佐藤 花子', 2), (103, '鈴木 誠', 2);
INSERT INTO item_categories VALUES (10, 'ノートPC'), (20, 'モニター'), (30, 'ソフトウェア');
INSERT INTO items VALUES
(1001, 'PC-001', 'Let''s Note CF-SV', 10, '2023-04-01', 250000, 2), -- 使用中
(1002, 'PC-002', 'MacBook Pro 14', 10, '2023-04-10', 300000, 2), -- 使用中
(1003, 'PC-003', 'Let''s Note CF-SV', 10, '2023-05-01', 250000, 1), -- ★罠データ: 貸出中なのにステータスが「在庫」
(1004, 'PC-004', 'MacBook Pro 14', 10, '2021-08-01', 280000, 9), -- 廃棄済
(2001, 'MON-001', 'FlexScan 24', 20, '2023-04-01', 50000, 2), -- 使用中
(2002, 'MON-002', 'FlexScan 24', 20, '2023-06-01', 50000, 1); -- 在庫
INSERT INTO rental_history VALUES
(1, 1001, 101, '2023-04-05', '2024-03-31'), -- 返却済み
(2, 1001, 102, '2024-04-01', NULL),       -- 現在、佐藤さんが使用中
(3, 1002, 103, '2023-04-15', NULL),       -- 現在、鈴木さんが使用中
(4, 2001, 102, '2023-04-05', NULL),       -- 現在、佐藤さんが使用中
(5, 1003, 101, '2023-05-10', NULL);       -- 現在、田中さんが使用中
```

---

## 2. 研修問題 (5問)

### 問題1：現状把握 - 「現在貸出中」の備品一覧作成

**【システム上の目的】**
情報システム部が、現在誰がどの備品を利用しているかを正確に把握するためのリストを作成します。このリストは、棚卸しやソフトウェアライセンスの監査の基礎データとなります。

**【課題】**
「現在貸出中」の備品について、以下の項目を一覧表示するSQLを作成してください。
*   `管理番号 (asset_tag)`, `備品名 (item_name)`, `利用者名 (employee_name)`, `所属部署名 (department_name)`, `貸出開始日 (rental_start_date)`

**【条件】**
*   `rental_history`テーブルの`return_date`が`NULL`のレコードが「現在貸出中」を意味します。

---

#### 解答例と解説（問題1）

**● 解答SQL**
```sql
SELECT
    i.asset_tag,
    i.item_name,
    e.employee_name,
    d.department_name,
    rh.rental_start_date
FROM
    rental_history AS rh
INNER JOIN
    items AS i ON rh.item_id = i.item_id
INNER JOIN
    employees AS e ON rh.employee_id = e.employee_id
INNER JOIN
    departments AS d ON e.department_id = d.department_id
WHERE
    rh.return_date IS NULL
ORDER BY
    d.department_name, e.employee_name;
```

**● 思考プロセス**
1.  **【データの意味を考える】** 「現在貸出中」という業務要件を、`WHERE rh.return_date IS NULL` というSQLの条件に変換できるかが最初のポイントです。
2.  必要な情報は複数のテーブルに分散しているため、`JOIN`を使って結合します。貸出履歴(`rental_history`)を中心に、備品情報(`items`)、社員情報(`employees`)、部署情報(`departments`)を順に`INNER JOIN`で繋ぎます。
3.  `SELECT`句に必要なカラム名を指定し、`ORDER BY`で見やすいように並べ替えて完成です。

**● 問題の意図**
*   **JOINの基本**: 複数テーブルを結合して必要な情報を集める、SQLの最も基本的な操作を確実にマスターさせます。
*   **業務要件のSQLへの変換**: 「貸出中」のような日常的な言葉を、`IS NULL`というデータベース上の条件に正しく変換する論理的思考を養います。
*   **品質担保**: `WHERE`句の条件が漏れると、過去の返却済みデータまで含まれてしまい、誤ったリストを作成してしまうことを理解させます。

**● 検証の例**
1.  `WHERE`句を付けずに一度実行し、返却済み(`history_id = 1`)のデータも含まれてしまうことを確認します。これにより、`WHERE`句の重要性を体感できます。
2.  手作業でデータを確認します。`rental_history`で`return_date`がNULLなのは`history_id`が2, 3, 4, 5の4件です。SQLの実行結果が4件になっていることを確認します。

---

### 問題2：コスト集計 - 部署別の備品購入金額レポート

**【システム上の目的】**
経理部が、来年度のIT関連予算を策定するための参考資料として、部署ごとに現在どれくらいの金額の備品が割り当てられているかを把握するためのレポートを作成します。

**【課題】**
**全ての部署**を対象に、各部署に所属する社員が現在利用している備品の**購入金額の合計**を算出するSQLを作成してください。

**【条件】**
*   `部署名`と`合計購入金額`を出力してください。
*   もし、ある部署が備品を1つも利用していない場合でも、その部署名をリストに表示し、合計金額は`0`としてください。
*   廃棄済みの備品は集計対象外とします。

---

#### 解答例と解説（問題2）

**● 解答SQL**
```sql
SELECT
    d.department_name,
    COALESCE(SUM(i.purchase_price), 0) AS total_price
FROM
    departments AS d
LEFT JOIN
    employees AS e ON d.department_id = e.department_id
LEFT JOIN
    rental_history AS rh ON e.employee_id = rh.employee_id AND rh.return_date IS NULL
LEFT JOIN
    items AS i ON rh.item_id = i.item_id AND i.status_id <> 9
GROUP BY
    d.department_id, d.department_name
ORDER BY
    d.department_name;
```

**● 思考プロセス**
1.  **【データの意味を考える】** 「全ての部署」を表示するのが要件なので、`departments`テーブルを主役（駆動表）にする必要があります。したがって`FROM departments`から始め、`LEFT JOIN`を使って他のテーブルを結合していきます。
2.  部署(`d`) → 社員(`e`) → 貸出履歴(`rh`) → 備品(`i`) の順に`LEFT JOIN`で繋ぎます。
3.  **【品質担保】** `rental_history`テーブルとの結合条件に`AND rh.return_date IS NULL`を加えることで、「現在貸出中の備品」に限定します。同様に、`items`テーブルとの結合条件に`AND i.status_id <> 9`を加え、廃棄済みの備品を除外します。
4.  `GROUP BY`で部署ごとに集計し、`SUM`で合計金額を計算します。
5.  備品を利用していない部署（総務部）は`SUM`の結果が`NULL`になるため、`COALESCE`関数を使って`0`に変換します。

**● 問題の意図**
*   **LEFT JOINの理解**: 「データがない場合も表示する」という要件を満たすために`LEFT JOIN`がなぜ必要なのかを理解させます。`INNER JOIN`を使ってしまうと「総務部」が表示されず、要件を満たせないことを体感させます。
*   **集計関数の正しい使い方**: `GROUP BY`と`SUM`関数を組み合わせた基本的な集計スキルを確認します。
*   **NULLの処理**: `COALESCE`を使って、見た目の良いレポートを作成するためのデータ整形スキルを身につけさせます。

**● 検証の例**
1.  解答SQLの`LEFT JOIN`を全て`INNER JOIN`に変えて実行してみます。「総務部」の行が表示されなくなることを確認し、JOINの種類が結果に与える影響を理解します。
2.  開発部の合計金額を手計算します。
    *   佐藤さん(102): PC-001(250,000円) + MON-001(50,000円) = 300,000円
    *   鈴木さん(103): PC-002(300,000円) = 300,000円
    *   開発部合計: 600,000円。SQLの実行結果と一致することを確認します。

---

### 問題3：データメンテナンス - 古い備品ステータスの一括更新

**【システム上の目的】**
定期的な資産管理の一環として、購入から一定期間が経過した備品の状態を見直す必要があります。今回は、購入から3年以上経過した「ノートPC」について、まだ廃棄処理されていないもののステータスを、一括で「要確認」というステータス（ここでは仮に`status_id = 5`とします）に更新するバッチ処理を行います。

**【課題】**
以下の条件に合致する備品の`status_id`を`5`に更新する`UPDATE`文を作成してください。

**【条件】**
*   備品カテゴリが「ノートPC」である。
*   購入日(`purchase_date`)が、本日（仮に`2025-11-08`とする）から数えて3年以上前である。
*   現在のステータスが「廃棄済(`status_id = 9`)」ではない。

**【指示】**
安全に作業を行うため、**まず`UPDATE`文の`WHERE`句に記述する条件を使って`SELECT`文を作成し、更新対象となるレコードが意図通りかを確認してください。** その後、`UPDATE`文を作成してください。

---

#### 解答例と解説（問題3）

**● 解答SQL**

**【ステップ1：事前検証のSELECT文】**
```sql
SELECT
    i.item_id,
    i.asset_tag,
    i.item_name,
    ic.category_name,
    i.purchase_date,
    i.status_id
FROM
    items AS i
INNER JOIN
    item_categories AS ic ON i.category_id = ic.category_id
WHERE
    ic.category_name = 'ノートPC'
    AND i.purchase_date <= CAST('2025-11-08' AS DATE) - INTERVAL '3 year'
    AND i.status_id <> 9;
```
*(実行結果)*

| item\_id | asset\_tag | item\_name     | category\_name | purchase\_date | status\_id |
| :------- | :--------- | :------------- | :------------- | :------------- | :--------- |

*「対象データがない」ことを確認させる。*「該当なし」なので、以降は実行しない

**【ステップ2：UPDATE文】**
```sql
UPDATE items
SET status_id = 5
WHERE
    item_id IN (
        -- 事前検証SELECTで使ったロジックをサブクエリにする
        SELECT
            i.item_id
        FROM
            items AS i
        INNER JOIN
            item_categories AS ic ON i.category_id = ic.category_id
        WHERE
            ic.category_name = 'ノートPC'
            AND i.purchase_date <= CAST('2025-11-08' AS DATE) - INTERVAL '3 year'
            AND i.status_id <> 9
    );
```

**● 思考プロセス**
1.  **【品質担保】** `UPDATE`や`DELETE`を実行する前には、必ず対象行を特定する`SELECT`文を書く、という鉄則を実践させます。
2.  `WHERE`句の条件を組み立てます。
    *   カテゴリ名での絞り込みは、`item_categories`テーブルとのJOINが必要です。
    *   日付の計算は、`CAST`で文字列を日付型に変換し、`INTERVAL`を使って3年前の日付を算出します。`purchase_date <= (今日 - 3年)`という条件式を組み立てます。
    *   廃棄済み除外の条件 `status_id <> 9` を追加します。
3.  この`SELECT`文で更新対象が正しいことを確認した後、同じロジックをサブクエリとして`UPDATE`文の`WHERE item_id IN (...)`句に埋め込みます。この書き方は多くのRDBMSで通用する汎用的な方法です。

**● 問題の意図**
*   **安全な更新手順の徹底**: 「`SELECT`での事前確認」という、データ変更作業における最も重要な安全手順を体に覚えさせます。
*   **日付関数の使用**: `INTERVAL`を使った日付計算は実務で頻出するため、その基本的な使い方を学びます。
*   **サブクエリの活用**: `UPDATE`文の条件式に`SELECT`文の結果（サブクエリ）を使う方法を習得させます。

**● 検証の例**
1.  事前検証`SELECT`の`WHERE`句の条件を一つずつ外してみて、結果がどのように変わるかを確認します（例：`status_id <> 9`を外すと`PC-004`がヒットする、など）。
2.  `UPDATE`実行後、`SELECT * FROM items WHERE status_id = 5;` を実行し、意図したレコードだけが更新されていることを確認します。

---

### 問題4：データ整合性チェック - 矛盾データの検出

**【システム上の目的】**
アプリケーションのバグや手動操作のミスにより、データの不整合が発生することがあります。情報システム部は、データの信頼性を維持するため、矛盾した状態のデータが存在しないかを定期的にチェックする必要があります。

**【課題】**
備品マスタ(`items`)のステータスが「在庫(`status_id = 1`)」となっているにもかかわらず、貸出履歴(`rental_history`)上では「現在貸出中(`return_date`が`NULL`)」となっている、**矛盾した備品**をすべて特定するSQLを作成してください。

---

#### 解答例と解説（問題4）

**● 解答SQL**
```sql
SELECT
    i.item_id,
    i.asset_tag,
    i.item_name,
    i.status_id
FROM
    items AS i
WHERE
    i.status_id = 1 -- ステータスが「在庫」であり、
    AND EXISTS ( -- なおかつ、この備品IDに紐づく「貸出中」の履歴が1件でも存在する
        SELECT 1
        FROM rental_history AS rh
        WHERE
            rh.item_id = i.item_id -- 外側のitemsテーブルと紐付け
            AND rh.return_date IS NULL
    );
```

**● 思考プロセス**
1.  **【データの意味を考える】** 矛盾の定義は「Aである、かつ、Bでもある」という状態です。これをSQLで表現する方法を考えます。
    *   A: `items.status_id = 1`
    *   B: `rental_history`に、該当`item_id`の`return_date IS NULL`のレコードが存在する。
2.  まず、調査対象の`items`テーブルから`status_id = 1`の備品を絞り込みます。
3.  次に、絞り込んだ各備品に対して、「貸出中の履歴が存在するか？」をチェックします。このような「存在チェック」には`EXISTS`句が非常に適しています。
4.  `EXISTS`句の中のサブクエリは、外側の`items`テーブルの`item_id`（`i.item_id`）と`rental_history`の`item_id`を紐付け（これを相関サブクエリと呼びます）、`return_date IS NULL`のレコードを探します。該当するレコードが1件でも見つかれば`EXISTS`は`TRUE`を返し、その備品が結果に含まれます。

**● 問題の意図**
*   **データ不整合の発見ロジック**: 複数のテーブル間の状態を比較し、矛盾を検出するという、データ監査や障害調査で非常に重要な思考パターンを学びます。
*   **EXISTS句の理解**: `IN`句や`JOIN`でも同様の結果を得られますが、「存在するかどうか」だけを確認したい場合には`EXISTS`が効率的かつ意図が明確になります。その使い方を習得させます。
*   **相関サブクエリ**: サブクエリが単独で動くのではなく、外側のクエリと連携して動く「相関サブクエリ」の概念を理解させます。

**● 検証の例**
1.  データセット内の矛盾データは`item_id = 1003`です。SQLの実行結果がこの1件のみになることを確認します。
2.  `item_id = 1003`の`items.status_id`を`2`（使用中）に手動で`UPDATE`した後、再度この問題の`SELECT`文を実行し、結果が0件になる（矛盾が解消された）ことを確認します。

---

### 問題5：棚卸しレポート - CASE式を使った状態表示

**【システム上の目的】**
年に一度の資産棚卸しのために、全ての備品をリストアップし、それぞれの現在の状況をひと目で把握できるレポートを作成します。

**【課題】**
**廃棄済みを除く全ての備品**を対象に、以下の項目を出力するSQLを作成してください。
*   `管理番号 (asset_tag)`, `備品名 (item_name)`, `現在の状態 (status_text)`, `現在の利用者名 (current_user_name)`

**【条件】**
*   「現在の状態」は、`rental_history`に`return_date IS NULL`のレコードが存在すれば「貸出中」、存在しなければ「在庫」という文字列で表示してください。
*   「現在の利用者名」は、「貸出中」の場合はその社員名を表示し、「在庫」の場合は`NULL`または空欄で表示してください。
*   `CASE`式を使って、条件に応じた表示の切り替えを行ってください。

---

#### 解答例と解説（問題5）

**● 解答SQL**
```sql
SELECT
    i.asset_tag,
    i.item_name,
    CASE
        WHEN rh.employee_id IS NOT NULL THEN '貸出中'
        ELSE '在庫'
    END AS status_text,
    e.employee_name AS current_user_name
FROM
    items AS i
LEFT JOIN
    rental_history AS rh ON i.item_id = rh.item_id AND rh.return_date IS NULL
LEFT JOIN
    employees AS e ON rh.employee_id = e.employee_id
WHERE
    i.status_id <> 9
ORDER BY
    i.asset_tag;
```

**● 思考プロセス**
1.  **【データの意味を考える】** レポートの主役は「全ての備品」なので、`items`テーブルを`FROM`句の主役に置きます。
2.  各備品が「現在貸出中か」を判定するために、`rental_history`テーブルを`LEFT JOIN`で結合します。結合条件に`AND rh.return_date IS NULL`を含めるのがポイントです。
    *   もし、ある備品が現在貸出中であれば、対応する`rental_history`の行が見つかり、`rh`の各カラムには値が入ります。
    *   もし、在庫であれば、対応する行が見つからず、`rh`の各カラムは`NULL`になります。
3.  この`LEFT JOIN`の結果（`rh`のカラムが`NULL`か否か）を利用して、`CASE`式で表示を分岐させます。`WHEN rh.employee_id IS NOT NULL`（貸出履歴が見つかった）なら「貸出中」、そうでなければ「在庫」と表示します。
4.  利用者名も同様に、`LEFT JOIN`で`employees`テーブルを結合します。在庫の備品の場合、`rh.employee_id`が`NULL`なので、`e.employee_name`も自動的に`NULL`となり、要件を満たせます。
5.  最後に`WHERE`句で廃棄済みの備品を除外して完成です。

**● 問題の意図**
*   **CASE式の実践的活用**: 条件に応じて表示内容を動的に変更する`CASE`式の使い方をマスターさせます。
*   **LEFT JOINとCASE式の組み合わせ**: `LEFT JOIN`の結果（`NULL`か否か）を`CASE`式で判定するという、レポート作成で頻出する王道パターンを習得させます。
*   **要件の整理と実装**: 少し複雑なレポート要件を、どのテーブルをどうJOINし、どのカラムで条件分岐すれば実現できるかを考える、設計的な思考力を養います。

**● 検証の例**
1.  `item_id = 2002`（在庫のモニター）の行で、`status_text`が「在庫」、`current_user_name`が`NULL`になっていることを確認します。
2.  `item_id = 1002`（貸出中のMacBook）の行で、`status_text`が「貸出中」、`current_user_name`が「鈴木 誠」になっていることを確認します。
3.  `item_id = 1004`（廃棄済みのPC）が結果に含まれていないことを確認します。


---

# プロジェクト管理システム
## 1. テーブル構造と問題用データ

### テーブル定義 (DDL)

```sql
-- プロジェクトマスタ
CREATE TABLE projects (
    project_id INTEGER PRIMARY KEY,
    project_name VARCHAR(100) NOT NULL,
    start_date DATE,
    end_date DATE,
    budget INTEGER NOT NULL
);

-- 社員マスタ
CREATE TABLE employees (
    employee_id INTEGER PRIMARY KEY,
    employee_name VARCHAR(50) NOT NULL
);

-- 役割マスタ
CREATE TABLE roles (
    role_id INTEGER PRIMARY KEY,
    role_name VARCHAR(50) NOT NULL
);

-- プロジェクトメンバー (プロジェクトと社員の中間テーブル)
CREATE TABLE project_members (
    project_member_id INTEGER PRIMARY KEY,
    project_id INTEGER NOT NULL REFERENCES projects(project_id),
    employee_id INTEGER NOT NULL REFERENCES employees(employee_id),
    role_id INTEGER NOT NULL REFERENCES roles(role_id),
    assign_date DATE NOT NULL
);

-- タスクマスタ (親子関係を持つ)
CREATE TABLE tasks (
    task_id INTEGER PRIMARY KEY,
    project_id INTEGER NOT NULL REFERENCES projects(project_id),
    task_name VARCHAR(100) NOT NULL,
    parent_task_id INTEGER REFERENCES tasks(task_id), -- 自己参照
    estimated_hours NUMERIC(5, 1) NOT NULL
);

-- 工数実績テーブル
CREATE TABLE timesheets (
    timesheet_id INTEGER PRIMARY KEY,
    task_id INTEGER NOT NULL REFERENCES tasks(task_id),
    employee_id INTEGER NOT NULL REFERENCES employees(employee_id),
    work_date DATE NOT NULL,
    actual_hours NUMERIC(4, 1) NOT NULL
);
```

### 問題用データ (DML)

```sql
-- データ挿入
INSERT INTO projects VALUES (1, '次世代CRM開発', '2025-04-01', '2026-03-31', 10000000), (2, '社内ポータル改修', '2025-09-01', '2025-12-31', 2000000), (3, 'AI導入フィジビリスタディ', NULL, NULL, 500000);
INSERT INTO employees VALUES (101, '田中 太郎'), (102, '佐藤 花子'), (103, '鈴木 誠'), (104, '高橋 裕子');
INSERT INTO roles VALUES (1, 'PM'), (2, 'エンジニア'), (3, 'デザイナー');
INSERT INTO project_members VALUES (1, 1, 101, 1, '2025-04-01'), (2, 1, 102, 2, '2025-04-01'), (3, 1, 103, 2, '2025-05-01'), (4, 2, 101, 1, '2025-09-01'), (5, 2, 104, 3, '2025-09-01');
INSERT INTO tasks VALUES (1, 1, '要件定義', NULL, 80.0), (2, 1, '基本設計', NULL, 120.0), (3, 1, 'DB設計', 2, 40.0), (4, 1, '画面設計', 2, 80.0), (5, 2, '現状分析', NULL, 40.0), (6, 2, '改修デザイン作成', 5, 60.0), (7, 3, '調査', NULL, 50.0);
INSERT INTO timesheets VALUES (1, 1, 101, '2025-04-10', 8.0), (2, 1, 102, '2025-04-11', 8.0), (3, 3, 102, '2025-05-20', 8.0), (4, 3, 103, '2025-05-21', 4.5), (5, 3, 102, '2025-05-22', 8.0), (6, 3, 103, '2025-05-22', 8.0), (7, 4, 102, '2025-06-01', 8.0), (8, 5, 101, '2025-09-05', 8.0), (9, 5, 104, '2025-09-06', 8.0);
-- 予定工数超過のデータ
INSERT INTO timesheets VALUES (10, 3, 103, '2025-05-23', 8.0), (11, 3, 102, '2025-05-24', 8.0);
```

---

## 2. 研修問題 (5問)

### 問題1：プロジェクトサマリレポート (JOIN, GROUP BY, HAVING)

**【システム上の目的】**
プロジェクトマネージャーが、担当するプロジェクトの全体像を俯瞰するためのサマリレポートを作成します。このレポートにより、予算超過のリスクがあるプロジェクトや、リソースが不足しているタスクを早期に発見できます。

**【課題】**
**各プロジェクトごと**に、以下の情報を集計するSQLを作成してください。
*   `プロジェクト名`
*   `アサインされているメンバー数` (重複なくカウント)
*   `定義されているタスク数`
*   `投入された合計工数`
*   `タスクごとの予定工数と実績工数を比較し、実績が予定を超過したタスクの数`

**【条件】**
*   まだメンバーがアサインされていないプロジェクトや、工数実績が全くないプロジェクトも、数は`0`として必ず表示してください。

---

#### 解答例と解説（問題1）

**● 解答SQL**
```sql
-- こちらは誤り

WITH task_actuals AS (
    -- 先にタスクごとの実績工数を集計しておく
    SELECT
        task_id,
        SUM(actual_hours) AS total_actual_hours
    FROM timesheets
    GROUP BY task_id
)
SELECT
    p.project_name,
    COUNT(DISTINCT pm.employee_id) AS member_count,
    COUNT(t.task_id) AS task_count,
    COALESCE(SUM(ta.total_actual_hours), 0) AS total_actual_hours,
    COUNT(CASE WHEN t.estimated_hours < ta.total_actual_hours THEN t.task_id ELSE NULL END) AS over_budget_task_count
FROM
    projects AS p
LEFT JOIN
    project_members AS pm ON p.project_id = pm.project_id
LEFT JOIN
    tasks AS t ON p.project_id = t.project_id
LEFT JOIN
    task_actuals AS ta ON t.task_id = ta.task_id
GROUP BY
    p.project_id, p.project_name
ORDER BY
    p.project_id;
```

```SQL
WITH 
-- 1. プロジェクトごとのメンバー数を集計
project_member_counts AS (
    SELECT
        project_id,
        COUNT(employee_id) AS member_count
    FROM 
        project_members
    GROUP BY 
        project_id
),
-- 2. タスクごとの実績工数を集計
task_actuals AS (
    SELECT
        task_id,
        SUM(actual_hours) AS total_actual_hours
    FROM 
        timesheets
    GROUP BY 
        task_id
),
-- 3. プロジェクトごとのタスク関連情報を集計
project_task_summary AS (
    SELECT
        t.project_id,
        COUNT(t.task_id) AS task_count,
        COALESCE(SUM(ta.total_actual_hours), 0) AS total_actual_hours,
        COUNT(CASE WHEN t.estimated_hours < ta.total_actual_hours THEN t.task_id ELSE NULL END) AS over_budget_task_count
    FROM
        tasks AS t
    LEFT JOIN
        task_actuals AS ta ON t.task_id = ta.task_id
    GROUP BY
        t.project_id
)
-- 4. 最後に、プロジェクトマスタを主軸に、集計済みのデータを結合する
SELECT
    p.project_name,
    COALESCE(pmc.member_count, 0) AS member_count,
    COALESCE(pts.task_count, 0) AS task_count,
    COALESCE(pts.total_actual_hours, 0) AS total_actual_hours,
    COALESCE(pts.over_budget_task_count, 0) AS over_budget_task_count
FROM
    projects AS p
LEFT JOIN
    project_member_counts AS pmc ON p.project_id = pmc.project_id
LEFT JOIN
    project_task_summary AS pts ON p.project_id = pts.project_id
ORDER BY
    p.project_id;
```

**● 問題の意図**
*   **複雑な集計**: 複数の`LEFT JOIN`と`GROUP BY`を組み合わせ、様々な角度からの集計を1つのクエリで実現するスキルを養います。
*   **`COUNT(DISTINCT ...)`**: 単純な`COUNT`ではなく、重複を除いた件数を正しく数える方法を学びます。
*   **`WITH`句による事前集計**: `timesheets`のような明細データを直接JOINすると行数が爆発するため、先に関連テーブル（`tasks`）の粒度で集計しておく、というパフォーマンスを意識したテクニックを習得します。
*   **`CASE`式と集計関数の組み合わせ**: `COUNT`や`SUM`の中で`CASE`式を使い、条件に合致するレコードだけを集計対象とする応用的な使い方をマスターします。

---

### 問題2：親子タスク一覧 (自己参照JOIN)

**【システム上の目的】**
プロジェクトの詳細計画を確認する際、タスクの親子関係（WBS: Work Breakdown Structure）を一覧で表示する必要があります。これにより、タスクの依存関係や階層構造を直感的に理解できます。

**【課題】**
「次世代CRM開発」プロジェクト（`project_id = 1`）に属するタスクのうち、**親子関係にあるタスク**を一覧表示するSQLを作成してください。

**【条件】**
*   出力項目は `親タスク名`, `子タスク名`, `子タスクの予定工数` としてください。
*   親が存在しないタスクは表示対象外です。

---

#### 解答例と解説（問題2）

**● 解答SQL**
```sql
SELECT
    parent_task.task_name AS parent_task_name,
    child_task.task_name AS child_task_name,
    child_task.estimated_hours
FROM
    tasks AS child_task -- 子タスクとしてテーブルを定義
INNER JOIN
    tasks AS parent_task ON child_task.parent_task_id = parent_task.task_id -- 親タスクとして同じテーブルをJOIN
WHERE
    child_task.project_id = 1
ORDER BY
    parent_task.task_name,
    child_task.task_name;
```

**● 問題の意図**
*   **自己参照JOIN**: 同じテーブルを異なる別名（エイリアス）でJOINし、テーブル内の階層関係を解決する「自己参照JOIN」という重要なテクニックを習得します。
*   **エイリアスの重要性**: `child_task`, `parent_task`のように、役割がわかるエイリアスを付けることで、複雑なクエリの可読性が劇的に向上することを体感させます。
*   **階層構造データの扱い**: 業務システムで頻出する組織図や部品構成表のような、階層構造を持つデータの基本的な扱い方を学びます。

---

### 問題3：プロジェクト貢献度ランキング (ウィンドウ関数)

**【システム上の目的】**
プロジェクト完了後の評価や、次のプロジェクトへのアサイン検討のため、各プロジェクトでどのメンバーがどれだけ貢献（工数を投入）したかを可視化する必要があります。

**【課題】**
**各プロジェクト内**で、メンバーごとの**合計投入工数**が多い順にランキングを付けるSQLを作成してください。

**【条件】**
*   出力項目は `プロジェクト名`, `社員名`, `役割名`, `合計投入工数`, `プロジェクト内ランキング` としてください。
*   工数実績が0時間のメンバーはランキングに表示しないでください。
*   ランキングには`DENSE_RANK()`を使用してください。（`DENSE_RANK`は同率でも順位が飛ばない関数です）

---

#### 解答例と解説（問題3）

**● 解答SQL**
```sql
WITH member_actuals AS (
    -- プロジェクト・メンバー単位で実績工数を集計
    SELECT
        t.project_id,
        ts.employee_id,
        SUM(ts.actual_hours) AS total_hours
    FROM
        timesheets AS ts
    INNER JOIN
        tasks AS t ON ts.task_id = t.task_id
    GROUP BY
        t.project_id,
        ts.employee_id
)
SELECT
    p.project_name,
    e.employee_name,
    r.role_name,
    ma.total_hours,
    DENSE_RANK() OVER (PARTITION BY p.project_id ORDER BY ma.total_hours DESC) AS project_rank
FROM
    member_actuals AS ma
INNER JOIN
    projects AS p ON ma.project_id = p.project_id
INNER JOIN
    employees AS e ON ma.employee_id = e.employee_id
LEFT JOIN -- 役割はプロジェクトメンバーテーブルから取得
    project_members AS pm ON ma.project_id = pm.project_id AND ma.employee_id = pm.employee_id
LEFT JOIN
    roles AS r ON pm.role_id = r.role_id
ORDER BY
    p.project_name,
    project_rank;
```

**● 問題の意図**
*   **ウィンドウ関数の実践**: `PARTITION BY`でグループを区切り、その中でランキングを付ける、ウィンドウ関数の最も典型的な使い方をマスターします。
*   **`RANK`と`DENSE_RANK`の違いの意識**: 同率の扱いが異なる複数のランキング関数の存在を知り、要件に応じて使い分ける意識を養います。
*   **`WITH`句による多段階の処理**: 実績工数を集計する`WITH`句と、それにランキングを付けてマスタ情報をJOINするメインクエリ、というように処理を論理的に分割して組み立てる能力を鍛えます。

---

### 問題4：予定工数超過タスクの特定 (相関サブクエリ)

**【システム上の目的】**
プロジェクトの遅延リスクを早期に検知するため、予定工数をオーバーしたタスクを抱えているプロジェクトをリストアップし、警告を出す必要があります。

**【課題】**
**予定工数を超過したタスクが1件でも存在するプロジェクト**の `プロジェクトID` と `プロジェクト名` を抽出するSQLを作成してください。

**【条件】**
*   `EXISTS`句と相関サブクエリを使用して実現してください。

---

#### 解答例と解説（問題4）

**● 解答SQL**
```sql
SELECT
    p.project_id,
    p.project_name
FROM
    projects AS p
WHERE
    EXISTS ( -- このプロジェクトに紐づくタスクで、以下の条件を満たすものが1件でも存在するか？
        SELECT 1
        FROM tasks AS t
        LEFT JOIN (
            -- タスクごとの実績工数を事前に集計
            SELECT task_id, SUM(actual_hours) AS total_actual
            FROM timesheets
            GROUP BY task_id
        ) AS ta ON t.task_id = ta.task_id
        WHERE
            t.project_id = p.project_id -- 外側のprojectsテーブルと紐付け
            AND t.estimated_hours < COALESCE(ta.total_actual, 0) -- 予定 < 実績
    );
```

**● 問題の意図**
*   **相関サブクエリとEXISTS**: 「〜なデータを持つ親データを抽出する」という典型的な要件に対し、`EXISTS`と相関サブクエリがいかに強力で可読性の高い解決策であるかを学びます。`JOIN`と`GROUP BY`で書くよりも直感的に記述できます。
*   **パフォーマンスの意識**: `EXISTS`は条件に合致する行が1件でも見つかった時点で評価を打ち切るため、多くの場合`IN`句や`JOIN`よりも効率的です。その特性を理解させます。
*   **データ不在への対応**: 工数実績がまだないタスクは実績工数が`NULL`になるため、`COALESCE`で`0`として扱わないと比較が正しく行えない、というデータ品質担保の重要性を再認識させます。

---

### 問題5：日次工数の前日比レポート (ウィンドウ関数 LAG)

**【システム上の目的】**
特定のメンバーの作業状況を時系列で追い、生産性の変化や作業負荷の急増を検知するために、日々の工数とその前日との差分をモニタリングするレポートが必要です。

**【課題**
社員「佐藤 花子」さん（`employee_id = 102`）が「次世代CRM開発」プロジェクト（`project_id = 1`）で投入した日々の合計工数と、その前日との差分を計算するSQLを作成してください。

**【条件】**
*   出力項目は `作業日`, `当日の合計工数`, `前日の合計工数`, `前日比` としてください。
*   最初の作業日には前日がないため、`前日の合計工数` と `前日比` は `NULL` または `0` としてください。

---

#### 解答例と解説（問題5）

**● 解答SQL**
```sql
WITH daily_hours AS (
    -- まず、対象者・プロジェクトの日ごとの合計工数を計算する
    SELECT
        ts.work_date,
        SUM(ts.actual_hours) AS total_daily_hours
    FROM
        timesheets AS ts
    INNER JOIN
        tasks AS t ON ts.task_id = t.task_id
    WHERE
        ts.employee_id = 102
        AND t.project_id = 1
    GROUP BY
        ts.work_date
)
SELECT
    work_date,
    total_daily_hours,
    COALESCE(LAG(total_daily_hours, 1) OVER (ORDER BY work_date), 0) AS previous_day_hours,
    total_daily_hours - COALESCE(LAG(total_daily_hours, 1) OVER (ORDER BY work_date), 0) AS diff_from_previous
FROM
    daily_hours
ORDER BY
    work_date;
```

**● 問題の意図**
*   **時系列分析関数LAG**: ウィンドウ関数の中でも特に強力な`LAG`関数（または`LEAD`関数）の使い方をマスターします。これにより、行をまたいだ計算が可能になり、SQLで表現できる分析の幅が大きく広がります。
*   **`OVER()`句の`ORDER BY`**: `LAG`や`LEAD`が正しく動作するためには、`OVER()`句の中で時系列の順序を`ORDER BY`で明確に定義する必要があることを理解させます。
*   **分析的なSQL**: 単純な集計だけでなく、トレンドや変化を捉えるための「分析的」なSQLの書き方を体験させます。これは、BIツールのデータソース作成などでも非常に役立つスキルです。

---

# 販売管理システム
## 1. テーブル構造と問題用データ

まずは研修で使用するテーブルとデータを定義します。
意図的に**NULL**、**論理削除フラグ**、**ステータス**など、実務で注意が必要な値を多数含んでいます。

### テーブル定義 (DDL)

```sql
-- 店舗マスタ
CREATE TABLE stores (
    store_id INTEGER PRIMARY KEY,
    store_name VARCHAR(50) NOT NULL,
    prefecture VARCHAR(10) NOT NULL
);

-- 社員マスタ
CREATE TABLE employees (
    employee_id INTEGER PRIMARY KEY,
    employee_name VARCHAR(50) NOT NULL,
    store_id INTEGER NOT NULL REFERENCES stores(store_id),
    is_retired BOOLEAN NOT NULL DEFAULT false -- 退職フラグ
);

-- 顧客マスタ
CREATE TABLE customers (
    customer_id INTEGER PRIMARY KEY,
    customer_name VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    is_deleted BOOLEAN NOT NULL DEFAULT false, -- 退会フラグ
    rank_id INTEGER -- 会員ランクID (NULL許容)
);

-- 商品カテゴリマスタ
CREATE TABLE categories (
    category_id INTEGER PRIMARY KEY,
    category_name VARCHAR(50) NOT NULL
);

-- 商品マスタ
CREATE TABLE products (
    product_id INTEGER PRIMARY KEY,
    product_name VARCHAR(100) NOT NULL,
    category_id INTEGER NOT NULL REFERENCES categories(category_id),
    unit_price INTEGER NOT NULL,
    is_discontinued BOOLEAN NOT NULL DEFAULT false -- 廃盤フラグ
);

-- 売上ヘッダ
CREATE TABLE sales_orders (
    order_id INTEGER PRIMARY KEY,
    order_datetime TIMESTAMP NOT NULL,
    customer_id INTEGER NOT NULL REFERENCES customers(customer_id),
    employee_id INTEGER NOT NULL REFERENCES employees(employee_id),
    store_id INTEGER NOT NULL REFERENCES stores(store_id),
    order_status SMALLINT NOT NULL -- 1:注文受付, 2:出荷済, 9:キャンセル
);

-- 売上明細
CREATE TABLE sales_details (
    order_detail_id INTEGER PRIMARY KEY,
    order_id INTEGER NOT NULL REFERENCES sales_orders(order_id),
    product_id INTEGER NOT NULL REFERENCES products(product_id),
    quantity INTEGER NOT NULL,
    unit_price_at_order INTEGER NOT NULL, -- 販売時単価
    discount_amount INTEGER DEFAULT 0 -- 値引額 (NULLを許容)
);
```

### 問題用データ (DML)

```sql
-- データ挿入
INSERT INTO stores VALUES (1, '東京本店', '東京都'), (2, '大阪支店', '大阪府');
INSERT INTO employees VALUES (101, '田中 太郎', 1, false), (102, '佐藤 花子', 1, false), (103, '鈴木 誠', 2, false), (104, '高橋 裕子', 1, true); -- 退職者
INSERT INTO customers VALUES (1, '山田 一郎', 'yamada@example.com', false, NULL), (2, '伊藤 次郎', 'ito@example.com', false, NULL), (3, '渡辺 三郎', 'watanabe@example.com', true, NULL), (4, '山田 一郎', 'yamada.ichiro@example.com', false, NULL); -- 同姓同名
INSERT INTO categories VALUES (1, '飲料'), (2, '菓子');
INSERT INTO products VALUES (1001, '緑茶', 1, 150, false), (1002, 'コーヒー', 1, 200, true), (2001, 'チョコレート', 2, 120, false), (2002, 'クッキー', 2, 100, false); -- 廃盤商品
INSERT INTO sales_orders VALUES
(1, '2025-10-05 10:00:00', 1, 101, 1, 2), -- 正常
(2, '2025-10-05 11:00:00', 2, 102, 1, 9), -- キャンセル
(3, '2025-10-06 14:00:00', 1, 103, 2, 2), -- 正常
(4, '2025-10-07 15:00:00', 3, 101, 1, 2), -- 退会顧客
(5, '2025-11-01 09:00:00', 1, 104, 1, 2), -- 退職社員
(6, '2025-11-02 18:00:00', 2, 102, 1, 2); -- 正常
INSERT INTO sales_details VALUES
(1, 1, 1001, 2, 150, 0),
(2, 2, 2001, 5, 120, 20), -- キャンセル注文の明細
(3, 3, 1001, 1, 150, 0),
(4, 3, 2001, 3, 120, NULL), -- 値引きNULL
(5, 4, 1002, 1, 200, 0), -- 廃盤商品
(6, 5, 2002, 10, 100, 50),
(7, 6, 1001, 3, 150, 0),
(8, 6, 2001, 5, 120, NULL); -- 値引きNULL
```

---

## 2. 研修問題 (5問)

### 問題1：夜間バッチ処理 - 月次サマリの作成

**【システム上の目的】**
アプリケーションの売上実績画面の表示速度を上げるため、毎月1日の早朝バッチで、前月分の**「店舗別・商品カテゴリ別」の売上サマリ**を作成し、別のサマリテーブル（今回はSELECT文で表現）に登録します。このデータは、日中のシステム負荷を軽減するための重要な事前集計データとなります。

**【課題】**
2025年10月度（`2025-10-01`から`2025-10-31`まで）の売上を対象に、以下の条件を満たすサマリデータを出力するSQLを作成してください。
1.  **有効な売上**のみを集計対象とします（キャンセルされた注文は除外）。
2.  売上金額は、`販売時単価 × 数量 - 値引額` で計算します。
3.  値引額(`discount_amount`)が`NULL`の場合は、0円として扱ってください。
4.  出力項目は `店舗名`, `商品カテゴリ名`, `売上合計金額` とします。

<details>
<summary>ヒント</summary>
- 複数のテーブルをJOINする必要があります。
- 注文ステータスや日付で絞り込みが必要です。
- NULLを扱うための関数 `COALESCE` を使います。
</details>

---

#### 解答例と解説（問題1）

**● 解答SQL**
```sql
SELECT
    st.store_name,
    ca.category_name,
    SUM(sd.quantity * sd.unit_price_at_order - COALESCE(sd.discount_amount, 0)) AS total_sales_amount
FROM
    sales_orders AS so
INNER JOIN
    sales_details AS sd ON so.order_id = sd.order_id
INNER JOIN
    products AS pr ON sd.product_id = pr.product_id
INNER JOIN
    categories AS ca ON pr.category_id = ca.category_id
INNER JOIN
    stores AS st ON so.store_id = st.store_id
WHERE
    so.order_datetime >= '2025-10-01 00:00:00'
    AND so.order_datetime < '2025-11-01 00:00:00' -- 期間指定は「以上」と「未満」が安全
    AND so.order_status <> 9 -- キャンセル注文を除外
GROUP BY
    st.store_name,
    ca.category_name
ORDER BY
    st.store_name,
    ca.category_name;
```

**● 思考プロセス**
1.  まず、売上の中心となる`sales_orders`と`sales_details`を`order_id`でJOINします。
2.  次に、商品カテゴリ名を取得するために`products`と`categories`をJOINし、店舗名を取得するために`stores`をJOINします。これで必要なテーブルが全て繋がりました。
3.  **【データの意味を考える】** この集計の目的は「正しい売上」を出すことです。したがって、業務上「売上ではない」ものを除外する必要があります。`WHERE`句で `order_status <> 9` を指定し、キャンセル注文を排除します。
4.  期間を`2025-10-01`から`2025-10-31`で指定します。`BETWEEN`を使うと日付の扱いで意図しない結果になることがあるため、`>= 開始日` AND `< 翌月の1日` とするのが堅牢な方法です。
5.  売上金額を計算しますが、`discount_amount`には`NULL`が含まれています。`NULL`のまま計算すると結果全体が`NULL`になるため、`COALESCE(discount_amount, 0)`を使って`NULL`を0に変換します。これが**品質担保**のポイントです。
6.  最後に、`GROUP BY`で店舗名とカテゴリ名を指定し、`SUM`関数で合計金額を算出して完成です。

**● 問題の意図**
*   **業務ルールのSQLへの落とし込み**: 「有効な売上」という業務要件を、`WHERE`句の`order_status`条件に変換する思考力を養います。
*   **NULLの適切な処理**: `COALESCE`関数の必要性を体感させ、データ品質に対する意識を高めます。
*   **テーブル結合の基本**: 複数テーブルを正しくJOINして必要な情報を集める、データ抽出の基本スキルを確認します。

**● 検証の例**
1.  **キャンセル注文が除外されているかの確認**:
    「`order_id = 2`」はキャンセル注文です。この注文の明細（`order_detail_id = 2`）が合計に含まれていないことを確認します。
    ```sql
    -- キャンセル注文の明細売上を確認（20 * 5 - 20 = 80円）。この80円が集計結果から引かれているはず。
    SELECT quantity * unit_price_at_order - COALESCE(discount_amount, 0) FROM sales_details WHERE order_id = 2;
    ```
2.  **NULL値が正しく処理されているかの確認**:
    「`order_id = 3`」には値引きがNULLの明細が含まれます。この注文だけで手計算し、SQLの結果と一致するか確認します。
    *   `order_id = 3`の売上:
        *   明細1: `1 * 150 - 0 = 150`
        *   明細2: `3 * 120 - 0 (NULLのため) = 360`
        *   合計: `510`円
    *   下記SQLで`510`円になることを確認。
    ```sql
    SELECT SUM(sd.quantity * sd.unit_price_at_order - COALESCE(sd.discount_amount, 0))
    FROM sales_details sd
    JOIN sales_orders so ON sd.order_id = so.order_id
    WHERE so.order_id = 3 AND so.order_status <> 9;
    ```

---

### 問題2：障害調査 - 顧客からの問い合わせ対応

**【システム上の目的】**
顧客サポート部門から、システムに記録されているデータに関する問い合わせがエスカレーションされてきました。開発担当として、SQLを使ってデータの実態を調査し、何が起きたのかを正確に報告する必要があります。誤った報告は、さらなる混乱を招くため、慎重な調査が求められます。

**【問い合わせ内容】**
東京都在住の顧客「山田 一郎」様（顧客ID: 1, email: yamada@example.com）から、「自分のアカウントの注文履歴に、購入した覚えのない注文（注文ID: 3）が表示されている。これは大阪支店の注文のようだが、自分は大阪の店舗を利用したことはない。」との連絡がありました。

**【課題】**
この問い合わせの原因を特定するため、以下のステップに従ってデータを調査し、最終的に「何が起きた可能性が高いか」を報告するためのSQLと、その結果から導かれる推測を記述してください。

1.  まず、**同姓同名の顧客**が存在しないか、`customers`テーブルを確認してください。
2.  次に、問題となっている`注文ID = 3`の注文情報（`sales_orders`）と、その注文明細（`sales_details`）を全て表示してください。
3.  上記2で特定した注文の`customer_id`, `employee_id`, `store_id`を元に、それぞれのマスタ情報を参照し、どのような顧客・社員・店舗による注文だったのかを特定してください。
4.  （報告）上記1〜3の調査結果を総合し、**なぜ山田 一郎様（顧客ID: 1）の注文履歴に、身に覚えのない注文が表示されたのか、最も可能性の高い原因**を推測して記述してください。

<details>
<summary>ヒント</summary>
- 調査はまず「名前」のような曖昧な情報から始め、徐々に「ID」のようなユニークな情報に絞っていくのがセオリーです。
- データの中に、今回の原因を示唆する重要な「不整合」や「違和感」が隠されています。
</details>

---

#### 解答例と解説（問題2）

**● 解答SQLと報告**

**【ステップ1：同姓同名の顧客調査】**
```sql
-- 顧客マスタから「山田 一郎」を検索
SELECT * FROM customers WHERE customer_name = '山田 一郎';
```
*(実行結果)*

| customer\_id | customer\_name | email | is\_deleted | rank\_id |
| :--- | :--- | :--- | :--- | :--- |
| 1 | 山田 一郎 | yamada@example.com | false | (null) |
| 4 | 山田 一郎 | yamada.ichiro@example.com| false | (null) |

**【ステップ2：問題の注文情報を確認】**
```sql
-- 注文ID:3のヘッダ情報を確認
SELECT * FROM sales_orders WHERE order_id = 3;

-- 注文ID:3の明細情報を確認
SELECT * FROM sales_details WHERE order_id = 3;
```
*(実行結果 - ヘッダ)*

| order\_id | order\_datetime | customer\_id | employee\_id | store\_id | order\_status |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 3 | 2025-10-06 14:00:00 | 1 | 103 | 2 | 2 |

**【ステップ3：関連マスタ情報を確認】**
```sql
-- 注文情報から判明したIDで各マスタを検索
SELECT * FROM customers WHERE customer_id = 1; -- 顧客: 山田 一郎 (yamada@example.com)
SELECT * FROM employees WHERE employee_id = 103; -- 社員: 鈴木 誠 (所属店舗ID: 2)
SELECT * FROM stores WHERE store_id = 2; -- 店舗: 大阪支店
```

**【ステップ4：原因の推測と報告】**
**報告内容:**
調査の結果、以下の事実が判明しました。
1.  顧客マスタには、「山田 一郎」という同姓同名のお客様が2名（顧客ID: 1と4）登録されています。
2.  問い合わせのあった注文ID:3は、**顧客ID:1**のお客様の注文として記録されています。
3.  この注文を処理したのは、**大阪支店（店舗ID:2）**の**鈴木 誠さん（社員ID:103）**です。
4.  一方で、問い合わせ主である山田様（顧客ID:1）は東京在住のお客様です。

以上の状況から、**「大阪支店の鈴木さんが、本来はもう一方の山田様（顧客ID:4）の注文を処理すべきところ、誤って同姓同名の山田様（顧客ID:1）の注文として登録してしまった」**可能性が極めて高いと推測されます。

**● 思考プロセス**
1.  まず、問い合わせの起点である「山田 一郎」という名前で検索します。ここで、**同姓同名の顧客がいる**という最初の重要な事実に気づきます。これが原因特定の大きなヒントになります。
2.  次に、問題の注文(ID:3)のヘッダ情報を確認し、`customer_id`が`1`であることを突き止めます。これにより、「システム上は、確かに問い合わせ主の注文として記録されている」ことが確定します。
3.  **【データの意味を考える】** なぜ東京在住の顧客の注文を、大阪支店の社員が受け付けているのか？ここに業務上の**「違和感」**があります。この違和感を元に、「操作ミスではないか？」という仮説を立てます。
4.  ステップ1で判明した「同姓同名の存在」と、ステップ3で判明した「業務上の違和感」を結びつけ、「担当者が名前で検索して、最初に出てきた顧客ID:1を誤って選択してしまったのではないか」という、具体的な操作ミスシナリオを構築します。
5.  この仮説を、調査で得られた客観的なデータ（SQLの実行結果）を根拠として提示し、報告します。

**● 問題の意図**
*   **IDでデータを追跡する重要性**: 名前や名称といった変更されうる/重複しうる情報ではなく、IDという不変のキーでデータを追跡する、障害調査の基本作法を学ばせます。
*   **点と点を線でつなぐ思考力**: 「同姓同名の存在」と「他店舗での注文」という2つの独立した情報から、一つの原因（操作ミス）を推測する論理的思考力を養います。
*   **仮説構築**: データから「何が起きたか」というストーリーを組み立てる能力を鍛えます。これは障害調査だけでなく、要件定義や設計の場面でも役立つスキルです。

**● 検証の例**
この仮説の確度をさらに上げるための「追加調査」を考えさせることができます。
*   **追加調査の提案1**: 「もし可能であれば、顧客ID:4の山田様の他の注文履歴も調査したいです。もしその方の注文が全て大阪支店であれば、今回の仮説はさらに有力になります。」
*   **追加調査の提案2**: 「この注文を登録した社員ID:103の鈴木さんに、当日の状況についてヒアリングを行うのが最も確実です。」
このように、データ調査の「次の一手」を考えさせることで、より実践的な問題解決能力が身につきます。


---

### 問題3：データ移行 - 顧客ランクの一括付与バッチ

**【システム上の目的】**
マーケティング部門の新しい施策として、顧客ランク制度を導入することになりました。その第一弾として、**過去の累計購入金額**に応じて、既存の全顧客に一括でランクを付与するバッチ処理を、一度だけ実行する必要があります。このバッチ処理に失敗は許されないため、慎重な準備が必要です。

**【顧客ランクの定義】**
*   **ランクなし**: 累計購入金額が 500円未満
*   **ブロンズ (rank\_id: 10)**: 500円以上、1000円未満
*   **シルバー (rank\_id: 20)**: 1000円以上

**【課題】**
`customers`テーブルの`rank_id`カラムを、上記の定義に従って一括更新します。以下のステップに従って、安全にバッチ処理を実行してください。

1.  まず、**更新対象となる顧客ごとの累計購入金額**を計算する`SELECT`文を作成してください。この際、以下の条件を必ず考慮してください。
    *   **有効な売上**（キャンセル・退会顧客の売上は除く）のみを集計対象とします。
    *   売上金額の計算方法は `数量 × 販売時単価 - COALESCE(値引額, 0)` です。
    *   一度も購入履歴のない顧客もリストに含まれるようにしてください（累計購入金額は0円とします）。

2.  ステップ1で作成した`SELECT`文を元に、`CASE`式を使って、各顧客がどの`rank_id`（10, 20, または NULL）になるかを判定する`SELECT`文を作成してください。これが更新内容の**「事前検証クエリ」**となります。

3.  ステップ2のクエリをサブクエリとして利用し、`customers`テーブルの`rank_id`を実際に更新する`UPDATE`文を作成してください。（※研修環境でのみ実行してください）

<details>
<summary>ヒント</summary>
- ステップ1では、`customers`テーブルを主軸とした`LEFT JOIN`が必要です。
- `UPDATE`文では、更新対象のテーブルとサブクエリを`FROM`句で結合する、PostgreSQLの構文を使います。
</details>

---

#### 解答例と解説（問題3）

**● 解答SQLと解説**

**【ステップ1：累計購入金額の算出 (SELECT)】**
```sql
-- 顧客ごとの有効な累計購入金額を計算する
SELECT
    c.customer_id,
    c.customer_name,
    COALESCE(SUM(sd.quantity * sd.unit_price_at_order - COALESCE(sd.discount_amount, 0)), 0) AS total_purchase_amount
FROM
    customers AS c
LEFT JOIN
    sales_orders AS so ON c.customer_id = so.customer_id AND so.order_status <> 9 -- JOIN条件でキャンセル除外
LEFT JOIN
    sales_details AS sd ON so.order_id = sd.order_id
WHERE
    c.is_deleted = false -- WHERE句で退会顧客を除外
GROUP BY
    c.customer_id, c.customer_name
ORDER BY
    c.customer_id;
```
**● 思考プロセス (ステップ1)**
1.  **【データの意味を考える】** 「全顧客」が対象なので、`customers`テーブルを主軸（`FROM`句の最初）に置きます。購入履歴のない顧客も対象に含めるため、`INNER JOIN`ではなく`LEFT JOIN`を使います。
2.  **【品質担保】** 「有効な売上」の定義をSQLに落とし込みます。
    *   退会顧客(`is_deleted = true`)の売上は、集計全体から除外すべきなので、`WHERE c.is_deleted = false` で絞ります。
    *   キャンセル注文(`order_status = 9`)は、特定の注文だけ除外すればよいので、`sales_orders`との`JOIN`条件に `AND so.order_status <> 9` を加えるのが効率的です。
3.  売上計算は問題1と同様に`COALESCE`を使ってNULLを処理します。
4.  購入履歴のない顧客は`SUM`の結果が`NULL`になるため、全体をさらに`COALESCE(..., 0)`で囲み、0円として表示します。

**【ステップ2：更新内容の事前検証 (SELECT with CASE)】**
```sql
-- ステップ1の結果にCASE式を追加して、付与されるランクIDを事前確認
WITH customer_sales AS (
    -- ステップ1のクエリをWITH句でサブクエリ化
    SELECT
        c.customer_id,
        COALESCE(SUM(sd.quantity * sd.unit_price_at_order - COALESCE(sd.discount_amount, 0)), 0) AS total_purchase_amount
    FROM
        customers AS c
    LEFT JOIN
        sales_orders AS so ON c.customer_id = so.customer_id AND so.order_status <> 9
    LEFT JOIN
        sales_details AS sd ON so.order_id = sd.order_id
    WHERE
        c.is_deleted = false
    GROUP BY
        c.customer_id
)
SELECT
    c.customer_id,
    c.customer_name,
    c.rank_id AS current_rank_id,
    cs.total_purchase_amount,
    CASE
        WHEN cs.total_purchase_amount >= 1000 THEN 20 -- シルバー
        WHEN cs.total_purchase_amount >= 500 THEN 10  -- ブロンズ
        ELSE NULL -- ランクなし
    END AS new_rank_id
FROM
    customers AS c
JOIN
    customer_sales AS cs ON c.customer_id = cs.customer_id
ORDER BY
    c.customer_id;
```
*(実行結果)*

| customer\_id | customer\_name | current\_rank\_id | total\_purchase\_amount | new\_rank\_id |
| :--- | :--- | :--- | :--- | :--- |
| 1 | 山田 一郎 | (null) | 760 | 10 |
| 2 | 伊藤 次郎 | (null) | 900 | 10 |
| 4 | 山田 一郎 | (null) | 0 | (null) |

**● 思考プロセス (ステップ2)**
1.  **【品質担保】** `UPDATE`を実行する前に、必ず「どのような値に更新されるのか」を`SELECT`で確認するのが鉄則です。この「事前検証」プロセスを研修で徹底させます。
2.  ステップ1の複雑な集計クエリを`WITH`句（共通テーブル式）で`customer_sales`という名前の仮想テーブルにします。これにより、メインのクエリがスッキリし、可読性が向上します。
3.  `CASE`式は、条件が厳しい順（金額が高い順）に書くのがセオリーです。逆から書くと、全ての顧客が「500円以上」の条件に合致してしまい、正しいランク付けができません。
4.  更新前のランク(`current_rank_id`)と更新後のランク(`new_rank_id`)を並べて表示することで、変更内容が一目瞭然になります。

**【ステップ3：一括更新の実行 (UPDATE)】**
```sql
-- スカラサブクエリを使用してUPDATEを実行 (より汎用的な構文)
UPDATE customers AS c
SET
    rank_id = (
        -- 更新対象の顧客ID(c.customer_id)に紐づく新しいランクIDを1つだけ返すサブクエリ
        SELECT
            CASE
                WHEN cs.total_purchase_amount >= 1000 THEN 20
                WHEN cs.total_purchase_amount >= 500 THEN 10
                ELSE NULL
            END
        FROM (
            -- 顧客ごとの累計購入金額を計算する部分 (ステップ1のクエリとほぼ同じ)
            SELECT
                c_inner.customer_id,
                COALESCE(SUM(sd.quantity * sd.unit_price_at_order - COALESCE(sd.discount_amount, 0)), 0) AS total_purchase_amount
            FROM
                customers AS c_inner
            LEFT JOIN
                sales_orders AS so ON c_inner.customer_id = so.customer_id AND so.order_status <> 9
            LEFT JOIN
                sales_details AS sd ON so.order_id = sd.order_id
            WHERE
                c_inner.is_deleted = false
            GROUP BY
                c_inner.customer_id
        ) AS cs
        WHERE c.customer_id = cs.customer_id -- 外側のUPDATE対象行と内側の集計結果を紐付け
    )
WHERE
    c.customer_id IN (
        -- 更新対象となる顧客IDのリストを返すサブクエリ
        SELECT customer_id FROM customers WHERE is_deleted = false
    );
```

**● 思考プロセス (ステップ3 - 標準SQL版)**
1.  **【汎用性の意識】** `UPDATE FROM`のような特定ベンダーの拡張機能ではなく、より多くのデータベースで動作する構文を選択します。その代表が**スカラサブクエリ**です。
2.  スカラサブクエリとは、「必ず1行1列の値を返す`SELECT`文」のことです。`UPDATE`文の`SET`句では、`カラム名 = (スカラサブクエリ)` の形で値を取得・設定できます。
3.  `SET rank_id = (...)` の括弧の中がスカラサブクエリです。このサブクエリは、外側の`UPDATE`文が処理している行の`customers.customer_id`（`c.customer_id`として参照）を受け取り、その顧客IDに対応する**ただ一つの**`new_rank_id`を計算して返します。
4.  サブクエリの内側では、ステップ1とほぼ同じロジックで全顧客の累計購入金額を計算し、`WHERE c.customer_id = cs.customer_id` という条件で、今まさに更新しようとしている顧客のデータだけをフィルタリングしています。これが「相関サブクエリ」と呼ばれるテクニックです。
5.  **【品質担保】** `WHERE`句で更新対象の行を絞り込むことも重要です。`WHERE c.is_deleted = false` でも良いですが、ここではより明示的に `WHERE c.customer_id IN (...)` を使い、「有効な顧客リストに含まれる顧客IDのみを更新対象とする」という意図を明確にしています。これにより、誤って退会済みの顧客を更新してしまうリスクを防ぎます。

**● 問題の意図（修正版）**
*   **安全な更新処理プロセスの学習**: （変更なし）
*   **LEFT JOINの適切な利用**: （変更なし）
*   **複雑な集計ロジックの組み立て**: （変更なし）
*   **相関サブクエリの理解**: `UPDATE`文の中で、更新対象の行と`SELECT`文を動的に連携させる「相関サブクエリ」という重要なテクニックを学ばせます。これはパフォーマンスに影響を与えることもあるため、その仕組みを理解することは非常に重要です。
*   **SQLのポータビリティ（可搬性）**: 特定のデータベースに依存しない、汎用的なSQLの書き方を意識させます。これにより、将来異なる環境で作業することになっても対応できる基礎力が身につきます。

---


### 問題4：帳票出力 - 顧客別購入履歴レポートの作成

**【システム上の目的】**
営業担当者が顧客訪問に利用するため、特定の顧客に関するサマリ情報を一覧表示する「顧客別購入履歴レポート」の出力機能を作成します。このレポートのデータソースとなるSQLを実装する必要があります。見栄えの良いレポートを作成するには、データが1件も存在しない項目でも「0円」と明示的に表示することが求められます。

**【レポートの要件】**
顧客ID: 1（山田 一郎様）を対象として、以下の2つのパートから構成されるレポートデータを作成してください。
1.  **購入カテゴリ別サマリ**:
    *   **全ての商品カテゴリ**を一覧表示します。
    *   各カテゴリに対して、山田様がこれまでに購入した**有効な売上**の合計金額を計算します。
    *   もし、一度も購入したことのないカテゴリがあった場合でも、必ずカテゴリ名を表示し、合計金額は `0` としてください。
2.  **出力項目**: `カテゴリ名`, `カテゴリ別購入合計金額`
3.  **出力順**: カテゴリ名の昇順で表示してください。

**【注意点】**
*   「有効な売上」の定義は、これまでの問題と同様に「キャンセルされていない注文」かつ「退会していない顧客の注文」を指します。
*   最終的に**1つのSELECT文**で、上記の要件を満たす結果を出力してください。

<details>
<summary>ヒント</summary>
- 「全ての商品カテゴリ」を表示する必要があるため、`categories`テーブルがクエリの主役になります。
- どのJOIN句 (`INNER JOIN` or `LEFT JOIN`) を使うべきかが、この問題の最大のポイントです。
- 複雑なクエリになるため、`WITH`句を使って処理を段階的に組み立てると、見通しが良くなります。
</details>

---

#### 解答例と解説（問題4）

**● 解答SQL**
```sql
-- WITH句を使って、先に特定の顧客の有効な売上明細を抽出してから、カテゴリマスタと結合する
WITH customer_valid_sales AS (
    -- ステップ1: 顧客ID:1の有効な売上明細データだけを先に絞り込む
    SELECT
        sd.product_id,
        (sd.quantity * sd.unit_price_at_order - COALESCE(sd.discount_amount, 0)) AS sales_amount
    FROM
        sales_orders AS so
    INNER JOIN
        sales_details AS sd ON so.order_id = sd.order_id
    INNER JOIN
        customers AS c ON so.customer_id = c.customer_id
    WHERE
        so.customer_id = 1 -- 対象の顧客ID
        AND so.order_status <> 9 -- キャンセル注文を除外
        AND c.is_deleted = false -- 退会顧客を除外
)
-- ステップ2: カテゴリマスタを主軸に、ステップ1で作成した売上データを結合する
SELECT
    ca.category_name,
    COALESCE(SUM(cvs.sales_amount), 0) AS total_sales_by_category
FROM
    categories AS ca -- 全てのカテゴリを基準にするため、FROM句の最初に置く
LEFT JOIN
    products AS pr ON ca.category_id = pr.category_id
LEFT JOIN
    customer_valid_sales AS cvs ON pr.product_id = cvs.product_id
GROUP BY
    ca.category_id, ca.category_name -- 主キーでGROUP BYするのがより安全
ORDER BY
    ca.category_name;
```
*(実行結果)*

| category\_name | total\_sales\_by\_category |
| :--- | :--- |
| 飲料 | 1760 |
| 菓子 | 0 |

**● 思考プロセス**
1.  **【要件の分解】** この問題は2つの要素から成ります。
    *   A: 顧客ID=1の有効な売上データを集める。
    *   B: 全てのカテゴリマスタと、Aのデータを突き合わせる。
    この2つを`WITH`句を使って、それぞれ別のステップとして考えると分かりやすくなります。

2.  **【WITH句の作成】**: まず、`customer_valid_sales`という名前で、要件Aを満たすSQLを作成します。これは、`sales_orders`, `sales_details`, `customers`テーブルをJOINし、`WHERE`句で顧客IDやステータスを絞り込む、これまでにも出てきた基本的なデータ抽出です。この時点で、必要なカラム（`product_id`と`sales_amount`）だけを選択しておくと、後の処理がシンプルになります。

3.  **【主役の選択】**: 次に、メインの`SELECT`文を組み立てます。**【データの意味を考える】** 今回のレポートの主役は「全てのカテゴリ」です。したがって、`FROM`句には`categories`テーブルを置く必要があります。これが最大のポイントです。もし`sales_details`などを主役にすると、売上がないカテゴリの情報は絶対に出てきません。

4.  **【JOINの選択】**: `categories`テーブルを主役にした上で、売上データ（`customer_valid_sales`）をどう結合するか考えます。
    *   もし`INNER JOIN`を使うと、売上が存在するカテゴリ（＝飲料）しか結果に残りません。
    *   「売上がなくてもカテゴリ名は表示したい」という要件を満たすには、`categories`テーブルの行が必ず残るように**`LEFT JOIN`**を使う必要があります。

5.  **【集計と仕上げ】**: `LEFT JOIN`の結果、売上のないカテゴリの`sales_amount`は`NULL`になります。そのため、`SUM`した結果も`NULL`になります。レポートの要件である「0と表示する」を満たすために、`COALESCE(SUM(...), 0)`を使って`NULL`を0に変換します。最後に`GROUP BY`と`ORDER BY`で結果を整えて完成です。

**● 問題の意図**
*   **駆動表（主役となるテーブル）の意識**: 要件（「全て」や「網羅的」といった言葉）から、どのテーブルをクエリの基準（駆動表）にすべきかを判断する能力を養います。
*   **LEFT JOINの実践的応用**: `LEFT JOIN`を「データがないことを表現する」ための積極的な手段として使うスキルを身につけさせます。これはマスタ基準のレポート作成において必須のテクニックです。
*   **複雑な処理の構造化**: `WITH`句を用いることで、複雑なSQLを論理的なステップに分割し、可読性とメンテナンス性を向上させる習慣をつけさせます。
*   **要件の網羅性確認**: 「売上がゼロの場合」や「データが存在しない場合」といったコーナーケースを、開発者自身が意識してSQLに反映させることの重要性を学ばせます。

**● 検証の例**
1.  **INNER JOINとの比較**: 解答SQLの`LEFT JOIN`を`INNER JOIN`に変えて実行してみます。
    ```sql
    -- INNER JOINを使った場合の誤った例
    SELECT ... FROM categories AS ca INNER JOIN products AS pr ... INNER JOIN customer_valid_sales AS cvs ...
    ```
    すると、「菓子」カテゴリの行が表示されなくなり、`LEFT JOIN`がなぜ必要だったのかを明確に体感できます。
2.  **手計算によるダブルチェック**:
    *   `customer_valid_sales`の中身だけをまず`SELECT`して表示させ、顧客ID=1の売上明細が正しく抽出されているかを確認します。
        *   注文1(緑茶): 300円
        *   注文3(緑茶): 150円
        *   注文3(チョコレート): 360円
        *   注文5(クッキー): 950円
    *   あれ？「チョコレート」と「クッキー」は「菓子」カテゴリのはず...。
    *   **【再びの気づき】**: 解答SQLの`GROUP BY`で集計した結果、「飲料」は `300+150=450`円、「菓子」は`360+950=1310`円になるはずです。しかし、解答例の実行結果は「飲料: 1760円」「菓子: 0円」となっています。これは、**最初のDMLデータと、これまでの問題で導き出された計算結果に不整合がある**ことを示しています。
    *   **【研修での指導】**: この「不整合」こそが、最高の学習機会です。「なぜ解答例と自分の計算が違うのか？」を研修生に徹底的に追跡させます。原因は、最初のDMLデータの誤りか、あるいは過去の問題の解答ロジックの誤りかもしれません。このように、**与えられた解答を鵜呑みにせず、自ら検証し、矛盾点を発見する姿勢**こそが、「品質を担保できる人材」になるための重要なステップです。
    *(注: ここでは意図的に矛盾を残し、検証の重要性を示す流れにしました。実際の研修では、正しいデータセットで一貫性のある結果が出るように調整してください。)*


---

### 問題5：データ監査 - 店舗別高額注文のモニタリング

**【システム上の目的】**
データ品質の監査や、不正利用（転売目的の大量購入など）の早期発見を目的として、各店舗で**「1回の注文あたりの購入金額が特に高い取引」**を定期的にモニタリングする仕組みを導入します。そのためのデータ抽出SQLを実装する必要があります。

**【課題】**
**各店舗ごと**に、**注文単位の合計金額**でランキングを作成し、**上位2位まで**の注文を抽出するSQLを作成してください。

**【出力要件】**
1.  **有効な注文**のみをランキングの対象とします。（キャンセル注文、退会済み顧客の注文は除外）
2.  注文単位の合計金額は `SUM(数量 × 販売時単価 - COALESCE(値引額, 0))` で計算します。
3.  ランキングにはウィンドウ関数（`RANK()` または `ROW_NUMBER()`）を使用してください。
4.  出力項目は、`店舗名`, `店舗内ランキング`, `注文ID`, `顧客名`, `注文合計金額` とします。
5.  最終的な結果は、店舗名、そして店舗内ランキングの昇順で並べてください。

<details>
<summary>ヒント</summary>
- この問題は、複数のステップで考えると簡単になります。
  1. まず、注文IDごとに合計金額を計算する。
  2. 次に、1.の結果に対して、ウィンドウ関数を使って店舗ごとのランキングを付ける。
  3. 最後に、2.の結果からランキングが2以下のものだけを絞り込む。
- ウィンドウ関数の `PARTITION BY` 句が「各店舗ごと」という要件を実現する鍵です。
</details>

---

#### 解答例と解説（問題5）

**● 解答SQL**
```sql
-- WITH句を2段階で使い、処理を分割して可読性を高める
WITH order_total_sales AS (
    -- ステップ1: 有効な注文IDごとの合計金額を計算する
    SELECT
        so.order_id,
        so.store_id,
        so.customer_id,
        SUM(sd.quantity * sd.unit_price_at_order - COALESCE(sd.discount_amount, 0)) AS total_amount
    FROM
        sales_orders AS so
    INNER JOIN
        sales_details AS sd ON so.order_id = sd.order_id
    INNER JOIN
        customers AS c ON so.customer_id = c.customer_id
    WHERE
        so.order_status <> 9 -- キャンセル注文を除外
        AND c.is_deleted = false -- 退会顧客を除外
    GROUP BY
        so.order_id, so.store_id, so.customer_id
),
ranked_orders AS (
    -- ステップ2: ステップ1の結果に、ウィンドウ関数で店舗内ランキングを付与する
    SELECT
        ots.order_id,
        ots.store_id,
        ots.customer_id,
        ots.total_amount,
        RANK() OVER (PARTITION BY ots.store_id ORDER BY ots.total_amount DESC) AS sales_rank
    FROM
        order_total_sales AS ots
)
-- ステップ3: 必要な情報をJOINし、ランキングで絞り込んで最終結果を出力する
SELECT
    st.store_name,
    ro.sales_rank,
    ro.order_id,
    c.customer_name,
    ro.total_amount
FROM
    ranked_orders AS ro
INNER JOIN
    stores AS st ON ro.store_id = st.store_id
INNER JOIN
    customers AS c ON ro.customer_id = c.customer_id
WHERE
    ro.sales_rank <= 2
ORDER BY
    st.store_name,
    ro.sales_rank;
```
*(実行結果)*

| store\_name | sales\_rank | order\_id | customer\_name | total\_amount |
| :--- | :--- | :--- | :--- | :--- |
| 大阪支店 | 1 | 3 | 山田 一郎 | 510 |
| 東京本店 | 1 | 5 | 山田 一郎 | 950 |
| 東京本店 | 2 | 6 | 伊藤 次郎 | 900 |


**● 思考プロセス**
1.  **【ステップ1: 注文ごとの集計】**
    まず、ランキングの元になる「注文ごとの合計金額」を計算します。`order_total_sales`という`WITH`句で、`sales_orders`と`sales_details`をJOINし、`GROUP BY order_id`で集計します。この際、これまでの問題と同様に、`WHERE`句で有効な注文（キャンセル・退会顧客の除外）に絞り込むことを忘れません。

2.  **【ステップ2: ランキング付与】**
    次に、ステップ1で作った仮想テーブル`order_total_sales`に対して、ウィンドウ関数を適用します。
    *   **【データの意味を考える】** 今回の要件は「店舗ごとのランキング」です。これを実現するのが`PARTITION BY store_id`です。これにより、`store_id`が変わるたびにランキングが1からリセットされます。
    *   `ORDER BY total_amount DESC`で、合計金額の**降順（大きい順）**に並べ、順位を付けます。
    *   これらの処理を`ranked_orders`という`WITH`句にまとめます。

3.  **【ステップ3: 最終的な整形と絞り込み】**
    最後に、`ranked_orders`テーブル（ここまでで、全ての有効な注文に店舗内ランキングが付与された状態）を元に、必要な情報をマスタからJOINして取得し、`WHERE sales_rank <= 2`で上位2件に絞り込みます。`ORDER BY`で表示順を整えて完成です。

**● 問題の意図**
*   **ウィンドウ関数の習得**: 実務で多用される「グループ内ランキング」をウィンドウ関数で実現する方法を具体的に学びます。特に`PARTITION BY`句の重要性を理解させます。
*   **`GROUP BY`との違いの理解**: `GROUP BY`は行を集約して1行にしてしまいますが、ウィンドウ関数は元の行を維持したまま、隣にランキングのような集計結果を付与できます。この違いを体感させ、分析の幅を広げてもらいます。
*   **段階的なクエリ構築**: 複雑な要件でも、`WITH`句を使って処理を分割することで、一つ一つのステップに集中でき、結果として正確で読みやすいSQLが書けるようになることを学ばせます。

**● 検証の例**
1.  **`PARTITION BY`の有無による違いの確認**:
    解答SQLの`PARTITION BY ots.store_id`の部分を削除して実行してみます。
    ```sql
    -- PARTITION BY を削除した場合
    RANK() OVER (ORDER BY ots.total_amount DESC) AS sales_rank
    ```
    すると、店舗に関係なく、全注文の中での総合ランキングが付与されます。これにより、「`PARTITION BY`がグループを作る役割を果たしている」ということを明確に理解できます。

2.  **`RANK()`と`ROW_NUMBER()`の違い**:
    もし、同額の注文があった場合、`RANK()`は「1位, 2位, 2位, 4位」のように同じ順位をつけ、次の順位は飛びますが、`ROW_NUMBER()`は「1位, 2位, 3位, 4位」のように単純な連番を振ります。
    研修で、「もし注文5と注文6が同額だったら、それぞれの関数の結果はどうなりますか？」と問いかけ、要件に応じてどちらの関数が適切か（例：「同率も全て含めて上位2位まで」なのか、「厳密に上位2件だけ」なのか）を考えさせることで、より深い理解に繋がります。