### 単元 4. plpgsql/ウィンドウ関数

**問題 1**
`invoice` テーブルから、各顧客 (`customer_id`) ごとに、その顧客の全請求書における合計金額 (`total`) の割合を計算してください。

**回答**

```sql
SELECT
    invoice_id,
    customer_id,
    total,
    SUM(total) OVER (PARTITION BY customer_id) AS customer_total_sales,
    (total / SUM(total) OVER (PARTITION BY customer_id)) * 100 AS percentage_of_customer_sales
FROM invoice
ORDER BY customer_id, invoice_date;
```

---

**問題 2**
`track` テーブルから、各ジャンル (`genre_id`) ごとに、`unit_price` の値がジャンル内で最も高いものから 3 番目までのトラックを取得してください。

**回答**

```sql
SELECT
    track_id,
    name,
    genre_id,
    unit_price
FROM (
    SELECT
        track_id,
        name,
        genre_id,
        unit_price,
        DENSE_RANK() OVER (PARTITION BY genre_id ORDER BY unit_price DESC) AS price_rank
    FROM track
) AS ranked_tracks
WHERE price_rank <= 3
ORDER BY genre_id, price_rank, track_id;
```

**別パターン (RANK()を使用)**

```sql
SELECT
    track_id,
    name,
    genre_id,
    unit_price
FROM (
    SELECT
        track_id,
        name,
        genre_id,
        unit_price,
        RANK() OVER (PARTITION BY genre_id ORDER BY unit_price DESC) AS price_rank
    FROM track
) AS ranked_tracks
WHERE price_rank <= 3
ORDER BY genre_id, price_rank, track_id;
```

---

**問題 3**
`employee` テーブルから、各従業員について、同じ`title`を持つ従業員の中での給与（ここでは`hire_date`と`birth_date`の差を仮想的な勤続年数として給与の代理とします）の順位と、同じ`title`を持つ従業員の中で最も勤続年数が長い従業員を特定してください。

**回答**

```sql
SELECT
    employee_id,
    first_name,
    last_name,
    title,
    AGE(CURRENT_DATE, hire_date) AS years_of_service, -- 勤続年数を計算
    RANK() OVER (PARTITION BY title ORDER BY AGE(CURRENT_DATE, hire_date) DESC) AS service_rank_in_title,
    FIRST_VALUE(first_name || ' ' || last_name) OVER (PARTITION BY title ORDER BY AGE(CURRENT_DATE, hire_date) DESC) AS longest_serving_in_title
FROM employee
ORDER BY title, service_rank_in_title;
```

**補足**: `AGE(CURRENT_DATE, hire_date)`は PostgreSQL で日付の差を期間として返す関数です。これを勤続年数の代理として使用しています。

---

**問題 4**
`invoice_line` テーブルから、各請求書 (`invoice_id`) 内の各商品について、その商品の`quantity`が、同じ請求書内のすべての商品の`quantity`の合計に占める割合を計算してください。

**回答**

```sql
SELECT
    invoice_line_id,
    invoice_id,
    track_id,
    quantity,
    SUM(quantity) OVER (PARTITION BY invoice_id) AS total_quantity_in_invoice,
    (quantity::NUMERIC / SUM(quantity) OVER (PARTITION BY invoice_id)) * 100 AS quantity_percentage_in_invoice
FROM invoice_line
ORDER BY invoice_id, invoice_line_id;
```

---

**問題 5**
`invoice` テーブルから、各顧客 (`customer_id`) ごとに、最新の請求書日 (`invoice_date`) から遡って 3 番目の請求書日を取得してください。3 つ未満しか請求書がない場合は、利用可能な最も古い請求書日を表示してください。

**回答**

```sql
SELECT
    invoice_id,
    customer_id,
    invoice_date,
    NTH_VALUE(invoice_date, 3) OVER (PARTITION BY customer_id ORDER BY invoice_date DESC) AS third_latest_invoice_date
FROM invoice
ORDER BY customer_id, invoice_date DESC;
```

**別パターン (サブクエリで ROW_NUMBER()を使用)**

```sql
SELECT
    t1.customer_id,
    t1.invoice_date AS latest_invoice_date,
    (SELECT invoice_date
     FROM (
         SELECT
             invoice_date,
             ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY invoice_date DESC) as rn
         FROM invoice
         WHERE customer_id = t1.customer_id
     ) AS sub
     WHERE rn = 3) AS third_latest_invoice_date
FROM (
    SELECT
        customer_id,
        invoice_date,
        ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY invoice_date DESC) as rn
    FROM invoice
) AS t1
WHERE t1.rn = 1
ORDER BY t1.customer_id;
```

**NTH_VALUE()の補足**: `NTH_VALUE`関数は指定された行番号の値を返します。`ORDER BY invoice_date DESC`で最新から順に並べているため、3 番目の値が欲しければ`NTH_VALUE(invoice_date, 3)`とします。もし 3 つ未満の請求書しかない場合は NULL が返されます。

---

### PL/pgSQL 問題

**問題 1**
PL/pgSQL で、指定された`customer_id`の顧客の`email`アドレスを取得し、`RAISE NOTICE`で表示する無名ブロックを作成してください。

**回答**

```sql
DO $$
DECLARE
    customer_email VARCHAR(60);
    target_customer_id INT := 1; -- 例として顧客ID 1 を使用
BEGIN
    SELECT email INTO customer_email
    FROM customer
    WHERE customer_id = target_customer_id;

    IF FOUND THEN
        RAISE NOTICE 'Customer ID % のメールアドレス: %', target_customer_id, customer_email;
    ELSE
        RAISE NOTICE 'Customer ID % は見つかりませんでした。', target_customer_id;
    END IF;
END $$;
```

---

**問題 2**
PL/pgSQL で、`track`テーブルに新しいトラックを挿入するプロシージャ`add_new_track_procedure`を作成してください。
引数として`p_name`, `p_unit_price`を受け取ります。
`album_id`, `media_type_id`, `genre_id`はそれぞれ仮の値（例: 1）を使用してください。
挿入後、`RAISE NOTICE`で挿入された`track_id`を表示してください。

**回答**

```sql
CREATE OR REPLACE PROCEDURE add_new_track_procedure(
    p_name VARCHAR,
    p_unit_price NUMERIC
)
LANGUAGE plpgsql AS $$
DECLARE
    v_new_track_id INT;
BEGIN
    INSERT INTO track (name, album_id, media_type_id, genre_id, unit_price, milliseconds, bytes)
    VALUES (p_name, 1, 1, 1, p_unit_price, NULL, NULL)
    RETURNING track_id INTO v_new_track_id;

    RAISE NOTICE '新しいトラックがID % で挿入されました: %', v_new_track_id, p_name;
END;
$$;

-- プロシージャの実行例:
-- CALL add_new_track_procedure('PLpgSQL Test Song 1', 0.99);
-- SELECT * FROM track WHERE name = 'PLpgSQL Test Song 1';
```

---

**問題 3**
PL/pgSQL で、`artist`テーブルのアーティスト名を更新する関数`update_artist_name`を作成してください。
引数として`p_artist_id`と`p_new_name`を受け取ります。
更新が成功した場合は`TRUE`、指定された`artist_id`が見つからなかった場合は`FALSE`を返すようにしてください。

**回答**

```sql
CREATE OR REPLACE FUNCTION update_artist_name(
    p_artist_id INT,
    p_new_name VARCHAR
)
RETURNS BOOLEAN AS $$
BEGIN
    UPDATE artist
    SET name = p_new_name
    WHERE artist_id = p_artist_id;

    IF FOUND THEN
        RAISE NOTICE 'アーティストID % の名前が "%" に更新されました。', p_artist_id, p_new_name;
        RETURN TRUE;
    ELSE
        RAISE NOTICE 'アーティストID % は見つからなかったため、更新されませんでした。', p_artist_id;
        RETURN FALSE;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- 関数の使用例:
-- SELECT update_artist_name(1, 'AC/DC New Name');
-- SELECT update_artist_name(999, 'Non-existent Artist');
```

---

**問題 4**
PL/pgSQL で、`invoice`テーブルの各請求書に対し、その`total`が特定の閾値（例: 10.00）を超えているかどうかをチェックし、結果を`RAISE NOTICE`で出力する無名ブロックを作成してください。

**回答**

```sql
DO $$
DECLARE
    invoice_record RECORD;
    threshold NUMERIC := 10.00;
BEGIN
    FOR invoice_record IN SELECT invoice_id, total, customer_id FROM invoice LOOP
        IF invoice_record.total > threshold THEN
            RAISE NOTICE '請求書ID % (顧客ID: %) の合計金額 %.2f は閾値 %.2f を超えています。',
                         invoice_record.invoice_id, invoice_record.customer_id, invoice_record.total, threshold;
        ELSE
            RAISE NOTICE '請求書ID % (顧客ID: %) の合計金額 %.2f は閾値 %.2f 以下です。',
                         invoice_record.invoice_id, invoice_record.customer_id, invoice_record.total, threshold;
        END IF;
    END LOOP;
END $$;
```

---

**問題 5**
PL/pgSQL で、`genre`テーブルに新しいジャンルを 5 つ追加するプロシージャ`add_multiple_genres`を作成してください。ジャンル名は 'New Genre 1', 'New Genre 2', ... 'New Genre 5' とします。各挿入後に`RAISE NOTICE`で挿入されたジャンル名を表示してください。

**回答**

```sql
CREATE OR REPLACE PROCEDURE add_multiple_genres()
LANGUAGE plpgsql AS $$
DECLARE
    i INT;
    new_genre_name VARCHAR(120);
    v_genre_id INT;
BEGIN
    FOR i IN 1..5 LOOP
        new_genre_name := 'New Genre ' || i;
        INSERT INTO genre (name)
        VALUES (new_genre_name)
        RETURNING genre_id INTO v_genre_id;

        RAISE NOTICE '新しいジャンル "%" (ID: %) が挿入されました。', new_genre_name, v_genre_id;
    END LOOP;
END;
$$;

-- プロシージャの実行例:
-- CALL add_multiple_genres();
-- SELECT * FROM genre ORDER BY genre_id DESC LIMIT 5;
```
