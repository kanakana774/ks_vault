### PL/pgSQL の基本的な構文と制御構造 (続き)

#### 4. レコード型と配列

##### 4.1. レコード型

レコード型は、複数の異なる型の値を一つの変数にまとめて保持できる複合データ型です。特に、`SELECT` クエリの結果行を格納するのに便利です。

###### 匿名レコード (`RECORD`)

`RECORD` 型は、クエリの結果セットの構造に合わせて実行時に型が決まるレコード変数です。`%ROWTYPE` と似ていますが、特定のテーブルの行構造に縛られません。主に `FOR` ループでクエリ結果を処理する際に使用されます。

**例:** `customer` テーブルから一部の列を選択し、`RECORD` 型変数で受け取ります。

```sql
DO $$
DECLARE
    -- 匿名レコード変数を宣言。型は実行時にSELECT INTOまたはFORループで決まる。
    customer_rec RECORD;
BEGIN
    RAISE NOTICE '--- Listing specific customer info using RECORD ---';
    -- customer_idが1の顧客の特定の列を選択して匿名レコードに格納
    SELECT first_name, last_name, email
    INTO customer_rec
    FROM customer
    WHERE customer_id = 1;

    -- レコードのフィールドにアクセス
    RAISE NOTICE 'Customer Name: % %', customer_rec.first_name, customer_rec.last_name;
    RAISE NOTICE 'Customer Email: %', customer_rec.email;

    -- FORループでもRECORDはよく使われる
    RAISE NOTICE '--- Listing first 2 artists using RECORD in FOR loop ---';
    FOR customer_rec IN SELECT artist_id, name FROM artist ORDER BY artist_id LIMIT 2 LOOP
        RAISE NOTICE 'Artist ID: %, Name: %', customer_rec.artist_id, customer_rec.name;
    END LOOP;
END
$$;
```

###### 宣言されたレコード (`variable_name record_type;`)

PL/pgSQL では、カスタムの複合型（`CREATE TYPE` で作成）を宣言し、その型を持つレコード変数を宣言することもできますが、この範囲では触れません。代わりに、`%ROWTYPE` を使用することで、テーブルの行構造に基づいた「宣言された」レコード型として扱えます。`%ROWTYPE` は、特定のテーブルの構造を明示的に参照するため、より安全で自己文書化されています。

**例:** `customer` テーブルの行構造に基づいたレコード型変数 (`%ROWTYPE` は宣言されたレコードの一種と解釈できます)。

```sql
DO $$
DECLARE
    -- customerテーブルの構造を持つレコード変数を宣言
    specific_customer_rec customer%ROWTYPE;
BEGIN
    SELECT *
    INTO specific_customer_rec
    FROM customer
    WHERE customer_id = 2;

    RAISE NOTICE 'Specific Customer ID: %', specific_customer_rec.customer_id;
    RAISE NOTICE 'Specific Customer City: %', specific_customer_rec.city;
END
$$;
```

##### 4.2. 配列

PostgreSQL は配列データ型をサポートしており、PL/pgSQL でこれらの配列変数を宣言し、操作することができます。

###### 配列変数の宣言

配列変数は、基本データ型の後に角括弧 `[]` を付けて宣言します。次元を指定することもできますが、通常は可変長の 1 次元配列が使われます。

**構文:**

```sql
variable_name data_type[]; -- 1次元配列
variable_name data_type[][]; -- 2次元配列 (または data_type[dim1][dim2])
```

**例:**

```sql
DO $$
DECLARE
    -- 整数型の配列
    my_numbers INTEGER[] := ARRAY[10, 20, 30];
    -- テキスト型の配列
    my_names TEXT[] DEFAULT '{"Alice", "Bob", "Charlie"}';
    -- 空の配列
    empty_array TEXT[];
BEGIN
    RAISE NOTICE 'Numbers: %', my_numbers;
    RAISE NOTICE 'Names: %', my_names;
    RAISE NOTICE 'Empty Array: %', empty_array;
END
$$;
```

###### 配列へのアクセスと操作

配列要素へのアクセスは、角括弧 `[]` とインデックス（1 から始まる）を使用します。配列の操作には、通常、PostgreSQL の組み込み配列関数を使用します。

**例:**

```sql
DO $$
DECLARE
    artist_ids INTEGER[] := ARRAY[1, 2, 3]; -- Artist IDs for AC/DC, Accept, Aerosmith
    first_artist_id INTEGER;
    updated_artist_ids INTEGER[];
BEGIN
    -- 配列要素へのアクセス (1-based index)
    first_artist_id := artist_ids[1];
    RAISE NOTICE 'First artist ID: %', first_artist_id;

    -- 配列要素の変更
    artist_ids[3] := 4; -- Aerosmith の ID を 4 に変更 (存在しないID)
    RAISE NOTICE 'Modified artist IDs: %', artist_ids;

    -- 配列の結合 (ARRAY_CAT)
    updated_artist_ids := artist_ids || ARRAY[5, 6]; -- 別の配列を追加
    RAISE NOTICE 'Combined artist IDs: %', updated_artist_ids;

    -- 配列の次元数と長さ (array_upper)
    RAISE NOTICE 'Array length of updated_artist_ids: %', array_upper(updated_artist_ids, 1);
END
$$;
```

###### 配列関数の利用 (例: `array_append`, `array_remove`, `unnest`)

PostgreSQL には、配列を操作するための便利な関数が多数用意されています。

- `array_append(array, element)`: 配列の最後に要素を追加
- `array_remove(array, element)`: 配列から指定した値のすべての要素を削除
- `unnest(array)`: 配列の要素を個別の行に展開

**例:**

```sql
DO $$
DECLARE
    track_names TEXT[] := ARRAY['Thunderstruck', 'Hells Bells', 'Back in Black'];
    appended_names TEXT[];
    removed_names TEXT[];
    unnested_name TEXT;
BEGIN
    RAISE NOTICE 'Original Track Names: %', track_names;

    -- array_append: 要素を追加
    appended_names := array_append(track_names, 'Highway to Hell');
    RAISE NOTICE 'After append: %', appended_names;

    -- array_remove: 要素を削除
    removed_names := array_remove(appended_names, 'Hells Bells');
    RAISE NOTICE 'After remove "Hells Bells": %', removed_names;

    -- unnest: 配列を個別の行に展開
    RAISE NOTICE '--- Unnesting track names ---';
    FOR unnested_name IN SELECT unnest(track_names) LOOP
        RAISE NOTICE 'Unnested Name: %', unnested_name;
    END LOOP;
    RAISE NOTICE '--- End unnesting ---';
END
$$;
```

---

### 練習問題

以下の指示に従って PL/pgSQL の `DO` ブロックを作成してください。

#### 問題 1: 匿名レコード (`RECORD`) の使用

1.  `DO` ブロック内で、`invoice_item_rec` という名前の `RECORD` 型変数を宣言してください。
2.  `invoice_line` テーブルから `invoice_id` が `10` の行をいくつか取得する `FOR` ループを作成してください。
3.  ループ内で、各行の `track_id` と `quantity` を `invoice_item_rec` を介してアクセスし、`RAISE NOTICE` で出力してください。
4.  ループ開始前と終了後に、それぞれ適切なメッセージを `RAISE NOTICE` で出力してください。

#### 問題 2: `customer%ROWTYPE` と配列の組み合わせ

1.  `DO` ブロック内で、`customer_rec` という名前の `customer%ROWTYPE` 型変数を宣言してください。
2.  `customer_emails` という名前の `TEXT[]` 型配列変数を宣言し、空の配列として初期化してください。
3.  `customer` テーブルから `country` が `'Brazil'` であるすべての顧客の `email` アドレスを取得し、`customer_emails` 配列に追加していく `FOR` ループを作成してください。
    - ヒント: `array_append()` 関数を使用してください。
4.  ループ終了後、`RAISE NOTICE` で `customer_emails` 配列全体を出力してください。

#### 問題 3: 配列の宣言、アクセス、および数値範囲ループとの組み合わせ

1.  `DO` ブロック内で、`top_track_ids` という名前の `INTEGER[]` 型配列変数を宣言し、`track` テーブルから `track_id` が最も小さい `5` つのトラックの `track_id` を格納してください。
    - ヒント: `SELECT array_agg(track_id) FROM track ORDER BY track_id LIMIT 5;` のようなクエリを `SELECT INTO` で使用して配列に直接格納できます。
2.  `track_name_val` 変数を `track.name%TYPE` で宣言してください。
3.  `top_track_ids` 配列の各要素（トラック ID）を反復処理する `FOR` ループ（数値範囲ループではありません）を作成してください。
    - ヒント: `FOR i IN 1 .. array_upper(top_track_ids, 1) LOOP` のような構造を使います。
4.  ループ内で、現在のトラック ID に対応する `track` の `name` を取得し、`RAISE NOTICE` でトラック ID と名前を出力してください。

#### 問題 4: `unnest` と条件分岐の組み合わせ

1.  `DO` ブロック内で、`genres_to_check` という名前の `TEXT[]` 型配列変数を宣言し、`ARRAY['Rock', 'Jazz', 'Pop', 'Classical']` で初期化してください。
2.  `genre_name_val` 変数を `genre.name%TYPE` で宣言してください。
3.  `genres_to_check` 配列の各要素を `unnest` を使用して反復処理する `FOR` ループを作成してください。
4.  ループ内で、現在のジャンル名（`unnested_genre` と仮定）が `genre` テーブルに存在するかどうかを確認してください。
    - ヒント: `SELECT name INTO genre_name_val FROM genre WHERE name = unnested_genre;` を使用し、`genre_name_val IS NOT NULL` で存在確認ができます。
5.  もしジャンルが存在すれば `'ジャンル "%" はデータベースに存在します。'` と、存在しなければ `'ジャンル "%" はデータベースに存在しません。'` と `RAISE NOTICE` で出力してください。

---

### 解答

#### 問題 1: 匿名レコード (`RECORD`) の使用

```sql
DO $$
DECLARE
    invoice_item_rec RECORD; -- 匿名レコード変数
    target_invoice_id INTEGER := 10;
BEGIN
    RAISE NOTICE '--- Invoice ID % の請求明細 ---', target_invoice_id;
    FOR invoice_item_rec IN SELECT track_id, quantity FROM invoice_line WHERE invoice_id = target_invoice_id LOOP
        RAISE NOTICE '  Track ID: %, Quantity: %', invoice_item_rec.track_id, invoice_item_rec.quantity;
    END LOOP;
    RAISE NOTICE '--- 請求明細の終了 ---';
END
$$;
```

#### 問題 2: `customer%ROWTYPE` と配列の組み合わせ

```sql
DO $$
DECLARE
    customer_rec customer%ROWTYPE;
    customer_emails TEXT[] := '{}'; -- 空の配列として初期化
    target_country TEXT := 'Brazil';
BEGIN
    RAISE NOTICE '--- Listing emails of customers from % ---', target_country;
    FOR customer_rec IN SELECT * FROM customer WHERE country = target_country ORDER BY customer_id LOOP
        customer_emails := array_append(customer_emails, customer_rec.email);
    END LOOP;

    RAISE NOTICE 'すべてのブラジル人顧客のメールアドレス: %', customer_emails;
END
$$;
```

#### 問題 3: 配列の宣言、アクセス、および数値範囲ループとの組み合わせ

```sql
DO $$
DECLARE
    top_track_ids INTEGER[];
    track_name_val track.name%TYPE;
BEGIN
    -- track_id が最も小さい5つのトラックIDを配列に格納⇒これだと3000行出てしまうので、limit効いてない
    SELECT array_agg(track_id ORDER BY track_id)
    INTO top_track_ids
    FROM track
    LIMIT 5;

    RAISE NOTICE '--- Top 5 Tracks by ID ---';
    -- 配列の要素数に基づいてループ
    FOR i IN 1 .. array_upper(top_track_ids, 1) LOOP
        -- 配列からトラックIDを取得
        DECLARE
            current_track_id INTEGER := top_track_ids[i];
        BEGIN
            -- トラックIDに対応するトラック名を取得
            SELECT name
            INTO track_name_val
            FROM track
            WHERE track_id = current_track_id;

            RAISE NOTICE '  Track ID: %, Name: %', current_track_id, track_name_val;
        END;
    END LOOP;
    RAISE NOTICE '--- End of Top 5 Tracks ---';
END
$$;
```

#### 問題 4: `unnest` と条件分岐の組み合わせ

```sql
DO $$
DECLARE
    genres_to_check TEXT[] := ARRAY['Rock', 'Jazz', 'Pop', 'Classical', 'NonExistentGenre'];
    unnested_genre TEXT; -- unnestで展開される各ジャンル名を保持
    genre_name_val genre.name%TYPE; -- データベースから取得したジャンル名を保持
BEGIN
    RAISE NOTICE '--- Checking Genres in Database ---';
    FOR unnested_genre IN SELECT unnest(genres_to_check) LOOP
        -- データベースにジャンルが存在するか確認
        SELECT name INTO genre_name_val
        FROM genre
        WHERE name = unnested_genre;

        IF genre_name_val IS NOT NULL THEN
            RAISE NOTICE '  ジャンル "%" はデータベースに存在します。', unnested_genre;
        ELSE
            RAISE NOTICE '  ジャンル "%" はデータベースに存在しません。', unnested_genre;
        END IF;
    END LOOP;
    RAISE NOTICE '--- End Genre Check ---';
END
$$;
```
