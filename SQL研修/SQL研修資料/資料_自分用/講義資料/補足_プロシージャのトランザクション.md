## 1. FUNCTION 内での COMMIT/ROLLBACK ができない（プロシージャ呼び出し経由も含む）

関数（FUNCTION）内ではトランザクション制御コマンド（COMMIT や ROLLBACK）は一切使用できません。これは、関数とプロシージャの最も本質的な違いの一つです。

- 関数 (FUNCTION): SELECT 文などの SQL 式の一部として呼び出され、値を返すことを目的としています。そのため、関数はそれを呼び出したトランザクションの一部として実行される必要があり、自身でトランザクションを終了させることはできません。
- プロシージャ (PROCEDURE): 値を返さず、状態を変更する一連の操作を実行することを目的としています。そのため、自律的にトランザクションを管理する能力が与えられています。
  この原則は、関数内からトランザクション制御を含むプロシージャを CALL で呼び出した場合にも適用されます。関数が実行されているコンテキスト自体がトランザクション制御を許可していないため、そこから呼び出されたプロシージャもトランザクションを COMMIT や ROLLBACK することはできません。実行しようとするとエラーになります。

## 2. 明示的なトランザクション内や EXCEPTION ブロック内での COMMIT/ROLLBACK ができない

プロシージャはトランザクションを管理できますが、それはプロシージャがトランザクションブロックの外から呼び出された場合に限られます。
これは PostgreSQL の重要な仕様です。

- 明示的なトランザクションブロック内: BEGIN;と COMMIT;（または ROLLBACK;）で囲まれたトランザクションブロックの中からプロシージャを CALL した場合、そのプロシージャ内で COMMIT や ROLLBACK を実行することはできません。
- EXCEPTION ブロック内: PL/pgSQL の BEGIN ... EXCEPTION ... END;ブロックがアクティブな間も、COMMIT や ROLLBACK は実行できません。EXCEPTION 句を持つブロックは、それ自体がサブトランザクション（暗黙的なセーブポイント）を形成するためです。このサブトランザクション内で、親トランザクション全体を終了させることは論理的に矛盾するため、許可されていません。
  これらの制約は、トランザクションの状態管理が予測不能になるのを防ぐためのものです。

⇒ 同じクエリツール内で呼ぶとたぶんトランザクションブロック内からの呼び出しになり、エラーになる。

## 3. SAVEPOINT は利用できない

PL/pgSQL のプロシージャ内では、COMMIT と ROLLBACK はサポートされていますが、SAVEPOINT、RELEASE SAVEPOINT、ROLLBACK TO SAVEPOINT といったセーブポイントを明示的に管理するコマンドはサポートされていません。
ただし、前述の通り、EXCEPTION 句を持つブロックが暗黙的なセーブポイントとして機能します。ブロック内でエラーが発生すると、そのブロック内で行われた処理だけがロールバックされ、プロシージャの実行は EXCEPTION 句のコードから継続されます。これにより、トランザクション全体を失敗させることなく、エラーからの回復処理を記述することが可能です。

## まとめ

PL/pgSQL と他の手続き言語（特に PL/SQL）とのトランザクション管理における設計思想の違いを示してます。

- PL/pgSQL: トランザクションの原子性（atomicity）と SQL 標準との整合性を重視しています。プロシージャによるトランザクション管理は SQL 標準への拡張機能であり、その使用は「自律的なトランザクション」を実行できる特定のコンテキスト（トランザクションブロックの外側）に限定されています。これにより、トランザクションの境界が常に明確に保たれます。
- PL/SQL (Oracle): より柔軟で広範なトランザクション制御をプロシージャや関数内で許容する設計になっています。
  このように、PL/pgSQL ではできないパターンが存在するのは事実ですが、これは PostgreSQL がトランザクションの一貫性と整合性を厳格に保つための設計上の選択と言えます。

PostgreSQL トランザクションまとめ

### 1. 検証用テーブル

```SQL
CREATE TABLE tx_log (
    id serial PRIMARY KEY,
    msg text,
    created_at timestamptz DEFAULT now()
);
```

---

### 2. 通常の SQL 文（暗黙トランザクション）

```SQL
-- 暗黙トランザクションにより自動コミット
INSERT INTO tx_log(msg) VALUES('普通のINSERT');

-- トランザクションID確認
SELECT txid_current_if_assigned() AS txid_before_after_insert;
```

- 挙動：
  - 1 文ごとにトランザクションが開始され、実行後にコミットされる
  - txid_current_if_assigned() は NULL（トランザクション終了済み）

---

### 3. 明示的トランザクション

```SQL
BEGIN; -- 明示的にトランザクション開始
INSERT INTO tx_log(msg) VALUES('明示的 BEGIN 内 INSERT');
-- トランザクション ID 確認
SELECT txid_current_if_assigned() AS txid_inside_begin;
COMMIT; -- 明示的にコミット
```

- 挙動：
  - この間の処理は 1 つのトランザクションにまとめられる
  - 明示的に書けば、暗黙トランザクションは貼られない

---

### 4. DO ブロック（COMMIT 不可）

```SQL
DO $$
BEGIN
INSERT INTO tx_log(msg) VALUES('DO ブロック内 INSERT');
-- COMMIT; -- これはエラーになる
END;
$$;
```

- 挙動：
  - 外側のトランザクションに従属
  - 内部で COMMIT / ROLLBACK はできない

---

### 5. ストアドプロシージャ（CALL）

```SQL
CREATE OR REPLACE PROCEDURE demo_proc()
LANGUAGE plpgsql AS $$

BEGIN
  INSERT INTO tx_log(msg) VALUES('プロシージャ内 INSERT 前');

  COMMIT; -- 明示的に区切ることが可能

  INSERT INTO tx_log(msg) VALUES('プロシージャ内INSERT後');
  COMMIT; -- 再度コミット

END;
$$;
```

クエリツールで呼び出す

```SQL
-- CALL 前に外側のトランザクションを閉じておく
COMMIT;

-- CALL 実行
CALL demo_proc();

-- CALL 後に確認
SELECT * FROM tx_log ORDER BY id;
```

- 挙動：
  - CALL はクエリツール上で暗黙トランザクションを貼られない
  - プロシージャ内部で COMMIT が安全に実行できる
  - 外側で BEGIN している場合はエラーになる

---

### 6. プロシージャ内 BEGIN / END

```SQL
CREATE OR REPLACE PROCEDURE demo_block_proc()
LANGUAGE plpgsql AS $$

BEGIN
  -- BEGIN/END はブロック構文として書ける
  BEGIN
    INSERT INTO tx_log(msg) VALUES('プロシージャ内ブロック INSERT');
  END;

COMMIT;
END;
$$;

-- CALL して確認
CALL demo_block_proc();
SELECT * FROM tx_log ORDER BY id;
```

- ポイント：
  - BEGIN … END はブロックのスコープを示すだけ
  - 実際のトランザクションは自動的にプロシージャ内に存在
  - COMMIT で明示的にトランザクションを区切れる

---

### 7. トランザクションの挙動まとめ

| 区分                       | トランザクション制御 | 暗黙トランザクション | 備考                                                        |
| -------------------------- | -------------------- | -------------------- | ----------------------------------------------------------- |
| 通常 SQL 文                | ×                    | ○                    | 文ごとに自動トランザクション開始・コミット                  |
| 明示的 BEGIN / COMMIT      | ○                    | ×                    | 明示的にまとめて制御可能                                    |
| FUNCTION / DO              | ×                    | ×                    | 呼び出し元トランザクションに従属、COMMIT 不可               |
| PROCEDURE / CALL           | ○                    | ×                    | 内部で COMMIT 可能。CALL 時は暗黙トランザクション貼られない |
| プロシージャ内 BEGIN / END | ○（明示可）          | 自動                 | BEGIN はブロック構文、COMMIT で区切れる                     |

---

💡 ポイントまとめ

1. CALL はクエリツール上で暗黙トランザクションが貼られない特別扱い

2. 関数や DO ブロックでは COMMIT できない

3. プロシージャ内では BEGIN はブロック構文で、COMMIT/ROLLBACK でトランザクションを明示的に区切れる

4. 明示的に BEGIN を書くと暗黙トランザクションは貼られない

5. トランザクションを閉じると、次の文では暗黙的に再度トランザクションが開始される

$$
$$
