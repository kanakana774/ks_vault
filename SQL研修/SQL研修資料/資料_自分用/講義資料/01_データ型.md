### **データ型（Data Types）**

各列に格納できるデータの種類を定義します。RDBMS によって提供されるデータ型は多岐にわたりますが、ここではよく使われるものを紹介します。

| データ型 (PostgreSQL)            | 説明                                   | 具体例 (Example Value)      | 他の RDBMS での類似例        |
| :--------------------------- | :----------------------------------- | :----------------------- | :-------------------- |
| SMALLINT                     | 小さな整数値（約$-32,768$～ $32,767$）         | 10, -1000                | SMALLINT              |
| INTEGER                      | 整数値（約$-20$ 億～ $20$ 億）                | 123, -500000             | INT, NUMBER           |
| BIGINT                       | 大きな整数値（約$-9 * 10^{18}～ 9 * 10^{18}$） | 9876543210, -10000000000 | BIGINT                |
| NUMERIC(p, s) /DECIMAL(p, s) | **正確な**数値（p: 全体の桁数, s: 小数点以下の桁数）     | 123.45, 999.00           | DECIMAL(p, s)         |
| REAL                         | **単精度**浮動小数点数（**近似値**）               | 1.23, 0.0001             | FLOAT, FLOAT(24)      |
| DOUBLE PRECISION/FLOAT       | **倍精度**浮動小数点数（**近似値**）               | 123.456789, 0.000000001  | DOUBLE, FLOAT(53)     |
| VARCHAR(n)                   | 可変長文字列（最大 n 文字）                      | 'Hello', '商品 A'          | VARCHAR2(n), NVARCHAR |
| TEXT                         | 可変長文字列（長さ制限なし）                       | '長い文章や説明文'               | LONGTEXT              |
| BOOLEAN                      | 真偽値（TRUE, FALSE, NULL）               | TRUE, FALSE              | TINYINT(1), BIT       |
| DATE                         | 日付（年、月、日）                            | '2023-10-26'             | DATE                  |
| TIMESTAMP                    | 日付と時刻                                | '2023-10-26 14:30:00'    | DATETIME              |

#### **データ型選択のポイント**

- **TEXT 型**: PostgreSQL ではサイズ制限がありませんが、Oracle や SQL Server など他の RDBMS では TEXT 型に相当するデータ型がサイズ制限があったり、非推奨であったりする場合があります。汎用性を考慮するなら VARCHAR(n)を適切な長さで使うのが無難です。
- **BOOLEAN 型**: PostgreSQL や MySQL では BOOLEAN 型が直接サポートされますが、Oracle には BOOLEAN 型が存在しません。その代わりに CHAR(1)型と'T', 'F'などの値を組み合わせて真偽値を表現することが一般的です。
- **数値型 (NUMERIC / DECIMAL vs FLOAT / REAL / DOUBLE PRECISION) の選び方**:

  - **NUMERIC(p, s) または DECIMAL(p, s)（固定小数点数型）**:

    - **特徴**: **正確な**数値を格納します。p (precision) は全体の桁数、s (scale) は小数点以下の桁数を指定します。指定した精度で値を正確に保持するため、丸め誤差が発生しません。整数部分も小数点以下も整数で持っているため。
    - **用途**: **金額、金融データ、科学計算で厳密な精度が求められるデータ**など、誤差が許されない場面で必ず使用してください。
    - **例**: NUMERIC(10, 2) は小数点以下 2 桁、全体で最大 10 桁の数値を格納できます。12345678.90 のような金額に適しています。

  - **FLOAT、REAL、DOUBLE PRECISION（浮動小数点数型）**:

    - **特徴**: **近似値**を格納します。内部的には二進数（2 進数）で表現されるため、特に十進数（10 進数）の小数を扱う場合に、わずかな**丸め誤差**が生じることがあります。REAL は単精度、DOUBLE PRECISION（または FLOAT）は倍精度で、後者の方が精度は高いですが、それでも近似値です。
    - 丸め誤差が生じる理由:  
      コンピュータは基本的に 0 と 1 の二進数で数を表現します。10 進数で簡単に表せる分数（例: 0.1=1/10）でも、二進数で正確に表現できない場合があります。  
      例として、10 進数の 1/3 を考えてみましょう。これを 10 進数の小数で正確に表現しようとすると、$0.3333...$と無限に続きます。途中で打ち切ると「丸め誤差」が生じます。
      これと同様に、10 進数の 0.1 や 0.2 も、二進数で正確に表現しようとすると無限小数になることがあります。コンピュータは有限のビット数で表現するため、どこかで「丸め」が行われ、それがわずかな誤差として現れるのです。ほとんどの 10 進数の小数は、2 進数に正確に変換できません。
      ```
      0.1(10) = 0.000110011001100110011...(2)⇒2進数にすると循環小数に
      ```
    - **用途**: 科学計算、物理シミュレーション、グラフィック処理など、わずかな誤差が許容される高速な計算が必要な場面で使われます。
    - **絶対に使ってはいけない場面**: **金額や、正確な計算結果が必須なデータ**（例えば、0.1 + 0.2 が厳密に 0.3 になることが保証されないため）。
    - 具体例で見る誤差:  
       以下の SQL を実行してみてください。

      ```SQL
      -- これはいくつになると思いますか？
      select 0.1::DOUBLE PRECISION+0.2::DOUBLE PRECISION
      ```

      期待する結果は 0.3 ですが、浮動小数点数型で計算されると 0.30000000000000004 のようなわずかに異なる値になることがあります。そのため、厳密な比較を行うと予期しない結果になる可能性があります。

      ```SQL
      SELECT 0.1::FLOAT + 0.2::FLOAT = 0.3;
      ```

      このクエリは、期待に反して FALSE を返すことがあります。これが浮動小数点数の丸め誤差による影響です。

## リテラルとデータ型の扱い

SQL では、データ型を直接指定するだけでなく、値そのものを直接記述することがよくあります。これを**リテラル (Literal)** と呼びます。また、SQL エンジンはリテラルのデータ型を自動的に判断したり、異なるデータ型を組み合わせて使用する際に自動で型変換を行ったりします。

### リテラルとは？

**リテラル**は、SQL 文に直接記述される固定値のことです。プログラミング言語における「定数」のようなものです。

| リテラルの種類    | 例                           | 説明                                 |
| :---------------- | :--------------------------- | :----------------------------------- |
| 文字列リテラル    | `'Hello World'`, `'123'`     | シングルクォーテーションで囲みます。 |
| 数値リテラル      | `123`, `3.14`, `-5`          | 整数や小数をそのまま記述します。     |
| 論理値リテラル    | `TRUE`, `FALSE`              | 真偽値を記述します。                 |
| NULL リテラル     | `NULL`                       | 値がないことを表します。             |
| 日付/時刻リテラル | `'2023-01-01'`, `'10:30:00'` | シングルクォーテーションで囲みます。 |

### NULL の重要性

`NULL`は「値がない」「未知」の状態を表し、**空文字 (`''`) や数値の `0` とは異なります**。これは実務で非常によく誤解される点ですので、明確に理解しておく必要があります。

- `NULL` は値を持たないため、いかなる値とも等しくありません（`NULL = NULL` も `FALSE` になります）。
- `NULL` のチェックには `IS NULL` または `IS NOT NULL` を使用します。

### 型推論 (Type Inference)

SQL エンジンは、記述されたリテラルの形式から、そのリテラルがどのデータ型であるかを自動的に判断しようとします。

**例:**

- `SELECT 100;` ⇒ `INTEGER`型と推論されます。
- `SELECT 'Apple';` ⇒ `TEXT`型または`VARCHAR`型と推論されます。
- `SELECT 3.14;` ⇒ `NUMERIC`型または`DOUBLE PRECISION`型（浮動小数点数）と推論されます。

### 暗黙の型変換 (Implicit Type Conversion)

異なるデータ型の値を比較したり、演算したりする場合、SQL エンジンは互換性のあるデータ型に自動的に変換しようとします。これを**暗黙の型変換**と呼びます。

**例:**

```sql
SELECT 100 + '50'; -- '50'は文字列リテラルなのに、数値に変換され、150 になる（RDBMS によってはエラーになる場合もある）
SELECT '2023-01-01' > CURRENT_DATE; -- 日付文字列が日付型に変換され、比較される
```

注意点:
暗黙の型変換は便利ですが、予期せぬ結果やパフォーマンスの問題を引き起こす可能性があります。例えば、文字列と数値を比較する際に、意図しない型変換が行われて比較が正しく行われないことがあります。
例（意図しない結果の可能性）:
数値として保存されているカラム item_code があり、VARCHAR 型だとします。
SELECT \* FROM items WHERE item_code > '100';
この場合、item_code が文字列として比較されるため、'2'が'100'より大きいと判断されるなど、数値としての比較と異なる結果になることがあります。

#### **RDBMS による暗黙変換の度合い**

暗黙の型変換の厳格さは、RDBMS によって大きく異なります。

- **PostgreSQL**: 比較的柔軟な型推論と暗黙の型変換を行います。
- Oracle や SQL Server: PostgreSQL と比較して暗黙の型変換が厳格で、意図しない型変換はエラーになることが多く、明示的な型変換がより頻繁に求められます。
  実務では、利用する RDBMS の挙動を理解し、できる限り明示的な型変換を心がけることが重要です。

### **明示的な型変換 (Explicit Type Conversion)**

暗黙の型変換に頼るのではなく、**明示的にデータ型を変換する**ことを強く推奨します。これにより、意図しない挙動を防ぎ、SQL 文の可読性と安定性を高めることができます。

一般的に、CAST()関数や、RDBMS 固有の型変換演算子（PostgreSQL では::演算子）を使用します。

**3つの方法:**
```SQL
type 'string'
'string'::type
CAST ( 'string' AS type )
```

**例:**

```SQL
SELECT '123'::INTEGER + 456; -- PostgreSQL 特有の記法で文字列を INTEGER に変換
SELECT DATE '2023-01-01'; -- 文字列を DATE 型に変換
SELECT CAST('2023-01-01' AS DATE); -- 文字列を DATE 型に変換
SELECT 100 + CAST('50' AS INTEGER); -- '50'を明示的に INTEGER に変換
```


