## **サブクエリ (Subqueries) (実務での重要度：高)**

サブクエリとは、**SQL クエリの中に記述される別の SQL クエリ**のことです。内側のクエリが先に実行され、その結果が外側のクエリに渡されて利用されます。サブクエリは SELECT, FROM, WHERE 句など、様々な場所で使用できます。

### **非相関サブクエリ (Non-correlated Subquery)**

内側のサブクエリが外側のクエリから独立して実行され、一度だけ結果を生成します。その結果は、外側のクエリ全体で利用されます。

#### **例 1: WHERE 句での利用（単一値またはリストを返す場合）**

平均価格より高い商品のリストを取得。

**事前データ:**

products テーブル:

| product_id | product_name | price   | category_id |
| :--------- | :----------- | :------ | :---------- |
| 1          | Laptop       | 1200.00 | 1           |
| 2          | Mouse        | 25.50   | 1           |
| 3          | Keyboard     | 75.00   | 1           |
| 4          | Monitor      | 300.00  | NULL        |
| 5          | Webcam       | 50.00   | 2           |

**SQL:**

```SQL
with p as (
select 1 as product_id, 'Laptop  ' product_name , 1200.00 as price , 1    as category_id union all
select 2 as product_id, 'Mouse   ' product_name , 25.50   as price , 1    as category_id union all
select 3 as product_id, 'Keyboard' product_name , 75.00   as price , 1    as category_id union all
select 4 as product_id, 'Monitor ' product_name , 300.00  as price , NULL as category_id union all
select 5 as product_id, 'Webcam  ' product_name , 50.00   as price , 2    as category_id
)

SELECT product_name, price
FROM products
WHERE price > (SELECT AVG(price) FROM products); -- サブクエリが先に平均価格を計算
```

（補足: 上記 products テーブルの AVG(price)は約 330.1 となります）

**実行結果:**

| product_name | price   |
| :----------- | :------ |
| Laptop       | 1200.00 |

このサブクエリは一度だけ実行され、products テーブルの平均価格（約 330.1）を返します。その後、外側のクエリが WHERE price \> 330.1 のように評価されます。

#### **例 2: FROM 句での利用（派生テーブルとして）**

サブクエリの結果を一時的なテーブル（**派生テーブル**または**導出テーブル**）として扱い、その上でさらにクエリを実行します。必ずエイリアスが必要です。

在庫が 100 以上の高額商品（1000 ドル以上）の平均価格を計算。

**事前データ:**

products テーブル:

| product_id | product_name | price   | category_id |
| :--------- | :----------- | :------ | :---------- |
| 1          | Laptop       | 1200.00 | 1           |
| 2          | Mouse        | 25.50   | 1           |
| 3          | Keyboard     | 75.00   | 1           |
| 4          | Monitor      | 300.00  | NULL        |
| 5          | Webcam       | 50.00   | 2           |

**SQL:**

```SQL
SELECT AVG(high_price_product_price) AS avg_high_price_product_price
FROM (
   SELECT product_name, price AS high_price_product_price
   FROM p
   WHERE  price >= 300
) AS high_value_products; -- サブクエリにエイリアスが必要
```

（補足: サブクエリの結果は Laptop 1200.00、Monitor 300.00）

**実行結果:**

| avg_high_price_product_price |
| :--------------------------- |
| 750.00                       |

このサブクエリは、まず条件に合う商品（この例では Laptop、Monitor のみ）を抽出し、その結果に対して外側のクエリが平均値を計算します。

#### **例 3: SELECT 句での利用（スカラサブクエリ）**

単一の行と単一の列（**スカラ値**）を返すサブクエリです。

各商品について、その商品のカテゴリに属する全商品の平均価格を合わせて表示（カテゴリの平均価格）。

**事前データ:**

products テーブル:

| product_id | product_name | price   | category_id |
| :--------- | :----------- | :------ | :---------- |
| 1          | Laptop       | 1200.00 | 1           |
| 2          | Mouse        | 25.50   | 1           |
| 3          | Keyboard     | 75.00   | 1           |
| 4          | Monitor      | 300.00  | NULL        |
| 5          | Webcam       | 50.00   | 2           |

**SQL:**

```SQL
SELECT
   p.product_name,
   p.price,
   p.category_id,
   (SELECT AVG(price) FROM products WHERE category_id = p.category_id) AS avg_category_price
FROM
   products AS p;
```

（補足: category_id=1 の平均価格 = (1200+25.5+75)/3 = 433.5、category_id=2 の平均価格 = 50/1 = 50、category_id=NULL の平均価格 = NULL）

**実行結果:**

| product_name | price   | category_id | avg_category_price |
| :----------- | :------ | :---------- | :----------------- |
| Laptop       | 1200.00 | 1           | 433.50             |
| Mouse        | 25.50   | 1           | 433.50             |
| Keyboard     | 75.00   | 1           | 433.50             |
| Monitor      | 300.00  | NULL        | NULL               |
| Webcam       | 50.00   | 2           | 50.00              |

この例では、SELECT 句のサブクエリは、外側のクエリの p.category_id に依存しており、行ごとに実行されます。これは次に説明する「相関サブクエリ」の性質を持っています。

### **相関サブクエリ (Correlated Subquery) (実務での重要度：中)**

内側のサブクエリが外側のクエリの現在の行の値に依存して実行されるサブクエリです。外側のクエリの行が処理されるたびに、内側のサブクエリが再評価されます。パフォーマンスに影響を与えることがあるため、代替手段（JOIN やウィンドウ関数）を検討することが推奨されます。

#### **💡 コラム: なぜ相関サブクエリはパフォーマンスに影響を与えるのか？**

相関サブクエリは、外側のクエリの**各行**が処理されるたびに**再実行**されます。もし外側のクエリが 1000 行あった場合、内側のサブクエリも 1000 回実行されることになります。これにより、特にデータ量が多い場合や、内側のサブクエリが複雑な場合に、処理時間が大幅に増加する可能性があります。

非相関サブクエリは一度だけ実行されるため、この点が大きな違いとなります。パフォーマンスが問題となる場合は、相関サブクエリを JOIN 句や**ウィンドウ関数**（後の章で学習）に書き換えることで改善できる場合があります。

#### **例: 各カテゴリで最も価格が高い商品を取得**

**事前データ:**

products テーブル:

| product_id | product_name | price   | category_id |
| :--------- | :----------- | :------ | :---------- |
| 1          | Laptop       | 1200.00 | 1           |
| 2          | Mouse        | 25.50   | 1           |
| 3          | Keyboard     | 75.00   | 1           |
| 4          | Monitor      | 300.00  | NULL        |
| 5          | Webcam       | 50.00   | 2           |
| 6          | Headset      | 150.00  | 2           |

**SQL:**

```SQL
with p as (
select 1 as product_id , 'Laptop  ' as product_name, 1200.00 as price, 1    as category_id union all
select 2 as product_id , 'Mouse   ' as product_name, 25.50   as price, 1    as category_id union all
select 3 as product_id , 'Keyboard' as product_name, 75.00   as price, 1    as category_id union all
select 4 as product_id , 'Monitor ' as product_name, 300.00  as price, NULL as category_id union all
select 5 as product_id , 'Webcam  ' as product_name, 50.00   as price, 2    as category_id union all
select 6 as product_id , 'Headset ' as product_name, 150.00  as price, 2    as category_id
)


SELECT
   p1.product_name,
   p1.price,
   p1.category_id
FROM
   products AS p1
WHERE
   p1.price = (SELECT MAX(p2.price) FROM products AS p2 WHERE p2.category_id = p1.category_id);
```

（補足: category_id=1 の最大価格は 1200.00、category_id=2 の最大価格は 150.00、category_id=NULL の最大価格は NULL）

**実行結果:**

| product_name | price   | category_id |
| :----------- | :------ | :---------- |
| Laptop       | 1200.00 | 1           |
| Headset      | 150.00  | 2           |

このクエリでは、内側のサブクエリ SELECT MAX(p2.price) FROM products AS p2 WHERE p2.category_id = p1.category_id は、外側のクエリ（p1）の現在の category_id に依存します。外側のクエリが products テーブルの各行を処理するたびに、その商品の category_id を使ってサブクエリが実行され、そのカテゴリの最大価格を取得します。

### **EXISTS / NOT EXISTS (実務での重要度：高)**

サブクエリが何らかの行を返すかどうか（存在するかどうか）をチェックします。サブクエリの内部が実際にデータを返す必要はなく、**条件に一致する行が 1 つでも見つかれば TRUE を返し、そうでなければ FALSE を返します**。

IN 句がサブクエリの結果と具体的な値を比較するのに対し、EXISTS は単に「存在するか」をチェックするため、パフォーマンス面で優れている場合があります（特にサブクエリが大量の行を返す可能性がある場合）。

#### **基本構文**

```SQL
-- EXISTS
SELECT 列リスト
FROM テーブル 1
WHERE EXISTS (サブクエリ);

-- NOT EXISTS
SELECT 列リスト
FROM テーブル 1
WHERE NOT EXISTS (サブクエリ);
```

#### **例: 少なくとも 1 つの注文がある顧客を取得**

**事前データ:**

customers テーブル:

| customer_id | customer_name |
| :---------- | :------------ |
| 1           | Alice         |
| 2           | Bob           |
| 3           | Charlie       |
| 4           | David         |

orders テーブル:

| order_id | customer_id | order_date   |
| :------- | :---------- | :----------- |
| 1        | 1           | '2023-01-01' |
| 2        | 1           | '2023-01-05' |
| 3        | 2           | '2023-02-10' |
| 4        | 4           | '2023-03-15' |

**SQL:**

```SQL
SELECT customer_name
FROM customers AS c
WHERE EXISTS (
   SELECT 1 -- 実際に何を選択するかは重要ではない、行の存在が重要
   FROM orders AS o
   WHERE o.customer_id = c.customer_id
);
```

**実行結果:**

| customer_name |
| :------------ |
| Alice         |
| Bob           |
| David         |

このクエリは、orders テーブルに customers テーブルの現在の顧客 ID と一致する行が 1 つでも存在すれば、その顧客を結果に含めます。Charlie は注文がないため含まれません。

#### **例: 注文が一度もない顧客を取得**

事前データ:
（EXISTS の例と同じデータを使用）
**SQL:**

```SQL
SELECT customer_name
FROM customers AS c
WHERE NOT EXISTS (
   SELECT 1
   FROM orders AS o
   WHERE o.customer_id \= c.customer_id
);
```

**実行結果:**

| customer_name |
| :------------ |
| Charlie       |

このクエリは、orders テーブルに customers テーブルの現在の顧客 ID と一致する行が一つも存在しない顧客を結果に含めます。Charlie のみが対象となります。

#### **IN と EXISTS の使い分け (実務での重要度：高)**

両者ともサブクエリを使って条件を絞り込む際に使われますが、内部的な動作と得意なケースが異なります。

- **IN**:
- サブクエリが返す**値のリスト**に対して、外側のクエリの列が一致するかどうかを評価します。
- サブクエリの結果が比較的小さいリストである場合に効率的です。
- サブクエリが NULL を返すと、予期せぬ結果になる可能性があります（IN リストに NULL が含まれる場合、NULL と比較される行は UNKNOWN となり、結果に含まれないため）。
- WHERE col IN (SELECT val FROM subquery)
- **EXISTS**:
- サブクエリが**行を返すかどうか**（存在するどうか）のみを評価します。具体的な値を比較するわけではありません。
- サブクエリが大量の行を返す可能性がある場合に、しばしば IN よりも効率的です。なぜなら、EXISTS は条件に一致する最初の 1 行を見つけた時点でサブクエリの実行を停止できるためです。
- NULL 値の影響を受けにくいです。
- WHERE EXISTS (SELECT 1 FROM subquery WHERE outer_col = inner_col)

**使い分けの指針:**

- **サブクエリの結果が少数の値のリスト**で、かつ NULL 値の心配が少ない場合 → **IN**
- **サブクエリの結果が大量の行**になる可能性があり、または\*\*サブクエリ内で外部クエリの列を参照する（相関サブクエリになる）\*\*場合 → **EXISTS**

### **サブクエリの代替としての JOIN (実務での重要度：高)**

多くの相関サブクエリや、IN 句を使用する非相関サブクエリは、JOIN 句を使用することで書き換え可能です。一般的に、JOIN 句の方がパフォーマンスが優れていることが多いとされています（オプティマイザがより最適化しやすい構造のため）。

相関サブクエリの例を JOIN で書き換え:
（各カテゴリで最も価格が高い商品を取得）

```SQL
-- 相関サブクエリの元の例
SELECT
   p1.product_name,
   p1.price,
   p1.category_id
FROM
   products AS p1
WHERE
   p1.price = (SELECT MAX(p2.price) FROM products AS p2 WHERE p2.category_id = p1.category_id);
```

```sql
-- JOIN と GROUP BY で書き換え
SELECT
   p.product_name,
   p.price,
   p.category_id
FROM
   products AS p
INNER JOIN (
   SELECT category_id, MAX(price) AS max_price_in_category
   FROM products
   GROUP BY category_id
) AS max_prices
ON p.category_id = max_prices.category_id AND p.price = max_prices.max_price_in_category;
```

この JOIN を使用したクエリは、まず各カテゴリの最大価格をサブクエリで計算し、その結果を元のテーブルと結合して、最大価格を持つ商品に絞り込んでいます。多くの場合、このような書き換えの方が効率的です。

## **RDBMS 間の違いに注意！ (実務での重要度：中)**

ここまで見てきた JOIN、集合演算、サブクエリの構文や挙動は、多くの RDBMS で共通していますが、細かな部分で違いがあります。

| 機能/概念                      | PostgreSQL                                            | MySQL                                                 | Oracle                                                | SQL Server                                            |
| :----------------------------- | :---------------------------------------------------- | :---------------------------------------------------- | :---------------------------------------------------- | :---------------------------------------------------- |
| FULL OUTER JOIN                | サポートあり                                          | サポートなし（代替で対応）                            | サポートあり                                          | サポートあり                                          |
| EXCEPT / MINUS                 | EXCEPT                                                | サポートなし（代替で対応）                            | MINUS                                                 | EXCEPT                                                |
| LIMIT/OFFSET                   | LIMIT OFFSET                                          | LIMIT OFFSET                                          | ROWNUM / OFFSET FETCH                                 | TOP / OFFSET FETCH                                    |
| サブクエリの最適化             | 進んでいる                                            | 進んでいる                                            | 進んでいる                                            | 進んでいる                                            |
| 相関サブクエリのパフォーマンス | 状況によるが、JOIN やウィンドウ関数への書き換えを推奨 | 状況によるが、JOIN やウィンドウ関数への書き換えを推奨 | 状況によるが、JOIN やウィンドウ関数への書き換えを推奨 | 状況によるが、JOIN やウィンドウ関数への書き換えを推奨 |

特に FULL OUTER JOIN や EXCEPT/MINUS は、RDBMS によってサポート状況や名称が異なるため、使用する際には注意が必要です。
