# **SQL 基礎：集計とグループ化、関数**

## **導入：集計とグループ化の目的**

データベースに格納されている生データは、そのままでは大量すぎて全体像を把握しにくい場合があります。ビジネスにおける意思決定や分析には、データを要約し、傾向を把握することが不可欠です。ここで「集計」と「グループ化」の概念が重要になります。

- **集計**: 複数の行のデータを計算し、単一の要約値を導き出すこと（例: 合計、平均、最大値）。
- **グループ化**: 特定の基準に基づいてデータを複数のグループに分割し、それぞれのグループに対して集計を行うこと。

また、日付や文字列のデータは、そのままの形式では分析や表示に適さない場合があります。これらのデータを加工・整形するために「日付・文字列関数」を活用します。

## **集計関数 (Aggregate Functions)**

集計関数は、複数の行の値をまとめて計算し、1 つの結果値を返します。
SELECT 句で直接使用することも、GROUP BY 句と組み合わせて使用することもできます。

### **COUNT()：行数のカウント**

指定した行または非 NULL 値の数をカウントします。

- **COUNT(\*)**: テーブルまたはクエリ結果の**全行数**をカウントします。NULL 値を含む全ての行が対象です。
- **COUNT(列名)**: 指定した列の**NULL ではない値**の数をカウントします。
- **COUNT(DISTINCT 列名)**: 指定した列の**重複を除いた NULL ではない値**の数をカウントします。

例: products テーブルを仮定します。  
（product_id, product_name, price, stock_quantity, category）

```SQL
-- テーブル全体の行数をカウント
SELECT COUNT(*) AS total_products FROM products;
```

```SQL
-- price 列に値がある商品の数をカウント (NULL ではない商品の数)
SELECT COUNT(price) AS products_with_price FROM products;
```

```SQL
-- 重複を除いたカテゴリの数をカウント
SELECT COUNT(DISTINCT category) AS unique_categories FROM products;
```

#### **💡 コラム: COUNT(1) と COUNT(\*) の違い**

SQL の初心者からよく聞かれる質問ですが、PostgreSQL を含む多くの RDBMS において、COUNT(1)と COUNT(\*)の機能的な違いは**ありません**。どちらもテーブルの全行数をカウントします。

歴史的には COUNT(\*)よりも COUNT(1)の方が高速であるという誤解がありましたが、現代の RDBMS ではオプティマイザが賢いため、ほとんどの場合パフォーマンスに差はありません。どちらを使っても構いませんが、COUNT(\*)の方が SQL 標準であり、より直感的で一般的です。

### **SUM()：合計値の算出**

指定した数値列の合計値を算出します。NULL 値は無視されます。

```SQL
-- 全商品の合計価格を算出
SELECT SUM(price) AS total_price FROM products;
```

```SQL
-- 全商品の合計在庫数を算出
SELECT SUM(stock_quantity) AS total_stock FROM products;
```

### **AVG()：平均値の算出**

指定した数値列の平均値を算出します。NULL 値は計算から除外されます。

```SQL
-- 全商品の平均価格を算出
SELECT AVG(price) AS average_price FROM products;
```

#### **DISTINCT と集計関数**

集計関数に DISTINCT キーワードを適用することで、重複する値を除外して集計を行うことができます。

**例:** 重複を除いたカテゴリ数を算出

```SQL
-- 全商品数 (重複値も含む)
SELECT COUNT(category) AS average_price FROM products;
```

```SQL
-- 重複を除いた全商品数＝カテゴリ数
SELECT COUNT(DISTINCT category) AS average_distinct_price FROM products;
```

### **MIN() / MAX()：最小値・最大値の算出**

指定した列の最小値または最大値を算出します。数値型だけでなく、文字列型や日付型にも適用可能です。NULL 値は無視されます。

```SQL
-- 最も安い商品の価格
SELECT MIN(price) AS min_price FROM products;
```

```SQL
-- 最も高い商品の価格
SELECT MAX(price) AS max_price FROM products;
```

```SQL
-- アルファベット順で最初に来る商品名
SELECT MIN(product_name) AS first_product_name FROM products;
```

#### **集計関数における NULL の扱い**

集計関数（SUM, AVG, MIN, MAX, COUNT(列名), COUNT(DISTINCT 列名)）は、デフォルトで\*\*NULL 値を除外して計算\*\*します。これは特に AVG で重要です。

例: 以下のデータを持つ sales テーブルを考えます。  
| sale_id | product_id | amount |  
| :------- | :---------- | :----- |  
| 1 | 101 | 100 |  
| 2 | 102 | NULL |  
| 3 | 101 | 200 |

- COUNT(\*): 3 (全行数)
- COUNT(amount): 2 (NULL を除く値の数)
- SUM(amount): 300 (100 \+ 200\)
- AVG(amount): 150 (300 / 2、NULL は分母からも除外される)

もし NULL を含む行を平均の計算に含めたい場合は、事前に COALESCE などの関数で NULL を 0 などに置き換える必要があります。

## **グループ化 (Grouping)：GROUP BY 句と HAVING 句**

集計関数は、通常、テーブル全体の要約値を計算します。しかし、特定の条件でグループ分けし、そのグループごとに集計を行いたい場合に GROUP BY 句を使用します。HAVING 句は、そのグループ化された結果に対してさらに条件を適用する際に使います。

### **GROUP BY 句：データをグループに分割**

1 つ以上の列の値に基づいて、行をグループにまとめます。SELECT 句で集計関数以外の列を指定する場合、その列は必ず GROUP BY 句にも含める必要があります。

#### **基本構文**

```SQL
SELECT 列名 1
FROM テーブル名
GROUP BY 列名 1;
```

```SQL
SELECT
	CATEGORY
FROM
	PRODUCTS_MST
GROUP BY
	CATEGORY;
```

#### **基本構文（集約関数と一緒に使う＝これが基本）**

```SQL
SELECT 列名 1, 集計関数(列名 2)
FROM テーブル名
GROUP BY 列名 1;
```

**例:** カテゴリごとの商品数と平均価格を算出します。

```SQL
SELECT
	CATEGORY,
	COUNT(*) AS PRODUCT_COUNT,
	AVG(PRICE) AS AVERAGE_PRICE
FROM
	PRODUCTS_MST
GROUP BY
	CATEGORY;
```

#### **GROUP BY 句の制約と SQL エラー**

SELECT 句で、集計関数を使用しない列（非集計列）を指定する場合、その非集計列は**必ず GROUP BY 句に含めなければなりません**。これは、どのグループの値を表示すべきか SQL エンジンが判断できないためです。

**例（エラーになる場合）:**

```SQL
-- ERROR: SELECT 句の'price'は GROUP BY 句に存在しないか、集計関数で囲まれていません
SELECT
	CATEGORY,
	PRICE
FROM
	PRODUCTS
GROUP BY
	CATEGORY;
```

上記のエラーは、category でグループ化しているにもかかわらず、price という個々の行に属する値を SELECT しようとしているために発生します。category ごとに price が複数存在する可能性があるため、どの price を表示すべきか一意に決まらないからです。

#### **💡 コラム: GROUP BY の緩い RDBMS (MySQL の例)**

PostgreSQL や Oracle などの多くの RDBMS は上記の GROUP BY の制約を厳格に適用しますが、MySQL の古いバージョンや特定のモードでは、SELECT 句に GROUP BY に含まれない非集計列を指定することが許されていました。その場合、そのグループ内のいずれかの値（通常は最初に見つかった値）がランダムに選ばれて表示されるため、予期しない結果を招く可能性がありました。

このような挙動は SQL 標準に準拠しておらず、混乱の元となるため、多くの RDBMS では厳格なルールが適用されます。常に\*\*SELECT 句の非集計列は GROUP BY 句に含める\*\*ように心がけましょう。

### **HAVING 句：グループ化された結果への条件**

WHERE 句が個々の行に対する条件を指定するのに対し、HAVING 句は\*\*GROUP BY によって集計された結果\*\*に対して条件を指定します。
集計関数を HAVING 句の中で直接使用できます。

#### **基本構文**

```SQL
SELECT 列名 1, 集計関数(列名 2)
FROM テーブル名
GROUP BY 列名 1
HAVING 集計結果に対する条件式;
```

**例:** 平均価格が 500 より大きいカテゴリのみを抽出します。

```SQL
SELECT
	CATEGORY,
	COUNT(*) AS PRODUCT_COUNT,
	AVG(PRICE) AS AVERAGE_PRICE
FROM
	PRODUCTS
GROUP BY
	CATEGORY
HAVING
	AVG(PRICE) > 500;
-- AVERAGE_PRICE > 500 とはできない
```

補足：AVERAGE_PRICE > 500 とはできない。
having 句の実行後に select が処理されるため。詳細は下記実行順参照。

#### **WHERE 句と HAVING 句の違い**

混同しやすいですが、両者には明確な役割の違いがあります。

| 特徴               | WHERE 句                                               | HAVING 句                                                   |
| :----------------- | :----------------------------------------------------- | :---------------------------------------------------------- |
| **評価タイミング** | GROUP BY 句の**前**に個々の行に対して評価される        | GROUP BY 句の**後**にグループ化された結果に対して評価される |
| **使用できる要素** | 元のテーブルの列 (SELECT 句で指定されていなくても良い) | 集計関数、または GROUP BY 句で指定された列                  |
| **目的**           | データを集計する前に、不要な行をフィルタリングする     | 集計された結果の中から、さらに条件でフィルタリングする      |

**処理順のイメージ:**

1. **FROM/JOIN**: どのテーブルからデータを取得するか
2. **WHERE**: 個々の行をフィルタリング（ここで不要な行を減らすことで、次の集計の負荷を軽減）
3. **GROUP BY**: フィルタリングされた行をグループ化
4. **HAVING**: 集計結果に対してさらにフィルタリング　**集計関数**: 各グループ内で集計を実行
5. **SELECT**: 最終的に表示する列を選択　**集計関数**: 各グループ内で集計を実行
6. **ORDER BY**: 結果を並び替える
7. **LIMIT/OFFSET**: 表示件数を制限

**例:** 在庫数が 10 より多い商品のみを対象に、カテゴリごとの平均価格を算出し、その平均価格が 500 より大きいカテゴリのみを抽出。

```SQL
SELECT
	CATEGORY,
	COUNT(*) AS PRODUCT_COUNT,
	AVG(PRICE) AS AVERAGE_PRICE
FROM
	PRODUCTS
WHERE
	STOCK_QUANTITY > 10 -- (1) まず在庫が 10 より多い商品に絞り込む（集計前）
GROUP BY
	CATEGORY
HAVING
	AVG(PRICE) > 500;-- (2) その後、絞り込んだデータで集計し、平均価格が 500 より大きいグループを抽出（集計後）
```



