## III. SQLの実行と制御フロー (Executing SQL and Control Flow)

この単元では、PL/pgSQLブロック内でSQL文をどのように実行するのか、そしてプログラムの流れを意のままに操るための条件分岐やループといった制御構造について学びます。

### 1. 静的SQLの実行

静的SQLとは、コード内に直接記述された、実行時に変化しないSQL文のことです。

#### `SELECT INTO`：クエリ結果を変数に格納する

`SELECT`文の結果が**必ず1行**であることが期待される場合に、その結果を変数に直接格納するための構文です。

**具体例：IDを指定して従業員の名前を取得する**

（前章で作成した`employees`テーブルを使用します）

```sql
DO $$
DECLARE
    -- 取得した名前を格納する変数
    employee_name employees.name%TYPE;
    target_id     employees.id%TYPE := 1;
BEGIN
    -- id=1の従業員のname列をemployee_name変数に格納する
    SELECT name INTO employee_name FROM employees WHERE id = target_id;

    RAISE NOTICE 'ID % is %', target_id, employee_name;
END;
$$ LANGUAGE plpgsql;
```

**実行結果:**

```
NOTICE:  ID 1 is Taro Yamada
```

**【重要】 `SELECT INTO` の注意点**
*   **結果が0行の場合:** `no_data_found`というエラーが発生します。（後の章で学ぶ`EXCEPTION`ブロックで捕捉できます）
*   **結果が2行以上の場合:** `too_many_rows`というエラーが発生します。
*   デフォルトでは厳格(`STRICT`)に1行であることを要求します。もし複数行が返る可能性がある場合は、カーソルや`FOR`ループ（後述）を使用する必要があります。

#### `PERFORM`：クエリを実行するが、結果は破棄する

`INSERT`、`UPDATE`、`DELETE`などのDML文は戻り値がないため直接実行できます。`PERFORM`が特に役立つのは、「値を返す`SELECT`文や関数を、その副作用（例: シーケンスを進める）のためだけに実行し、戻り値は不要な」場合です。`INTO`句なしで`SELECT`を実行するとエラーになるため、`PERFORM`で結果を破棄します。

**具体例：シーケンスを進めるためだけに関数を呼び出す**

```sql
-- ログ用のテーブルとシーケンス
CREATE TABLE execution_log (
    id serial PRIMARY KEY,
    log_message text,
    logged_at timestamptz DEFAULT now()
);

DO $$
BEGIN
    -- INSERT文は直接実行できる
    INSERT INTO execution_log (log_message) VALUES ('Process started');

    -- nextval()はシーケンスの次の値を返すが、今回はその値自体は不要。
    -- 副作用である「シーケンスを進める」ことだけが目的なのでPERFORMを使う。
    PERFORM nextval('execution_log_id_seq');

    RAISE NOTICE 'Log entry created and sequence advanced.';
END;
$$ LANGUAGE plpgsql;
```

 #### `RETURNING ... INTO`：DML文の実行結果を変数に格納する

 `INSERT`、`UPDATE`、`DELETE`文を実行した際に、実際に処理された行の値を直接変数に格納したい場合があります。このときに`RETURNING`句と`INTO`句を組み合わせることで、DML文の実行と値の取得を一度に行うことができ、非常に効率的です。

 **具体例：新しい従業員を登録し、自動採番されたIDを取得する**

 ```sql
 DO $$
 DECLARE
     -- INSERTされた従業員のIDを格納する変数
     new_employee_id employees.id%TYPE;
 BEGIN
     INSERT INTO employees (name, salary)
     VALUES ('Jiro Suzuki', 550000)
     RETURNING id INTO new_employee_id;

     RAISE NOTICE 'New employee created with ID: %', new_employee_id;
 END;
 $$ LANGUAGE plpgsql;
 ```

 このように、`RETURNING`句を使えば、`INSERT`後にわざわざ`SELECT`文で`id`を再検索する必要がありません。`UPDATE`で変更後の値を取得したり、`DELETE`で削除した行の情報をログに残したりする際にも極めて有効です。
#### 特殊変数：`FOUND` と `ROW_COUNT`

PL/pgSQLには、直前に実行したSQL文の状態を把握するための特殊な変数が用意されています。これらを使うことで、処理が期待通りに行われたかを簡単にチェックできます。

##### `FOUND` (`boolean`型)

直前に実行されたSQL文（`SELECT INTO`, `UPDATE`, `INSERT`, `DELETE`, `FETCH`など）が、**1行以上の対象行を見つけたかどうか**を示す`boolean`型の変数です。

*   **`true`**: 1行以上の行が処理された（見つかった）場合。
*   **`false`**: 処理対象の行が見つからなかった場合（0行だった場合）。

**具体例：従業員情報が存在するか確認してから更新する**
```sql
DO $$
DECLARE
    target_id employees.id%TYPE := 1;
BEGIN
    -- まず、SELECT INTOで存在を確認
    PERFORM id FROM employees WHERE id = target_id;

    IF FOUND THEN
        RAISE NOTICE 'Employee % found. Proceeding with update...', target_id;
        UPDATE employees SET name = 'Taro Yamada Updated' WHERE id = target_id;
    ELSE
        RAISE NOTICE 'Employee % not found.', target_id;
    END IF;
END;
$$ LANGUAGE plpgsql;
```

##### `ROW_COUNT` (`integer`型) と `GET DIAGNOSTICS` コマンド

`FOUND`が「見つかったか（はい/いいえ）」しか教えてくれないのに対し、**「具体的に何行が影響を受けたか」**を知りたい場合には `GET DIAGNOSTICS` コマンドを使います。

`GET DIAGNOSTICS` は、直前のコマンドに関する様々な診断情報を取得するためのコマンドで、`ROW_COUNT`はその中で最もよく使われる情報です。

**構文:**
`GET DIAGNOSTICS variable_name = ROW_COUNT;`

**具体例：条件に一致するログを全て削除し、削除件数を報告する**
```sql
DO $$
DECLARE
    deleted_rows_count integer;
BEGIN
    -- 2025年より前の古いログを削除
    DELETE FROM execution_log WHERE logged_at < '2025-01-01';

    -- 直前のDELETE文で何行が削除されたかを取得
    GET DIAGNOSTICS deleted_rows_count = ROW_COUNT;

    RAISE NOTICE '% rows of old logs were deleted.', deleted_rows_count;
END;
$$ LANGUAGE plpgsql;
```
`UPDATE`や`DELETE`が意図せず0行、あるいは想定より多くの行に影響を与えていないかを確認する際に非常に役立ちます。

### 2. 動的SQLの実行

動的SQLとは、プログラムの実行中に文字列としてSQL文を組み立て、それを実行する手法です。テーブル名や列名、検索条件が実行時まで確定しない場合に使用します。

#### `EXECUTE`：文字列からSQL文を実行する

`EXECUTE`コマンドは、文字列として与えられたSQL文を実行します。

**具体例：引数で指定されたテーブルの行数を返す関数**
```sql
CREATE OR REPLACE FUNCTION count_rows(table_name text)
RETURNS integer AS $$
DECLARE
    row_count integer;
BEGIN
    -- format関数を使って安全にSQL文を組み立てる
    EXECUTE format('SELECT count(*) FROM %I', table_name)
    INTO row_count;
    RETURN row_count;
END;
$$ LANGUAGE plpgsql;

-- 実行
SELECT count_rows('employees');
```

#### `USING`句：動的SQLへ安全に値を渡す

動的SQLで最も注意すべきは**SQLインジェクション**です。ユーザーからの入力を単純に文字列連結してSQL文を作成すると、悪意のあるSQLを埋め込まれる危険性があります。これを防ぐために、値は`USING`句を使ってプレースホルダ（`$1`, `$2`...）に渡します。

**具体例：動的な`WHERE`句に安全に値を渡す**
```sql
CREATE OR REPLACE FUNCTION get_employee_by_id_dynamic(p_id integer)
RETURNS employees%ROWTYPE AS $$
DECLARE
    -- 戻り値用のレコード型変数
    result_rec employees%ROWTYPE;
BEGIN
    -- $1がプレースホルダ。USING句で渡された値が安全に埋め込まれる
    EXECUTE 'SELECT * FROM employees WHERE id = $1'
    INTO result_rec
    USING p_id;

    RETURN result_rec;
END;
$$ LANGUAGE plpgsql;

-- 実行
SELECT * FROM get_employee_by_id_dynamic(2);
```

#### `format()`関数とSQLインジェクション対策

`USING`句は「値」を安全に渡せますが、テーブル名や列名といった「識別子」を渡すことはできません。識別子を動的に扱いたい場合は`format()`関数を使います。

*   `%I` (Identifier): 識別子として安全にクォートして埋め込みます。
*   `%L` (Literal): 値（リテラル）として安全にクォートして埋め込みます。

**`RETURN QUERY`：動的SQLの結果セットを返す**
`EXECUTE`で実行した`SELECT`文の結果セットを、そのまま関数の戻り値（テーブル形式）として返したい場合に `RETURN QUERY EXECUTE` を使います。

**具体例：列名と検索値を動的に指定して従業員を検索する**
```sql
-- 戻り値の型としてテーブル形式(SETOF)を指定
CREATE OR REPLACE FUNCTION find_employee(column_name text, search_value text)
RETURNS SETOF employees AS $$
DECLARE
    sql_query text;
BEGIN
    /*
     * !! 危険な例 (SQLインジェクションの脆弱性あり) !!
     * sql_query := 'SELECT * FROM employees WHERE ' || column_name || ' = ''' || search_value || ''';';
     * もし search_value が "Taro' OR 1=1; --" のような値だったら...
     * SELECT * FROM employees WHERE name = 'Taro' OR 1=1; --'; となり、全件取得されてしまう。
     */

    -- format()関数で識別子(%I)とリテラル(%L)を安全に埋め込む
    sql_query := format('SELECT * FROM employees WHERE %I = %L', column_name, search_value);
    RAISE NOTICE 'Executing: %', sql_query;

    -- 組み立てたクエリを実行し、その結果を関数の戻り値として返す
    RETURN QUERY EXECUTE sql_query;
END;
$$ LANGUAGE plpgsql;

-- 実行
SELECT * FROM find_employee('name', 'Taro Yamada');
```


 #### 【パフォーマンスに関する注意点】
 
 動的SQLは非常に強力ですが、静的SQLと比較してパフォーマンス上のオーバーヘッドが生じる可能性があります。静的SQLはPostgreSQLが最初に関数を解析する際に実行計画をキャッシュできますが、動的SQLは`EXECUTE`が実行されるたびにSQL文の解析と実行計画の作成が行われるためです。

 特に、**ループ内で何度も同じ構造の動的SQLを実行する場合**は注意が必要です。パフォーマンスが重要な処理では、可能な限り静的SQLを使用することを検討してください。

### 3. 制御構造

#### 条件分岐：`IF` と `CASE`

**`IF-THEN-ELSIF-ELSE-END IF`**

```sql
DO $$
DECLARE
    sales_amount integer := 15000;
    customer_rank text;
BEGIN
    IF sales_amount > 20000 THEN
        customer_rank := 'Gold';
    ELSIF sales_amount > 10000 THEN
        customer_rank := 'Silver';
    ELSE
        customer_rank := 'Bronze';
    END IF;
    RAISE NOTICE 'Customer Rank: %', customer_rank;
END;
$$;
```

**`CASE`**
`CASE`には2つの形式があります。

**1. 単純CASE文 (Simple CASE)**
特定の一つの変数の値によって処理を分岐させます。
```sql
DO $$
DECLARE
    role_id integer := 2;
    role_name text;
BEGIN
    CASE role_id
        WHEN 1 THEN role_name := 'Administrator';
        WHEN 2 THEN role_name := 'Manager';
        ELSE role_name := 'Guest';
    END CASE;
    RAISE NOTICE 'Role: %', role_name;
END;
$$;
```

**2. 検索CASE文 (Searched CASE)**
`IF`文のように、各`WHEN`句に独立した条件式を記述できます。
```sql
DO $$
DECLARE
    sales_amount integer := 15000;
    customer_rank text;
BEGIN
    CASE
        WHEN sales_amount > 20000 THEN customer_rank := 'Gold';
        WHEN sales_amount > 10000 THEN customer_rank := 'Silver';
        ELSE customer_rank := 'Bronze';
    END CASE;
    RAISE NOTICE 'Customer Rank: %', customer_rank;
END;
$$;
```

#### ループ：`LOOP`, `WHILE`, `FOR`

##### 0. LOOP ... END LOOP (基本的なループ)
>
最も基本的なループ構造で、`EXIT`や`RETURN`で明示的に脱出しない限り、無限に処理を繰り返します。そのため、必ずループ内に脱出条件を記述する必要があります。

**どのような時に使うか？**
>
*   ループの終了条件が複雑で、ループの先頭（`WHILE`）や末尾で判定できない場合。
*   他のループ構文の基礎を理解するため。

**構文:**

```sql
LOOP
    statements
    IF condition THEN
        EXIT; -- ループを抜ける
    END IF;
END LOOP;
```
>
> **具体例：カウンターが5になったらループを抜ける**
```sql
DO $$
DECLARE
    counter integer := 0;
BEGIN
    LOOP
        counter := counter + 1;
        RAISE NOTICE 'Counter is %', counter;
        -- 脱出条件
        IF counter >= 5 THEN
            EXIT;
        END IF;
    END LOOP;
END;
$$;
```

##### 1. FOR ... IN ... LOOP (クエリ結果のループ)

**実務で最もよく使われるループです。** `SELECT`文の結果セットを 1 行ずつ順番に処理したい場合に非常に便利です。カーソルを明示的に宣言することなく、簡潔に記述できます。

**どのような時に使うか？**

- テーブルの各行に対して、何らかの更新や計算処理を行いたい場合
- 複数のテーブルを結合した結果を基に、複雑な処理を行いたい場合

**構文:**

```sql
FOR target IN query LOOP
    statements
END LOOP;
```

**実用的な例：**
`employees` テーブルの各従業員の給与を 5%昇給させるプロシージャ

```sql
DO $$
DECLARE
    employee_record RECORD;
BEGIN
    FOR employee_record IN SELECT * FROM employees LOOP
        -- 各従業員の給与を更新
        UPDATE employees
        SET salary = salary * 1.05
        WHERE employee_id = employee_record.employee_id;

        RAISE NOTICE 'Updated salary for employee: %', employee_record.employee_name;
    END LOOP;
END;
$$;
```

この例では、`employees`テーブルの全レコードを 1 行ずつ`employee_record`という変数に格納し、ループ内でそのレコードの給与を更新しています。

###### FOR ... IN EXECUTE ... LOOP (動的クエリ結果のループ)

 `FOR`ループは、動的に組み立てたクエリの結果セットに対しても使用できます。`EXECUTE`コマンドと組み合わせることで、実行時まで内容が確定しない`SELECT`文の結果を1行ずつ処理できます。

 **どのような時に使うか？**
 - 検索条件や対象テーブルが動的に変わるクエリ結果をループ処理したい場合。

 **構文:**

 ```sql
 FOR target IN EXECUTE text_expression [ USING expression [, ... ] ] LOOP
     statements
 END LOOP;
 ```

 **具体例：部署IDを動的に指定して、所属する従業員一覧を表示する**

 ```sql
 CREATE OR REPLACE PROCEDURE show_employees_in_department(p_dept_id integer) AS $$
 DECLARE
     -- ループ内で各行のデータを格納するレコード型変数
     employee_rec RECORD;
     query text;
 BEGIN
     query := 'SELECT name, salary FROM employees WHERE department_id = $1 ORDER BY name';

     -- 動的クエリの結果をループ処理
     FOR employee_rec IN EXECUTE query USING p_dept_id LOOP
         RAISE NOTICE 'Name: %, Salary: %', employee_rec.name, employee_rec.salary;
     END LOOP;
 END;
 $$ LANGUAGE plpgsql;

 -- 実行
 CALL show_employees_in_department(10);
 ```
 このように、`USING`句を使うことで、静的な`FOR`ループと同様に安全に値を渡すことができます。

---

##### 2. FOR ... LOOP (整数ループ)

決まった回数だけ処理を繰り返したい場合に使用します。単純な繰り返し処理に適しています。

**どのような時に使うか？**

- 指定した回数だけテストデータを挿入したい場合
- 月ごと（1 月から 12 月まで）の集計処理を行いたい場合

**構文:**

```sql
FOR loop_counter IN [ REVERSE ] from..to [ BY step ] LOOP
    statements
END LOOP;
```

**実用的な例：**
1 月から 12 月までの月別データを集計テーブルに挿入する

```sql
DO $$
BEGIN
    FOR i IN 1..12 LOOP
        -- 各月の売上サマリを計算して挿入する（salesテーブルは別途存在すると仮定）
        INSERT INTO monthly_summary (month, total_sales)
        SELECT i, SUM(amount)
        FROM sales
        WHERE EXTRACT(MONTH FROM sales_date) = i;
    END LOOP;
END;
$$;
```

この例では、カウンタ変数 `i` が 1 から 12 まで 1 ずつ増えながら、12 回ループ処理が実行されます。 `REVERSE` を使うと逆順に、`BY` を使うとステップ数を指定できます。

---

##### 3. WHILE ... LOOP

特定の条件が満たされている間、処理を繰り返したい場合に使用します。 ループの前に条件を評価するため、一度も実行されない可能性があります。

**どのような時に使うか？**

- 特定の状態（例：キューにデータが残っているなど）が解消されるまで処理を続けたい場合
- ループの継続条件が、ループ内の処理によって変化する場合

**構文:**

```sql
WHILE condition LOOP
statements
END LOOP;

```

**実用的な例：**
在庫が 100 個未満になるまで、製品を発注し続ける

```sql
DO $$
DECLARE
    current_stock INT;
BEGIN
    SELECT stock_quantity INTO current_stock FROM products WHERE product_id = 1;

    WHILE current_stock < 100 LOOP
        -- 発注処理（ここでは単純に在庫を10増やす）
        UPDATE products
        SET stock_quantity = stock_quantity + 10
        WHERE product_id = 1
        RETURNING stock_quantity INTO current_stock;

        RAISE NOTICE 'Ordered. Current stock: %', current_stock;
    END LOOP;
END;
$$;
```

---

##### 4. FOREACH ... IN ARRAY ... LOOP

配列の各要素に対して処理を行いたい場合に使用します。

**どのような時に使うか？**

- 引数で受け取った ID の配列を使って、一括でステータスを更新したい場合
- 複数の設定値を配列で管理し、それぞれに対して処理を行いたい場合

**構文:**

```sql
FOREACH target IN ARRAY expression LOOP
    statements
END LOOP;
```

**実用的な例：**
指定された複数の製品 ID の価格を更新する

```sql
DO $$
DECLARE
    product_ids INT[] := ARRAY[101, 105, 120];
    pid INT;
BEGIN
    FOREACH pid IN ARRAY product_ids LOOP
        -- 価格を10%引きにする
        UPDATE products
        SET price = price * 0.9
        WHERE product_id = pid;
    END LOOP;
END;
$$;
```

この例では、`product_ids` 配列の各要素が変数 `pid` に順番に代入され、ループが実行されます。

##### ループの制御 (`EXIT`, `CONTINUE`, ラベル)

*   `EXIT`: 現在のループを即座に終了します。
*   `CONTINUE`: ループの残りの処理をスキップし、次の繰り返しに進みます。

**具体例：`CONTINUE` と `EXIT`**
`WHEN`句と組み合わせることで、`IF`文を使わずに簡潔に記述できます。
```sql
DO $$
BEGIN
    FOR i IN 1..10 LOOP
        CONTINUE WHEN i % 2 = 0; -- iが偶数なら以降をスキップ
        RAISE NOTICE 'Odd number found: %', i;
        EXIT WHEN i >= 7; -- iが7以上になったらループを抜ける
    END LOOP;
END;
$$;
```

**ラベルを使った多重ループの制御**
ネストしたループ（多重ループ）の中から、外側のループをまとめて脱出したい場合、ブロックに**ラベル**を付け、`EXIT label_name;` のように指定します。これは非常に強力なテクニックです。

**具体例：条件に合致したら、すべてのループを抜ける**
```sql
DO $$
<<outer_loop>> -- 外側ループにラベルを付ける
BEGIN
    FOR i IN 1..3 LOOP
        RAISE NOTICE 'Outer: %', i;
        <<inner_loop>> -- 内側ループにもラベルを付けられる
        FOR j IN 1..3 LOOP
            RAISE NOTICE '  Inner: %', j;
            -- 特定の条件になったら、外側のループ(outer_loop)ごと終了する
            IF i = 2 AND j = 2 THEN
                EXIT outer_loop;
            END IF;
        END LOOP;
    END LOOP;
    RAISE NOTICE 'This message will not be displayed.';
END;
$$;
```
**実行結果:**
```
NOTICE:  Outer: 1
NOTICE:    Inner: 1
NOTICE:    Inner: 2
NOTICE:    Inner: 3
NOTICE:  Outer: 2
NOTICE:    Inner: 1
NOTICE:    Inner: 2
```
`i=2`, `j=2`の時点で`outer_loop`が終了するため、その後の処理は実行されません。ラベルを指定しない`EXIT`は、最も内側のループ(`inner_loop`)のみを終了します。

##### まとめ

PL/pgSQL には複数のループ構文がありますが、実務では以下の使い分けが一般的です。

| ループの種類            | よく使われる場面                                                         |
| :---------------------- | :----------------------------------------------------------------------- |
| **FOR ... IN ... LOOP** | **クエリ結果（テーブルの行など）に対する繰り返し処理（最も頻繁に利用）** |
| **FOR ... LOOP**        | 決まった回数の繰り返し                                                   |
| **WHILE ... LOOP**      | 特定の条件が満たされるまでの繰り返し                                     |
| **FOREACH ... LOOP**    | 配列要素に対する繰り返し                                                 |

これらのループを適切に使い分けることで、効率的で可読性の高い PL/pgSQL のコードを記述することができます。