## IV. 関数とプロシージャの詳解 (Deep Dive into Functions and Procedures)

基本的な関数とプロシージャの作り方を学んだところで、次はその能力を最大限に引き出すための詳細な機能を見ていきましょう。引数の渡し方、多様な戻り値の返し方、そしてセキュリティに関する重要な概念を学びます。

### 1. 引数と戻り値

#### 関数とプロシージャ共通

##### 引数モード：`IN`, `OUT`, `INOUT`

引数には、その役割を示す「モード」を指定できます。

*   `IN` (デフォルト): 関数への**入力専用**の引数です。
*   `OUT`: 関数からの**出力専用**の引数です。関数が複数の値を返すための便利な方法です。
*   `INOUT`: **入力と出力の両方**の役割を持つ引数です。関数に渡した変数が、関数内で変更されて返されます。

**具体例(`OUT`): 円の面積と円周を同時に返す**
```sql
CREATE OR REPLACE FUNCTION circle_details(
    radius numeric, -- in
    OUT area numeric,
    OUT circumference numeric
) AS $$
BEGIN
    area := PI() * radius ^ 2;
    circumference := 2 * PI() * radius;
END;
$$ LANGUAGE plpgsql;

-- 呼び出し方 (レコードとして返る)
SELECT * FROM circle_details(10);
```

**具体例(`INOUT`): カウンターの値をインクリメントする**
`INOUT`引数を使うと、渡した変数の値を直接変更できます。
```sql
CREATE OR REPLACE PROCEDURE increment(INOUT counter integer) AS $$
BEGIN
    counter := counter + 1;
END;
$$ LANGUAGE plpgsql;

-- 呼び出し方
DO $$
DECLARE
    v_my_counter integer := 5;
BEGIN
    CALL increment(v_my_counter);
    RAISE NOTICE 'New counter value: %', v_my_counter; -- 結果は 6 になる
END;
$$;
```

##### デフォルト引数と呼び出し記法

引数に`DEFAULT`値を与えると、呼び出し時に省略できます。また、引数の指定方法には2種類あります。

*   **位置記法 (Positional notation)**: `my_func(10, 'text')` のように、定義された順序で値を渡します。
*   **名前付き記法 (Named notation)**: `my_func(name => 'text', id => 10)` のように、`引数名 => 値` の形式で渡します。順序を気にする必要がなく、可読性が向上します。

**具体例：名前付き記法とデフォルト引数**
```sql
CREATE OR REPLACE PROCEDURE write_log(
    message text,
    log_level text DEFAULT 'INFO',
    to_console boolean DEFAULT true
) AS $$
BEGIN
    IF to_console THEN
        RAISE NOTICE '[%] %', log_level, message;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- 呼び出し方
CALL write_log('User logged in.'); -- 位置記法 + デフォルト値を利用
CALL write_log('File not found', 'ERROR'); -- 位置記法
CALL write_log(message => 'DB connection failed', log_level => 'CRITICAL'); -- 名前付き記法
CALL write_log(log_level => 'WARN', message => 'Disk space is low.'); -- 名前付き記法 (順序不問)
```

##### 多重定義 (Overloading)

**関数名が同じでも、引数の数やデータ型が異なれば**、別の関数として定義できます。これを多重定義（オーバーロード）と呼びます。PostgreSQLは、渡された引数の型に応じて適切な関数を自動的に呼び分けます。

**具体例：ID (integer) または 名前 (text) で従業員を検索する**
```sql
-- 1. IDで検索する関数
CREATE OR REPLACE FUNCTION get_employee(p_id integer) RETURNS employees%ROWTYPE AS ...
-- 2. 名前で検索する関数
CREATE OR REPLACE FUNCTION get_employee(p_name text) RETURNS employees%ROWTYPE AS ...
```

##### 可変長引数 (`VARIADIC`)
引数の個数が決まっていない場合に、`VARIADIC`キーワードを使って任意の数の引数を配列として受け取れます。

**具体例：渡された全ての数値を合計する**
```sql
CREATE OR REPLACE FUNCTION sum_all(VARIADIC numbers numeric[])
RETURNS numeric AS $$
DECLARE
    total numeric := 0;
    num numeric;
BEGIN
    FOREACH num IN ARRAY numbers LOOP
        total := total + num;
    END LOOP;
    RETURN total;
END;
$$ LANGUAGE plpgsql;

-- 呼び出し方
SELECT sum_all(10, 20, 30); -- 60
SELECT sum_all(5, 15, 25, 55.5); -- 100.5

-- 【補足】配列を可変長引数に渡す
-- 既に配列がある場合、VARIADICキーワードを付けて渡すことができる
SELECT sum_all(VARIADIC ARRAY[10, 20, 50]); -- 80
```

#### 関数のみ

##### 基本的な戻り値
`RETURNS <type>` を使い、計算結果などを返します。

```sql
CREATE OR REPLACE FUNCTION get_stock_status(stock_quantity integer)
RETURNS text AS $$
BEGIN
    IF stock_quantity <= 0 THEN
        RETURN '在庫切れ';
    ELSIF stock_quantity <= 10 THEN
        RETURN '残りわずか';
    ELSE
        RETURN '在庫あり';
    END IF;
END;
$$ LANGUAGE plpgsql;
```

##### 戻り値がない関数 (`RETURNS void`)
プロシージャのように値を返しませんが、構文上は関数として定義されます。内部で`COMMIT`や`ROLLBACK`はできません。主に副作用（NOTICEの表示や、`dblink`を使った外部DBの更新など）が目的の場合に使われます。

**具体例: メッセージをログに出力する**
```sql
CREATE OR REPLACE FUNCTION write_log_func(
    message text,
    log_level text DEFAULT 'INFO'
)
RETURNS void AS $$ -- 戻り値がvoidであることを明記
BEGIN
    RAISE NOTICE '[%] %', log_level, message;
END;
$$ LANGUAGE plpgsql;

-- 呼び出し方 (SELECT文で呼び出す)
SELECT write_log_func('User logged in.');
```

##### 多様な戻り値 (`SETOF`, `TABLE`)

**`RETURNS SETOF <type>`**: 単一のデータ型の行セット（複数の行）を返します。`RETURN NEXT`で1行ずつ結果セットに追加します。
**`RETURNS TABLE(...)`**: 複数の列を持つテーブル形式で行セットを返します。`RETURN QUERY`でクエリ結果をまとめて返すのが一般的です。

**具体例(`RETURNS SETOF`): 指定された数値までの偶数を返す**
```sql
CREATE OR REPLACE FUNCTION get_even_numbers(up_to integer)
RETURNS SETOF integer AS $$
BEGIN
    FOR i IN 1..up_to LOOP
        IF i % 2 = 0 THEN
            -- 偶数を結果セットに1行追加する
            RETURN NEXT i;
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT * FROM get_even_numbers(10);
```

**具体例(`RETURNS TABLE`): 有効なユーザーのリストを返す**
```sql
CREATE OR REPLACE FUNCTION get_active_users()
RETURNS TABLE(user_id integer, user_name text) AS $$
BEGIN
    -- クエリの結果セットをそのまま関数の戻り値として返す
    RETURN QUERY SELECT id, username FROM users WHERE is_active = true;
END;
$$ LANGUAGE plpgsql;

SELECT * FROM get_active_users();
```

---
### 2. セキュリティと実行権限

関数やプロシージャが「誰の権限で」内部のSQLを実行するのかを定義します。

#### `SECURITY INVOKER` (デフォルト)
**関数を呼び出したユーザーの権限で**内部のSQLが実行されます。これがデフォルトであり、最も安全な選択です。

#### `SECURITY DEFINER`
**関数を作成したユーザー（定義者/所有者）の権限で**内部のSQLが実行されます。呼び出し元にテーブルへの直接のアクセス権を与えず、特定の操作だけを許可したい場合に非常に強力です。

**具体例：プロシージャ経由でのみ監査ログへの書き込みを許可する**
```sql
-- 1. 管理者でテーブルとプロシージャを作成
CREATE TABLE audit_log (log_entry text);
CREATE OR REPLACE PROCEDURE record_audit(entry text)
  LANGUAGE plpgsql
  SECURITY DEFINER -- ★定義者(管理者)の権限で実行
AS $$
BEGIN
  INSERT INTO audit_log (log_entry) VALUES (entry);
END;
$$;
-- プロシージャの実行権限だけを一般ユーザー(app_user)に与える
GRANT EXECUTE ON PROCEDURE record_audit(text) TO app_user;

-- 2. app_userで実行
-- これは失敗する: INSERT INTO audit_log ... (ERROR: permission denied)
-- これは成功する: CALL record_audit('User action recorded.');
```

**【最重要】`SECURITY DEFINER`のベストプラクティス**
`SECURITY DEFINER`は、意図しない権限昇格の脆弱性を生む可能性があるため、細心の注意が必要です。

1.  **SQLインジェクション対策の徹底**: 動的SQLを使う場合は、`format`関数 (`%I`, `%L`) や `USING`句 を使い、外部からの入力を絶対にサニタイズ（無害化）してください。
2.  **`search_path`を明示的に設定する**: 悪意のあるユーザーが同名の偽の関数やテーブルを別スキーマに作成し、それを意図せず実行させてしまう攻撃を防ぐため、関数の先頭で検索パスを安全なものに限定します。
    ```sql
    CREATE FUNCTION privileged_function() RETURNS text AS $$
    #variable_conflict use_variable
    BEGIN ... END;
    $$ LANGUAGE plpgsql SECURITY DEFINER
       SET search_path = public; -- 安全なスキーマに限定
    ```
3.  **最小権限の原則**: 定義者ユーザーは、スーパーユーザーではなく、その関数が必要とする最小限の権限だけを持つ専用のロールにすることが理想です。

---
### 3. トランザクション制御

#### 関数とプロシージャのトランザクションにおける役割の違い

*   **プロシージャ (`PROCEDURE`)**:
    *   独立した処理の単位として設計されています。
    *   内部で`COMMIT`や`ROLLBACK`を実行し、**トランザクションを自律的に制御できます**。

*   **関数 (`FUNCTION`)**:
    *   `SELECT`文などのSQLの一部として呼び出されることを想定しています。
    *   もし関数が勝手に`COMMIT`すると、それを呼び出した外側の`SELECT`文のトランザクションが破壊されてしまいます。
    *   このため、関数内で`COMMIT`や`ROLLBACK`は**使用できません**。

#### プロシージャ内でのトランザクション制御
プロシージャは、一連の処理の原子性（すべて成功するか、すべて失敗するかのいずれか）を保証するのに適しています。
```sql
CREATE OR REPLACE PROCEDURE transfer_money(from_id int, to_id int, amount numeric)
LANGUAGE plpgsql AS $$
BEGIN
    UPDATE accounts SET balance = balance - amount WHERE id = from_id;
    UPDATE accounts SET balance = balance + amount WHERE id = to_id;
    COMMIT; -- 両方のUPDATEが成功したらコミット
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK; -- 何かエラーが起きたら全てをロールバック
        RAISE; -- エラーを再スローする
END;
$$;
```

#### 関数内でのサブトランザクション
関数内で`COMMIT`はできませんが、`BEGIN ... EXCEPTION ... END`ブロックを使うことで**サブトランザクション**を作成できます。これにより、ブロック内で発生したエラーを捕捉し、そのブロック内の変更**だけ**をロールバックして、主トランザクションの処理を続行させることが可能です。**プロシージャでもサブトランザクションを持つことはもちろん可能**。

**具体例：一部の失敗を無視して処理を続ける**
```sql
-- accountsテーブルのid=2のbalanceにCHECK (balance >= 0) 制約があるとする
BEGIN; -- 主トランザクション開始
UPDATE accounts SET balance = 9999 WHERE id = 1;

-- サブトランザクションを開始
BEGIN
    -- このUPDATEはCHECK制約違反でエラーになる
    UPDATE accounts SET balance = -100 WHERE id = 2;
EXCEPTION
    WHEN check_violation THEN
        RAISE NOTICE 'Caught check_violation. Sub-transaction rolled back.';
END;
-- サブトランザクション終了

-- 主トランザクションは続行される
SELECT * FROM accounts;
-- id=1のbalanceは9999になっているが、id=2のbalanceは元のまま
COMMIT; -- 主トランザクションをコミット
```


### まとめ：どちらをいつ使うか？

*   **`SELECT`文の一部として計算結果やデータセットが欲しい場合**
    → **関数 (FUNCTION)** を使います。
*   **複数のデータ更新などをまとめて、一連の処理として成功か失敗かを保証したい場合**
    → **プロシージャ (PROCEDURE)** を使います。
*   **トランザクション制御 (`COMMIT`/`ROLLBACK`) が必要な場合**
    → **プロシージャ (PROCEDURE)** を使います。
*   **副作用（ログ出力など）が目的で戻り値は不要だが、`SELECT`文の文脈で呼び出したい場合**
    → **`void`を返す関数 (FUNCTION)** を使います。