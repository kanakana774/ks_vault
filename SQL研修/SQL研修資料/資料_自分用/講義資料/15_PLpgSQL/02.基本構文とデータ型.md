### II. 基本構文とデータ型 (Basic Syntax and Data Types)

PL/pgSQLで意味のある処理を行うには、データを一時的に保存しておく「変数」が不可欠です。この単元では、変数をどのように宣言し、どのような種類のデータを扱えるのか、そして変数に値を設定する方法を学びます。

#### 1. 宣言とスコープ

##### 変数の宣言とデータ型指定

変数は、`DECLARE`セクションで宣言します。宣言の基本構文は以下の通りです。

`variable_name [ CONSTANT ] data_type [ NOT NULL ] [ { DEFAULT | := | = } expression ];`

**【補足】変数の命名規則に関する慣習**
必須ではありませんが、コードの可読性を高めるために、変数の役割に応じた接頭辞（プレフィックス）を付けることが推奨されます。
*   `v_` : 一般的な変数 (例: `v_user_name`)
*   `p_` : 関数の引数 (例: `p_employee_id`)
*   `c_` : 定数 (例: `c_tax_rate`)
*   `r_` または `rec_` : レコード型の変数 (例: `r_employee`)

**具体例：基本的な変数を宣言する**

```sql
DO $$
DECLARE
    v_user_name   text;  -- TEXT型の変数を宣言
    v_user_id     integer := 101;  -- 宣言と同時に初期値を代入
    d_signup_date date DEFAULT '2025-11-01'; -- DEFAULT句で初期値を代入
    b_is_active   boolean NOT NULL = true; -- NULLを許容しない制約
    C_PI          CONSTANT numeric := 3.14159; -- 定数の宣言
BEGIN
    v_user_name := 'Hanako Suzuki';

    RAISE NOTICE 'User ID: %, Name: %, Active: %', v_user_id, v_user_name, b_is_active;
    RAISE NOTICE 'Signup Date: %', d_signup_date;
    RAISE NOTICE 'PI: %', C_PI;
END;
$$ LANGUAGE plpgsql;
```

**実行結果:**

```
NOTICE:  User ID: 101, Name: Hanako Suzuki, Active: true
NOTICE:  Signup Date: 2025-11-01
NOTICE:  PI: 3.14159
```

##### スコープ：変数が有効な範囲

変数が使える範囲（スコープ）は、その変数が宣言された`BEGIN ... END`ブロックの内部に限られます。ブロックを入れ子にすることもでき、内側のブロックは外側のブロックで宣言された変数にアクセスできます。

**具体例：ブロックのスコープを確認する**

```sql
DO $$
DECLARE
    v_outer_variable integer := 10;
BEGIN
    RAISE NOTICE 'Outer block: v_outer_variable = %', v_outer_variable; -- => 10

    -- 内側のブロックを開始
    DECLARE
        v_inner_variable integer := 20;
    BEGIN
        RAISE NOTICE 'Inner block: v_outer_variable = %', v_outer_variable; -- 外側の変数にアクセス可能 => 10
        RAISE NOTICE 'Inner block: v_inner_variable = %', v_inner_variable; -- => 20
    END;
    -- 内側のブロックが終了

    -- ここでv_inner_variableにアクセスしようとするとエラーになる
    -- RAISE NOTICE 'Outer block: v_inner_variable = %', v_inner_variable; -- ERROR: "v_inner_variable" does not exist
END;
$$ LANGUAGE plpgsql;
```

##### ラベル付きブロックと修飾名

ブロックには `<<label_name>>` という形式で**ラベル**を付けることができます。これは、主に2つの目的で役立ちます。

1.  **変数名の競合を解決する**: 内側と外側のブロックで同じ名前の変数を宣言した場合でも、`label_name.variable_name` という「修飾名」を使うことで、外側のブロックの変数を明示的に参照できます。
2.  **ループの制御**: `LOOP` 構文と組み合わせることで、多重ループの中から特定のループを `EXIT` したり `CONTINUE` したりできます（詳細は制御構造の章で解説）。

**具体例：ラベルを使って同名変数にアクセスする**

```sql
DO $$
<<outer_block>>
DECLARE
    v_counter integer := 1;
BEGIN
    RAISE NOTICE 'Outer block counter: %', outer_block.v_counter; -- => 1

    <<inner_block>>
    DECLARE
        v_counter integer := 2;
    BEGIN
        RAISE NOTICE 'Inner block counter: %', inner_block.v_counter; -- => 2

        -- ラベルを使って外側のブロックの変数にアクセスする
        RAISE NOTICE 'Outer counter from inner block: %', outer_block.v_counter; -- => 1

        -- ラベルを付けないと、最も内側のスコープにある変数が参照される
        RAISE NOTICE 'Counter without label in inner block: %', v_counter; -- => 2
    END;

    RAISE NOTICE 'Back in outer block, counter is: %', v_counter; -- => 1
END;
$$ LANGUAGE plpgsql;
```

#### 2. 主要なデータ型と操作

PL/pgSQLでは、PostgreSQLがサポートするすべてのデータ型を利用できます。ここでは特に利用頻度の高いものを紹介します。

**基本的なデータ型**

| カテゴリ | データ型 | 説明 |
| :--- | :--- | :--- |
| **数値型** | `integer` | 整数を格納します。 |
| | `numeric(p, s)` | 固定小数点数を正確に格納します。金額計算などに適しています。 |
| | `double precision` | 浮動小数点数を格納します。 |
| **文字列型**| `text` | 長さ制限のない可変長の文字列を格納します。 |
| | `varchar(n)` | 最大長nの可変長文字列を格納します。 |
| **日付/時刻型**| `date` | 日付のみを格納します。 |
| | `time` | 時刻のみを格納します。 |
| | `timestamp` | 日付と時刻の両方を格納します。 |
| **論理型**| `boolean` | `true`, `false`, `NULL`のいずれかの値を格納します。|

##### 便利な属性：`%TYPE` と `%ROWTYPE`

テーブルの定義が変わるたびにPL/pgSQLのコードを修正するのは大変です。`%TYPE`と`%ROWTYPE`を使うと、テーブル定義に連動する変数を簡単に作成でき、メンテナンス性が向上します。

*   **`%TYPE`**: テーブルの**特定の列と同じデータ型**を持つ変数を宣言します。
*   **`%ROWTYPE`**: テーブルの**行全体と同じ構造**を持つレコード型変数を宣言します。

**具体例：`employees`テーブルの型を利用する**
(この例を実行するには、`employees`テーブルが必要です: `CREATE TABLE employees (id serial primary key, name text); INSERT INTO employees (name) VALUES ('Taro Yamada');`)

```sql
CREATE OR REPLACE FUNCTION get_employee_name(p_employee_id integer)
RETURNS text AS $$
DECLARE
    -- employeesテーブルのname列と同じ型を持つ変数を宣言
    v_employee_name employees.name%TYPE;
BEGIN
    SELECT name INTO v_employee_name
    FROM employees
    WHERE id = p_employee_id;

    RETURN v_employee_name;
END;
$$ LANGUAGE plpgsql;
```
このコードは、将来`employees`テーブルの`name`列のデータ型が`text`から`varchar(100)`に変更されても、修正する必要がありません。


##### 複合型 (`CREATE TYPE`) と レコード型 (`RECORD`)

複数のデータをひとまとめにして扱いたい場合に便利です。

*   **複合型 (Composite Type)**: 事前に`CREATE TYPE`で型（フィールド名とデータ型のセット）を定義しておく必要があります。構造が固定されている場合に適しています。
*   **レコード型 (Record Type)**: 型を事前に定義する必要がない、柔軟な複合型です。`SELECT`の結果を一時的に格納する際に、その問い合わせの列構造に応じて**動的に構造が決まります**。

**具体例：複合型を利用する**

```sql
-- 1. 住所を格納するための複合型を定義
CREATE TYPE address_type AS (
    postal_code text,
    prefecture  text,
    city        text
);

-- 2. 複合型を変数として利用する
DO $$
DECLARE
    -- address_type型の変数を宣言
    v_office_address address_type;
BEGIN
    -- 各フィールドに値を代入
    v_office_address.postal_code := '100-0001';
    v_office_address.prefecture  := '東京都';
    v_office_address.city        := '千代田区';

    RAISE NOTICE 'City: %', v_office_address.city; -- フィールドにアクセス

    -- ROWコンストラクタを使って一括で代入も可能
    v_office_address := ROW('108-0075', '東京都', '港区');
    RAISE NOTICE 'New City: %', v_office_address.city;
END;
$$ LANGUAGE plpgsql;
```

##### 列挙型 (`ENUM`)

`CREATE TYPE ... AS ENUM` を使うと、事前定義された定数のリストの中から値を選択する、独自のデータ型を作成できます。状態管理（例: '保留中', '承認済', '却下'）などに最適です。

**具体例: タスクの状態を管理するENUM型**
```sql
-- 1. ENUM型を定義
CREATE TYPE task_status AS ENUM ('pending', 'in_progress', 'completed', 'cancelled');

-- 2. ENUM型を使う関数
DO $$
DECLARE
    v_current_status task_status;
BEGIN
    v_current_status := 'in_progress';
    RAISE NOTICE 'Current task status: %', v_current_status;

    -- 型に定義されていない値を代入しようとするとエラーになる
    -- v_current_status := 'waiting'; -- ERROR: invalid input value for enum task_status
END;
$$ LANGUAGE plpgsql;
```

##### 配列 (`ARRAY`)

同じデータ型の要素の集まりを格納できます。

**具体例：配列をループ処理する**
```sql
DO $$
DECLARE
    -- テキスト型の配列を宣言し、初期化
    v_user_names text[] := ARRAY['Alice', 'Bob', 'Charlie'];
    v_name text;
BEGIN
    RAISE NOTICE 'Third user is: %', v_user_names[3]; -- 配列のインデックスは1から始まる
    RAISE NOTICE 'Array length is: %', array_length(v_user_names, 1); -- 配列の長さを取得

    -- FOREACHを使って配列の各要素をループ処理
    FOREACH v_name IN ARRAY v_user_names
    LOOP
        RAISE NOTICE 'Processing user: %', v_name;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

##### JSON/JSONB

現代のアプリケーションで多用されるJSON形式のデータを扱うための強力なデータ型です。特に理由がなければ、インデックスが利用でき効率的な**`JSONB`**を使いましょう。

**具体例：JSONBデータから情報を取り出す**

```sql
DO $$
DECLARE
    j_user_info jsonb;
BEGIN
    j_user_info := '{ "id": 123, "name": "David", "is_premium": true, "tags": ["A", "B", "C"] }';

    RAISE NOTICE 'Original JSON: %', j_user_info;

    -- 主要な演算子
    RAISE NOTICE 'Name (text): %', j_user_info ->> 'name'; -- `->>`: textで取得
    RAISE NOTICE 'Tags (jsonb): %', j_user_info -> 'tags'; -- `->`: jsonbで取得
    RAISE NOTICE 'Second tag (text): %', j_user_info -> 'tags' ->> 1; -- 配列要素にアクセス(0-indexed)
    RAISE NOTICE 'Is name key exists?: %', j_user_info ? 'name'; -- `?`: トップレベルのキーが存在するか
END;
$$ LANGUAGE plpgsql;
```

---

#### 3. 代入と式

##### 代入演算子 (`:=` または `=`)

変数に値を設定（代入）するには、`:=` を使うのが一般的です。`=`も使えますが、SQLの比較演算子と見分けにくくなるため、PL/pgSQL内では `:=` の使用が推奨されます。

##### `SELECT ... INTO ...` による代入

SQLクエリの結果を直接変数に代入するための、非常に重要な構文です。

**【重要】 `INTO`句の注意点**
`SELECT ... INTO ...` は、クエリが**厳密に1行だけ**を返すことを期待します。
*   **0行の場合**: `NO_DATA_FOUND` という例外が発生します。
*   **2行以上の場合**: `TOO_MANY_ROWS` という例外が発生します。

これらの例外は、`EXCEPTION`ブロックで捕捉して処理する必要があります。

**具体例：`SELECT INTO` を使った代入**
(この例を実行するには、`employees`テーブルとデータが必要です)
```sql
DO $$
DECLARE
    v_employee_name employees.name%TYPE;
    r_employee      employees%ROWTYPE;
BEGIN
    -- 1. 単一の列を単一の変数に代入
    SELECT name INTO v_employee_name FROM employees WHERE id = 1;
    RAISE NOTICE 'Employee ID 1 is %.', v_employee_name;

    -- 2. 行全体をレコード型変数に代入
    SELECT * INTO r_employee FROM employees WHERE id = 1;
    RAISE NOTICE 'Employee ID 1 is %.', r_employee.name;
END;
$$ LANGUAGE plpgsql;
```

##### `PERFORM`：結果を破棄するクエリの実行

`PERFORM`は、**クエリの結果（戻り値）を必要としない場合**に使用する特殊なコマンドです。これがなぜ必要かを理解するには、PL/pgSQLの重要なルールを知る必要があります。

**【重要】PL/pgSQLにおける `SELECT` のルール**
PL/pgSQLブロック内で `SELECT` 文を直接実行する場合、その結果は**必ず**どこかに格納されなければなりません。通常は `SELECT ... INTO ...` 構文を使って変数に格納します。もし `INTO` 句なしで `SELECT` を実行すると、「`query has no destination for result data`」というエラーが発生します。

しかし、関数の中には、データの取得が目的ではなく、**副作用（データの変更、ログの記録、一時停止など）**を目的とするものがあります。これらの関数の結果は不要ですが、`SELECT` を使って呼び出すと上記のエラーが発生してしまいます。

そこで `PERFORM` の出番です。`PERFORM` は、`SELECT` 文を実行し、その**結果セットをすべて破棄**します。これにより、エラーを回避しつつ、関数の副作用だけを安全に実行できます。

**`PERFORM` の主な用途**

1.  **戻り値が不要な関数を呼び出す**
    `pg_sleep()` のようなシステム関数や、`INSERT` を内部で行う自作関数など、戻り値自体には関心がない場合に利用します。

2.  **トリガー関数内での存在チェック**
    トリガー内で「特定の条件を満たすレコードが存在するかどうか」だけを確認し、その内容自体は不要な場合などに使われます。

**具体例：`PERFORM` の必要性を理解する**

```sql
DO $$
BEGIN
    -- 【エラーになる例】
    -- SELECT now(); -- ERROR: query has no destination for result data
    -- now()は値を返すが、その値を格納する INTO句 がないためエラーになる。

    -- 【正しい例】
    -- now() の結果は不要で、単に実行したい（または副作用が目的の関数を呼びたい）場合
    PERFORM now();
    RAISE NOTICE 'The PERFORM statement executed successfully.';

    -- データ変更言語（DML）は PERFORM がなくても直接実行可能
    -- INSERT, UPDATE, DELETE は値を返さないため、そのまま記述できる
    -- CREATE TABLE IF NOT EXISTS logs (message text, created_at timestamptz);
    -- INSERT INTO logs (message, created_at) VALUES ('PERFORM test', now());

END;
$$ LANGUAGE plpgsql;
```
このように、`PERFORM`は「値を返すけれども、その値は要らない」という状況で、PL/pgSQLの構文ルールを守るために不可欠なコマンドです。主に `SELECT` 文に対して使われ、`INSERT` や `UPDATE` などには通常不要です。
##### PL/pgSQL内でのSQL式の評価

変数の代入や計算には、数値計算だけでなく、PostgreSQLの組み込み関数なども自由に使用できます。

**具体例：税込み価格を計算する**

```sql
DO $$
DECLARE
    v_price           numeric := 1000;
    c_tax_rate        numeric := 0.1;
    v_price_with_tax  numeric;
    dt_current_time   timestamp;
    v_current_user    text;
BEGIN
    -- 変数と定数を使った計算
    v_price_with_tax := v_price * (1 + c_tax_rate);

    -- SQL関数（now()やcurrent_user）の結果を変数に代入
    dt_current_time := now();
    v_current_user := current_user;

    -- 型変換（キャスト）して表示
    RAISE NOTICE 'Price with tax: %', v_price_with_tax::text;

    RAISE NOTICE 'Current time: %', dt_current_time;
    RAISE NOTICE 'DB User: %', v_current_user;
END;
$$ LANGUAGE plpgsql;
```